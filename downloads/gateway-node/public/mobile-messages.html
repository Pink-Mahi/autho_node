<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f7931a">
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" type="image/svg+xml" href="/icons/autho-192.svg">
  <title>Messages - Autho</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Georgia', 'Times New Roman', serif;
      background: linear-gradient(180deg, #0d0d0d 0%, #1a1a1a 50%, #0a0a0a 100%);
      color: #fff;
      min-height: 100vh;
    }
    .messages-container {
      max-width: 600px;
      margin: 0 auto;
      padding: 1rem;
    }

    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(212, 175, 55, 0.2);
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .back-to-dashboard {
      color: #d4af37;
      text-decoration: none;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.4rem 0.75rem;
      border: 1px solid rgba(212, 175, 55, 0.4);
      border-radius: 6px;
      background: rgba(212, 175, 55, 0.1);
      transition: all 0.2s;
    }

    .back-to-dashboard:hover {
      background: rgba(212, 175, 55, 0.2);
      border-color: #d4af37;
    }

    .page-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #d4af37;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .inbox-stats {
      font-size: 0.875rem;
      color: #888;
    }

    .conversation-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .conversation-card {
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .conversation-card:hover {
      border-color: #d4af37;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(212, 175, 55, 0.15);
    }

    .conversation-card.unread {
      border-left: 3px solid #d4af37;
    }

    .conversation-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.5rem;
    }

    .conversation-participant {
      font-weight: 600;
      color: #fff;
    }

    .conversation-time {
      font-size: 0.75rem;
      color: #888;
    }

    .conversation-preview {
      font-size: 0.875rem;
      color: #aaa;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .conversation-item-badge {
      display: inline-block;
      background: rgba(212, 175, 55, 0.2);
      color: #d4af37;
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      margin-top: 0.5rem;
    }

    .unread-badge {
      background: #d4af37;
      color: #000;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 0.2rem 0.5rem;
      border-radius: 10px;
      min-width: 1.2rem;
      text-align: center;
    }

    .empty-inbox {
      text-align: center;
      padding: 3rem 1rem;
      color: #888;
    }

    .empty-inbox-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .empty-inbox-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #aaa;
      margin-bottom: 0.5rem;
    }

    /* Chat View */
    .chat-view {
      display: none;
      flex-direction: column;
      height: calc(100vh - 120px);
    }

    .chat-view.active {
      display: flex;
    }

    .chat-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border-bottom: 2px solid rgba(212, 175, 55, 0.4);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .chat-back-btn {
      background: none;
      border: none;
      color: #d4af37;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem;
    }

    .chat-participant-name {
      font-weight: 600;
      color: #fff;
    }

    .chat-item-context {
      font-size: 0.75rem;
      color: #888;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .message-bubble {
      max-width: 80%;
      padding: 0.75rem 1rem;
      border-radius: 16px;
      position: relative;
    }

    .message-bubble.sent {
      align-self: flex-end;
      background: linear-gradient(135deg, #d4af37, #b8962e);
      color: #0d0d0d;
      border-bottom-right-radius: 4px;
      box-shadow: 0 2px 10px rgba(212, 175, 55, 0.3);
    }

    .message-bubble.received {
      align-self: flex-start;
      background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
      border: 1px solid rgba(212, 175, 55, 0.2);
      color: #fff;
      border-bottom-left-radius: 4px;
    }

    .message-text {
      word-wrap: break-word;
    }

    .message-meta {
      font-size: 0.65rem;
      opacity: 0.7;
      margin-top: 0.25rem;
      text-align: right;
    }

    .message-expires {
      font-size: 0.6rem;
      color: #888;
    }

    .media-buttons-row {
      display: flex;
      justify-content: center;
      gap: 0.75rem;
      padding: 0.5rem 0.75rem;
      background: linear-gradient(180deg, #1a1a1a, #0d0d0d);
      border-top: 1px solid rgba(212, 175, 55, 0.3);
    }

    .media-buttons-row .media-btn {
      flex: 1;
      max-width: 100px;
      padding: 0.4rem 0.6rem;
      background: rgba(50, 50, 50, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      color: #d4af37;
      font-size: 0.75rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
    }

    .media-buttons-row .media-btn:active {
      background: rgba(212, 175, 55, 0.2);
    }

    .chat-input-row {
      display: flex;
      padding: 0.5rem 0.75rem;
      background: linear-gradient(180deg, #1a1a1a, #0d0d0d);
    }

    .chat-actions-row {
      display: flex;
      gap: 0.75rem;
      padding: 0.5rem 0.75rem 0.75rem;
      background: linear-gradient(180deg, #0d0d0d, #0a0a0a);
      justify-content: center;
    }

    .chat-input {
      flex: 1;
      background: rgba(50, 50, 50, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 20px;
      padding: 0.75rem 1rem;
      color: #fff;
      font-size: 1rem;
    }

    .chat-input:focus {
      outline: none;
      border-color: #d4af37;
    }

    .chat-send-btn {
      background: linear-gradient(135deg, #d4af37, #b8962e);
      border: 1px solid #d4af37;
      border-radius: 12px;
      flex: 1;
      height: 44px;
      color: #0d0d0d;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
      transition: all 0.2s;
    }

    .chat-send-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
    }

    .chat-send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Push-to-Talk Button */
    .ptt-btn {
      background: linear-gradient(145deg, #2a5d2a, #1a3d1a);
      border: 2px solid #4CAF50;
      border-radius: 12px;
      flex: 1;
      height: 44px;
      color: #fff;
      cursor: pointer;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: all 0.2s;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }

    .ptt-btn:active, .ptt-btn.recording {
      background: linear-gradient(145deg, #4CAF50, #2E7D32);
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
    }

    .ptt-icon {
      font-size: 1.1rem;
      line-height: 1;
    }

    .ptt-text {
      font-size: 0.5rem;
      font-weight: bold;
      text-transform: uppercase;
    }

    .ptt-recording {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #4CAF50;
      border-radius: 20px;
      padding: 2rem 3rem;
      z-index: 1000;
      text-align: center;
    }

    .ptt-recording.active {
      display: block;
    }

    .ptt-pulse {
      width: 60px;
      height: 60px;
      background: #4CAF50;
      border-radius: 50%;
      margin: 0 auto 1rem;
      animation: ptt-pulse 1s ease-in-out infinite;
    }

    @keyframes ptt-pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
    }

    .ptt-status {
      color: #fff;
      font-size: 1rem;
      font-weight: 500;
    }

    /* Auto-play indicator for voice messages */
    .voice-message {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid rgba(76, 175, 80, 0.4);
      border-radius: 12px;
      padding: 0.5rem;
    }

    .voice-message.new {
      animation: voice-new 0.5s ease-out;
    }

    @keyframes voice-new {
      0% { transform: scale(0.9); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    .encryption-notice {
      text-align: center;
      font-size: 0.7rem;
      color: #666;
      padding: 0.5rem;
    }

    .encryption-notice span {
      color: #4CAF50;
    }

    .loading-spinner {
      display: flex;
      justify-content: center;
      padding: 2rem;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(212, 175, 55, 0.2);
      border-top-color: #d4af37;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .nav-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .nav-tab {
      flex: 1;
      padding: 0.75rem;
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      color: #ccc;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    .nav-tab.active {
      background: rgba(212, 175, 55, 0.2);
      border-color: #d4af37;
      color: #d4af37;
    }

    .contacts-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .contact-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      transition: all 0.2s;
    }

    .contact-card:hover {
      border-color: #d4af37;
      box-shadow: 0 4px 15px rgba(212, 175, 55, 0.15);
    }

    .contact-info {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .contact-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(212, 175, 55, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #d4af37;
      font-weight: 600;
    }

    .contact-name {
      font-weight: 500;
      color: #fff;
    }

    .contact-role {
      font-size: 0.75rem;
      color: #888;
    }

    .contact-actions button {
      background: none;
      border: 1px solid rgba(212, 175, 55, 0.3);
      color: #d4af37;
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .share-btn {
      background: rgba(212, 175, 55, 0.2);
      border: 1px solid #d4af37;
      color: #d4af37;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .add-contact-btn {
      background: #d4af37;
      border: none;
      color: #000;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .contact-buttons {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .privacy-toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.65rem 0.75rem;
      border: 1px solid rgba(212, 175, 55, 0.25);
      border-radius: 10px;
      margin-bottom: 0.75rem;
      background: rgba(212, 175, 55, 0.08);
    }

    .privacy-toggle-label {
      font-size: 0.82rem;
      color: #d9d9d9;
      line-height: 1.25;
    }

    .privacy-toggle-label strong {
      color: #f0d57a;
      display: block;
      margin-bottom: 0.1rem;
    }

    .privacy-toggle {
      width: 44px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(212, 175, 55, 0.45);
      background: rgba(255, 255, 255, 0.12);
      position: relative;
      cursor: pointer;
      transition: background 0.2s ease;
      flex: 0 0 auto;
    }

    .privacy-toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      transition: transform 0.2s ease;
    }

    .privacy-toggle.active {
      background: rgba(76, 175, 80, 0.5);
    }

    .privacy-toggle.active::after {
      transform: translateX(20px);
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 1rem;
    }

    .modal-content {
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border: 2px solid rgba(212, 175, 55, 0.4);
      border-radius: 16px;
      padding: 1.5rem;
      max-width: 400px;
      width: 100%;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(212, 175, 55, 0.1);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #d4af37;
    }

    .modal-close {
      background: none;
      border: none;
      color: #888;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .qr-container {
      background: #fff;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 1rem;
    }

    .qr-container canvas, .qr-container img {
      max-width: 200px;
    }

    .share-link-container {
      background: rgba(50, 50, 50, 0.5);
      border: 1px solid rgba(212, 175, 55, 0.2);
      border-radius: 8px;
      padding: 0.75rem;
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .share-link-input {
      flex: 1;
      background: none;
      border: none;
      color: #fff;
      font-size: 0.8rem;
      outline: none;
    }

    .copy-btn {
      background: #d4af37;
      border: none;
      color: #000;
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .modal-input {
      width: 100%;
      background: rgba(50, 50, 50, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      padding: 0.75rem;
      color: #fff;
      font-size: 1rem;
      margin-bottom: 1rem;
    }

    .modal-input:focus {
      outline: none;
      border-color: #d4af37;
    }

    .modal-btn {
      width: 100%;
      background: linear-gradient(135deg, #d4af37, #b8962e);
      border: 1px solid #d4af37;
      color: #0d0d0d;
      padding: 0.75rem;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
    }

    .modal-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
    }

    .modal-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .share-instructions {
      text-align: center;
      color: #888;
      font-size: 0.875rem;
      margin-bottom: 1rem;
    }

    .add-contact-chat-btn {
      background: rgba(212, 175, 55, 0.2);
      border: 1px solid #d4af37;
      color: #d4af37;
      padding: 0.4rem 0.75rem;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      white-space: nowrap;
    }

    .add-contact-chat-btn.added {
      background: rgba(76, 175, 80, 0.2);
      border-color: #4CAF50;
      color: #4CAF50;
    }

    /* Media Messaging Styles */
    .media-buttons {
      display: flex;
      gap: 0.25rem;
      padding-right: 0.5rem;
    }

    .media-btn {
      background: transparent;
      border: none;
      color: #888;
      font-size: 1.25rem;
      padding: 0.5rem;
      cursor: pointer;
      border-radius: 50%;
      transition: all 0.2s;
    }

    .media-btn:hover {
      color: #d4af37;
      background: rgba(212, 175, 55, 0.1);
    }

    .media-btn.recording {
      color: #ff4444;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .media-preview {
      background: rgba(30, 30, 30, 0.95);
      padding: 0.75rem;
      border-top: 1px solid rgba(212, 175, 55, 0.2);
      display: none;
    }

    .media-preview.active {
      display: block;
    }

    .media-preview-content {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .media-preview img,
    .media-preview video {
      max-width: 120px;
      max-height: 80px;
      border-radius: 8px;
      object-fit: cover;
    }

    .media-preview-info {
      flex: 1;
      color: #888;
      font-size: 0.75rem;
    }

    .media-preview-name {
      color: #fff;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .media-preview-remove {
      background: rgba(255, 68, 68, 0.2);
      border: none;
      color: #ff4444;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
    }

    .audio-recorder {
      display: none;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: rgba(30, 30, 30, 0.95);
      border-top: 1px solid rgba(212, 175, 55, 0.2);
    }

    .audio-recorder.active {
      display: flex;
    }

    .audio-timer {
      color: #ff4444;
      font-family: monospace;
      font-size: 1rem;
      min-width: 50px;
    }

    .audio-waveform {
      flex: 1;
      height: 30px;
      background: rgba(255, 68, 68, 0.1);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
    }

    .audio-bar {
      width: 3px;
      background: #ff4444;
      border-radius: 2px;
      animation: audioWave 0.5s ease-in-out infinite;
    }

    @keyframes audioWave {
      0%, 100% { height: 5px; }
      50% { height: 20px; }
    }

    .audio-cancel-btn {
      background: rgba(255, 68, 68, 0.2);
      border: none;
      color: #ff4444;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
    }

    .audio-send-btn {
      background: #d4af37;
      border: none;
      color: #000;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
    }

    .message-media {
      margin-top: 0.5rem;
      max-width: 250px;
    }

    .message-media img {
      width: 100%;
      border-radius: 8px;
      cursor: pointer;
    }

    .message-media video {
      width: 100%;
      border-radius: 8px;
    }

    .message-media audio {
      width: 100%;
      height: 36px;
    }

    .media-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .media-fullscreen.active {
      display: flex;
    }

    .media-fullscreen img,
    .media-fullscreen video {
      max-width: 95%;
      max-height: 95%;
      object-fit: contain;
    }

    .media-fullscreen-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .hidden-input {
      display: none;
    }

    /* Group Chat Styles */
    .group-card {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid rgba(76, 175, 80, 0.3);
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .group-card:hover {
      border-color: #4CAF50;
      transform: translateY(-2px);
    }

    .group-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(76, 175, 80, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #4CAF50;
      font-size: 1.2rem;
      margin-right: 0.75rem;
    }

    .group-name {
      font-weight: 600;
      color: #fff;
    }

    .group-members-count {
      font-size: 0.75rem;
      color: #888;
    }

    .create-group-btn {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid #4CAF50;
      color: #4CAF50;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .member-select-list {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 1rem;
    }

    .member-select-item {
      display: flex;
      align-items: center;
      padding: 0.5rem;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .member-select-item:hover {
      background: rgba(212, 175, 55, 0.1);
    }

    .member-select-item.selected {
      background: rgba(76, 175, 80, 0.2);
    }

    .member-checkbox {
      width: 20px;
      height: 20px;
      margin-right: 0.75rem;
      accent-color: #4CAF50;
    }

    .group-header-info {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .group-message-sender {
      font-size: 0.7rem;
      color: #4CAF50;
      margin-bottom: 0.25rem;
    }

    .section-divider {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin: 1rem 0;
      color: #666;
      font-size: 0.8rem;
    }

    .section-divider::before,
    .section-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: rgba(212, 175, 55, 0.2);
    }

    /* Disappearing Messages Styles */
    .timer-selector {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: rgba(30, 30, 30, 0.9);
      border-radius: 8px;
      margin-bottom: 0.5rem;
    }

    .timer-selector select {
      background: #333;
      border: 1px solid #555;
      color: #fff;
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .timer-label {
      color: #888;
      font-size: 0.8rem;
    }

    .message-expiry {
      font-size: 0.65rem;
      color: #ff9800;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }

    .message-expiry.urgent {
      color: #f44336;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .message-delete-btn {
      position: absolute;
      top: 0.25rem;
      right: 0.25rem;
      background: rgba(244, 67, 54, 0.8);
      border: none;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      font-size: 0.7rem;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .message-bubble:hover .message-delete-btn {
      opacity: 1;
    }

    .message-bubble {
      position: relative;
    }

    .disappearing-indicator {
      display: inline-block;
      margin-left: 0.25rem;
      color: #ff9800;
    }

    .media-type-badge {
      font-size: 0.65rem;
      background: rgba(255, 255, 255, 0.1);
      padding: 0.1rem 0.3rem;
      border-radius: 4px;
      margin-left: 0.25rem;
    }

    /* Message Context Menu */
    .message-context-menu {
      position: fixed;
      background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
      border: 1px solid rgba(212, 175, 55, 0.4);
      border-radius: 12px;
      padding: 0.5rem 0;
      min-width: 160px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      z-index: 2000;
      display: none;
    }

    .message-context-menu.active {
      display: block;
    }

    .context-menu-item {
      padding: 0.75rem 1rem;
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: background 0.2s;
    }

    .context-menu-item:hover {
      background: rgba(212, 175, 55, 0.1);
    }

    .context-menu-item.delete {
      color: #ff5757;
    }

    .context-menu-item .price-tag {
      margin-left: auto;
      font-size: 0.75rem;
      color: #888;
      background: rgba(99, 102, 241, 0.2);
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
    }

    /* Encryption Info Modal */
    .encryption-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .encryption-modal.active {
      display: flex;
    }

    .encryption-modal-content {
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border: 2px solid rgba(99, 102, 241, 0.4);
      border-radius: 20px;
      padding: 1.5rem;
      max-width: 400px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .encryption-modal-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.25rem;
      color: #6366f1;
      font-size: 1.25rem;
      font-weight: 600;
    }

    .encryption-feature {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      padding: 0.75rem 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .encryption-feature:last-child {
      border-bottom: none;
    }

    .encryption-feature-icon {
      font-size: 1.25rem;
      min-width: 28px;
    }

    .encryption-feature-text {
      flex: 1;
    }

    .encryption-feature-title {
      color: #fff;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .encryption-feature-desc {
      color: #888;
      font-size: 0.85rem;
      line-height: 1.4;
    }

    .encryption-close-btn {
      width: 100%;
      margin-top: 1rem;
      padding: 0.75rem;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      border: none;
      border-radius: 10px;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }

    /* Premium File Tiers */
    .file-tier-selector {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .file-tier-btn {
      flex: 1;
      padding: 0.5rem;
      background: rgba(50, 50, 50, 0.6);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      color: #ccc;
      font-size: 0.7rem;
      cursor: pointer;
      text-align: center;
    }

    .file-tier-btn.active {
      background: rgba(99, 102, 241, 0.2);
      border-color: #6366f1;
      color: #6366f1;
    }

    .file-tier-btn .tier-size {
      font-weight: 600;
      display: block;
    }

    .file-tier-btn .tier-price {
      font-size: 0.65rem;
      color: #888;
    }
  </style>
</head>
<body>
  <div class="messages-container">
    <!-- Inbox View -->
    <div id="inboxView">
      <div class="page-header">
        <a href="/m/wallet" class="back-to-dashboard">‚Üê Dashboard</a>
        <div class="page-title">
          <span>üí¨</span> Messages
        </div>
        <div class="inbox-stats" id="inboxStats">Loading...</div>
      </div>

      <!-- Service Balance Bar -->
      <div id="serviceBalanceBar" style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 10px 16px; display: flex; justify-content: space-between; align-items: center; border-radius: 10px; margin: 0 16px 12px 16px;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <span style="font-size: 16px;">‚ö°</span>
          <span style="color: #fff; font-size: 14px;">Service Credits:</span>
          <span id="msgServiceBalance" style="color: #fff; font-weight: 700; font-size: 16px;">0</span>
          <span style="color: rgba(255,255,255,0.8); font-size: 12px;">sats</span>
        </div>
        <button onclick="window.location.href='/m/wallet#service-balance'" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: #fff; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
          + Fund
        </button>
      </div>

      <!-- Message Search Bar -->
      <div id="messageSearchBar" style="margin:0 16px 8px 16px;">
        <input type="text" id="messageSearchInput" placeholder="Search messages..." 
               oninput="handleMessageSearch(this.value)"
               style="width:100%;padding:10px 14px;background:#1a1a1a;border:1px solid #333;border-radius:10px;color:#fff;font-size:14px;outline:none;">
        <div id="messageSearchResults" style="display:none;max-height:300px;overflow-y:auto;background:#1a1a1a;border:1px solid #333;border-top:none;border-radius:0 0 10px 10px;"></div>
      </div>

      <div class="nav-tabs">
        <div class="nav-tab active" data-tab="conversations" onclick="switchTab('conversations')">
          Chats
        </div>
        <div class="nav-tab" data-tab="groups" onclick="switchTab('groups')">
          Groups
        </div>
        <div class="nav-tab" data-tab="contacts" onclick="switchTab('contacts')">
          Contacts
        </div>
      </div>

      <div id="conversationsTab">
        <div id="conversationList" class="conversation-list">
          <div class="loading-spinner">
            <div class="spinner"></div>
          </div>
        </div>
      </div>

      <div id="groupsTab" style="display: none;">
        <div class="contact-buttons" style="margin-bottom: 1rem;">
          <button class="create-group-btn" onclick="showCreateGroupModal()">
            <span>üë•</span> Create Group
          </button>
        </div>
        <div id="groupsList" class="conversation-list"></div>
      </div>

      <div id="contactsTab" style="display: none;">
        <div class="privacy-toggle-row">
          <div class="privacy-toggle-label">
            <strong>Private Contacts Mode</strong>
            Keep contact list local on this device only
          </div>
          <button id="privateContactsToggle" class="privacy-toggle" onclick="togglePrivateContactsMode()" aria-label="Toggle private contacts mode"></button>
        </div>
        <div class="contact-buttons">
          <button class="share-btn" onclick="showShareModal()">
            <span>üì§</span> Share My Contact
          </button>
          <button class="add-contact-btn" onclick="showAddContactModal()">
            <span>‚ûï</span> Add Contact
          </button>
        </div>
        <div id="contactsList" class="contacts-list"></div>
      </div>

      <div class="encryption-notice" onclick="showEncryptionInfo()">
        <span>üîê</span> Military-grade E2E encryption ‚Ä¢ Messages auto-delete ‚Ä¢ <span style="text-decoration: underline; cursor: pointer;">Learn more</span>
      </div>
    </div>

    <!-- Chat View -->
    <div id="chatView" class="chat-view">
      <div class="chat-header">
        <button class="chat-back-btn" onclick="showInbox()">‚Üê</button>
        <div style="flex:1">
          <div class="chat-participant-name" id="chatParticipantName">Loading...</div>
          <div class="chat-item-context" id="chatItemContext"></div>
        </div>
        <button id="voiceCallBtn" onclick="startVoiceCall()" title="Encrypted voice call" style="background:transparent;border:1px solid #4caf50;color:#4caf50;padding:4px 8px;border-radius:6px;font-size:14px;cursor:pointer;margin-right:4px;">
          üìû
        </button>
        <button id="videoCallBtn" onclick="startVideoCall()" title="Encrypted video call" style="background:transparent;border:1px solid #2196f3;color:#2196f3;padding:4px 8px;border-radius:6px;font-size:14px;cursor:pointer;margin-right:4px;">
          üìπ
        </button>
        <button class="add-contact-chat-btn" id="verifyContactBtn" onclick="showSafetyNumber()" title="Verify contact identity" style="background:transparent;border:1px solid #4caf50;color:#4caf50;padding:4px 8px;border-radius:6px;font-size:11px;cursor:pointer;margin-right:4px;">
          üîç Verify
        </button>
        <button class="add-contact-chat-btn" id="addContactChatBtn" onclick="addCurrentRecipientToContacts()">
          ‚ûï Add
        </button>
      </div>

      <div class="chat-messages" id="chatMessages"></div>

      <div id="typingIndicator" style="display:none;padding:4px 16px;font-size:12px;color:#888;font-style:italic;">typing...</div>

      <div class="encryption-notice" onclick="showEncryptionInfo()">
        <span>üîê</span> AES-256 + Curve25519 encrypted ‚Ä¢ Zero-knowledge architecture
      </div>

      <!-- Media Preview -->
      <div class="media-preview" id="mediaPreview">
        <div class="media-preview-content">
          <div id="mediaPreviewThumb"></div>
          <div class="media-preview-info">
            <div class="media-preview-name" id="mediaPreviewName">Photo</div>
            <div id="mediaPreviewSize">0 KB</div>
          </div>
          <button class="media-preview-remove" onclick="clearMediaPreview()">√ó</button>
        </div>
      </div>

      <!-- Audio Recorder -->
      <div class="audio-recorder" id="audioRecorder">
        <div class="audio-timer" id="audioTimer">0:00</div>
        <div class="audio-waveform">
          <div class="audio-bar" style="animation-delay: 0s"></div>
          <div class="audio-bar" style="animation-delay: 0.1s"></div>
          <div class="audio-bar" style="animation-delay: 0.2s"></div>
          <div class="audio-bar" style="animation-delay: 0.3s"></div>
          <div class="audio-bar" style="animation-delay: 0.4s"></div>
        </div>
        <button class="audio-cancel-btn" onclick="cancelAudioRecording()">Cancel</button>
        <button class="audio-send-btn" onclick="sendAudioRecording()">Send</button>
      </div>

      <!-- Media buttons row (above input) -->
      <div class="media-buttons-row">
        <button class="media-btn" onclick="document.getElementById('photoInput').click()" title="Send photo">üì∑ Photo</button>
        <button class="media-btn" onclick="document.getElementById('videoInput').click()" title="Send video">üé• Video</button>
        <button class="media-btn" onclick="document.getElementById('fileInput').click()" title="Send file">üìé File</button>
        <button class="media-btn" id="audioBtn" onclick="toggleAudioRecording()" title="Record audio">üé§ Audio</button>
      </div>
      
      <!-- Disappearing message timer selector -->
      <div class="timer-selector" id="timerSelector">
        <span class="timer-label">‚è±Ô∏è Auto-delete:</span>
        <select id="disappearTimer" onchange="updateDisappearTimer()">
          <option value="0">Default (by media type)</option>
          <option value="30000">30 seconds</option>
          <option value="300000">5 minutes</option>
          <option value="3600000">1 hour</option>
          <option value="86400000">24 hours</option>
          <option value="259200000">3 days</option>
          <option value="864000000">10 days</option>
        </select>
        <label style="display: flex; align-items: center; gap: 0.25rem; color: #888; font-size: 0.75rem;">
          <input type="checkbox" id="expiresAfterView"> After view
        </label>
      </div>
      
      <!-- Text input row -->
      <div class="chat-input-row">
        <input type="text" class="chat-input" id="messageInput" placeholder="Type a message..." 
               onkeypress="if(event.key==='Enter')sendMessage()">
      </div>
      
      <!-- Action buttons row (below input) -->
      <div class="chat-actions-row">
        <button class="ptt-btn" id="pttBtn" title="Hold to talk">
          <span class="ptt-icon">üéôÔ∏è</span>
          <span class="ptt-text">Hold to Talk</span>
        </button>
        <button class="chat-send-btn" onclick="sendMessage()" id="sendBtn">‚û§ Send</button>
      </div>
      
      <!-- Push-to-Talk Recording Indicator -->
      <div class="ptt-recording" id="pttRecording">
        <div class="ptt-pulse"></div>
        <div class="ptt-status">üéôÔ∏è Recording... Release to send</div>
      </div>

      <!-- Hidden file inputs -->
      <input type="file" id="photoInput" class="hidden-input" accept="image/*" capture="environment" onchange="handlePhotoSelect(event)">
      <input type="file" id="videoInput" class="hidden-input" accept="video/*" capture="environment" onchange="handleVideoSelect(event)">
      <input type="file" id="fileInput" class="hidden-input" onchange="handleFileSelect(event)">
    </div>
  </div>

  <!-- Fullscreen Media Viewer -->
  <div class="media-fullscreen" id="mediaFullscreen" onclick="closeFullscreen()">
    <button class="media-fullscreen-close">√ó</button>
    <div id="fullscreenContent"></div>
  </div>

  <!-- Message Context Menu -->
  <div class="message-context-menu" id="messageContextMenu">
    <div class="reaction-quick-bar" id="reactionQuickBar" style="display:flex;gap:8px;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,0.1);justify-content:center;">
      <span class="reaction-emoji" onclick="reactToMessage('üëç')" style="font-size:22px;cursor:pointer;padding:2px 4px;border-radius:6px;transition:background 0.15s;">üëç</span>
      <span class="reaction-emoji" onclick="reactToMessage('‚ù§Ô∏è')" style="font-size:22px;cursor:pointer;padding:2px 4px;border-radius:6px;transition:background 0.15s;">‚ù§Ô∏è</span>
      <span class="reaction-emoji" onclick="reactToMessage('üòÇ')" style="font-size:22px;cursor:pointer;padding:2px 4px;border-radius:6px;transition:background 0.15s;">üòÇ</span>
      <span class="reaction-emoji" onclick="reactToMessage('üòÆ')" style="font-size:22px;cursor:pointer;padding:2px 4px;border-radius:6px;transition:background 0.15s;">üòÆ</span>
      <span class="reaction-emoji" onclick="reactToMessage('üò¢')" style="font-size:22px;cursor:pointer;padding:2px 4px;border-radius:6px;transition:background 0.15s;">üò¢</span>
      <span class="reaction-emoji" onclick="reactToMessage('üî•')" style="font-size:22px;cursor:pointer;padding:2px 4px;border-radius:6px;transition:background 0.15s;">üî•</span>
    </div>
    <div class="context-menu-item" onclick="copyMessageText()">
      <span>üìã</span> Copy Text
    </div>
    <div class="context-menu-item" onclick="editMessage()">
      <span>‚úèÔ∏è</span> Edit <span class="price-tag">25 sats</span>
    </div>
    <div class="context-menu-item delete" onclick="deleteMessageWithPayment()">
      <span>üóëÔ∏è</span> Delete Now <span class="price-tag">50 sats</span>
    </div>
  </div>

  <!-- Encryption Info Modal -->
  <div class="encryption-modal" id="encryptionModal" onclick="if(event.target===this)closeEncryptionModal()">
    <div class="encryption-modal-content">
      <div class="encryption-modal-header">
        <span>üîê</span> Military-Grade Encryption
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üîí</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">AES-256 Encryption</div>
          <div class="encryption-feature-desc">Same encryption used by governments and banks. Would take billions of years to crack with current technology.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üîë</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Curve25519 Key Exchange</div>
          <div class="encryption-feature-desc">Your private keys never leave your device. Not even we can read your messages.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üö´</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Zero-Knowledge Architecture</div>
          <div class="encryption-feature-desc">We cannot comply with data requests because we literally don't have access to your data.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üåê</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Decentralized Network</div>
          <div class="encryption-feature-desc">No central server to hack or subpoena. Your data is distributed across a global mesh network.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">‚è±Ô∏è</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Auto-Deleting Messages</div>
          <div class="encryption-feature-desc">Messages automatically disappear after the set time. Perfect for sensitive communications.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">‚úÖ</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Open Source & Auditable</div>
          <div class="encryption-feature-desc">Our encryption code is publicly available for security researchers to verify.</div>
        </div>
      </div>
      
      <button class="encryption-close-btn" onclick="closeEncryptionModal()">Got It</button>
    </div>
  </div>

  <!-- Insufficient Balance Modal -->
  <div class="encryption-modal" id="insufficientBalanceModal" onclick="if(event.target===this)closeInsufficientBalanceModal()">
    <div class="encryption-modal-content">
      <div class="encryption-modal-header">
        <span>‚ö°</span> Insufficient Service Balance
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üí∞</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Current Balance: <span id="currentBalanceDisplay">0</span> sats</div>
          <div class="encryption-feature-desc">You need <span id="requiredAmountDisplay">50</span> sats for this action.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üì±</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Fund Your Balance</div>
          <div class="encryption-feature-desc">Go to your wallet to add funds via Bitcoin payment.</div>
        </div>
      </div>
      
      <button class="encryption-close-btn" onclick="window.location.href='/m/wallet'" style="background: linear-gradient(135deg, #d4af37, #b8962e);">
        Go to Wallet
      </button>
      <button class="encryption-close-btn" onclick="closeInsufficientBalanceModal()" style="background: transparent; border: 1px solid #666; margin-top: 0.5rem;">
        Cancel
      </button>
    </div>
  </div>

  <!-- Share Contact Modal -->
  <div id="shareModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeModals()">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">üì§ Share My Contact</div>
        <button class="modal-close" onclick="closeModals()">√ó</button>
      </div>
      <div class="share-instructions">
        Others can scan this QR code or use the link to message you
      </div>
      <div class="qr-container" id="qrContainer"></div>
      <div class="share-link-container">
        <input type="text" class="share-link-input" id="shareLink" readonly>
        <button class="copy-btn" onclick="copyShareLink()">Copy</button>
      </div>
    </div>
  </div>

  <!-- Create Group Modal -->
  <div id="createGroupModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeModals()">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">üë• Create Group</div>
        <button class="modal-close" onclick="closeModals()">√ó</button>
      </div>
      <input type="text" class="modal-input" id="groupNameInput" placeholder="Group name...">
      <div class="share-instructions">Select members from your contacts:</div>
      <div class="member-select-list" id="memberSelectList"></div>
      <button class="modal-btn" onclick="createGroup()">Create Group</button>
    </div>
  </div>

  <!-- Manage Group Modal -->
  <div id="manageGroupModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeModals()">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">‚öôÔ∏è Group Settings</div>
        <button class="modal-close" onclick="closeModals()">√ó</button>
      </div>
      <div id="manageGroupName" style="font-weight: 600; margin-bottom: 1rem; color: #fff;"></div>
      <div class="share-instructions">Current members:</div>
      <div class="member-select-list" id="currentMembersList"></div>
      <div class="section-divider">Add members</div>
      <div class="member-select-list" id="addMembersList"></div>
      <button class="modal-btn" style="background: #ff4444; margin-top: 1rem;" onclick="leaveCurrentGroup()">üö™ Leave Group</button>
    </div>
  </div>

  <!-- Add Contact Modal -->
  <div id="addContactModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeModals()">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">‚ûï Add Contact</div>
        <button class="modal-close" onclick="closeModals()">√ó</button>
      </div>
      <div class="share-instructions">
        Scan a contact QR code or paste their link/ID
      </div>
      <div id="qrScannerContainer" style="display: none; margin-bottom: 15px;">
        <video id="qrScannerVideo" style="width: 100%; max-height: 250px; border-radius: 12px; background: #000;"></video>
        <div id="qrScannerStatus" style="text-align: center; color: #999; font-size: 13px; margin-top: 8px;">Point camera at QR code...</div>
      </div>
      <button class="modal-btn" id="scanQrBtn" onclick="toggleQrScanner()" style="margin-bottom: 15px; background: #333;">
        üì∑ Scan QR Code
      </button>
      <input type="text" class="modal-input" id="addContactInput" placeholder="Or paste link / account ID...">
      <button class="modal-btn" onclick="addContactFromInput()">Add & Start Chat</button>
    </div>
  </div>

  <!-- Safety Numbers Verification Modal -->
  <div id="safetyNumberModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeSafetyNumberModal()">
    <div class="modal-content" style="max-width: 380px;">
      <div class="modal-header">
        <div class="modal-title">üîç Verify Safety Number</div>
        <button class="modal-close" onclick="closeSafetyNumberModal()">√ó</button>
      </div>
      <div style="color: #aaa; font-size: 13px; margin-bottom: 16px; line-height: 1.5;">
        Compare this number with your contact's screen. If they match, your conversation is end-to-end encrypted and not intercepted.
      </div>
      <div id="safetyNumberDisplay" style="font-family: 'Courier New', monospace; font-size: 18px; letter-spacing: 2px; text-align: center; color: #4caf50; background: rgba(76,175,80,0.08); border: 1px solid rgba(76,175,80,0.2); border-radius: 12px; padding: 20px 16px; margin-bottom: 16px; word-break: break-all; line-height: 2;">
        Loading...
      </div>
      <div id="safetyNumberQR" style="display: flex; justify-content: center; margin-bottom: 16px;"></div>
      <div id="safetyQrScannerContainer" style="display:none; margin-bottom: 16px;">
        <video id="safetyQrVideo" style="width:100%; border-radius:10px; background:#000;" playsinline></video>
        <div id="safetyQrScanStatus" style="text-align:center; font-size:12px; color:#888; margin-top:6px;">Point camera at contact's QR code...</div>
      </div>
      <div style="display: flex; gap: 8px; flex-wrap: wrap;">
        <button class="modal-btn" id="scanQrBtn" onclick="toggleSafetyQrScanner()" style="background: #1a73e8; flex: 1; min-width: 120px;">üì∑ Scan QR</button>
        <button class="modal-btn" onclick="markContactVerified()" style="background: #4caf50; flex: 1; min-width: 120px;">‚úÖ Mark Verified</button>
        <button class="modal-btn" onclick="closeSafetyNumberModal()" style="background: #333; flex: 1; min-width: 120px;">Close</button>
      </div>
      <div id="verifiedStatus" style="text-align: center; margin-top: 12px; font-size: 12px; color: #888;"></div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Encrypted Call Overlay ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div id="callOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:#0a0a0a;z-index:10000;flex-direction:column;align-items:center;justify-content:center;font-family:Inter,'Segoe UI',sans-serif;">
    <!-- Remote video (fills background) -->
    <video id="remoteVideo" autoplay playsinline style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;"></video>
    <!-- Remote audio (for voice calls) -->
    <audio id="remoteAudio" autoplay playsinline style="display:none;"></audio>
    <!-- Self-view (picture-in-picture) -->
    <video id="localVideo" autoplay playsinline muted style="position:absolute;top:16px;right:16px;width:120px;height:160px;object-fit:cover;border-radius:12px;border:2px solid rgba(255,255,255,0.3);z-index:10001;display:none;"></video>

    <!-- Call info (centered, shown over video or solid bg) -->
    <div id="callInfo" style="position:relative;z-index:10001;text-align:center;padding:40px 20px;">
      <div id="callPeerName" style="font-size:28px;font-weight:600;color:#fff;margin-bottom:8px;">Unknown</div>
      <div id="callStatusText" style="font-size:16px;color:rgba(255,255,255,0.6);margin-bottom:4px;">Calling...</div>
      <div id="callDuration" style="font-size:14px;color:rgba(255,255,255,0.4);"></div>
      <div id="callEncryption" style="font-size:12px;color:#4caf50;margin-top:12px;">üîê End-to-end encrypted</div>
    </div>

    <!-- Incoming call buttons -->
    <div id="incomingCallBtns" style="display:none;position:absolute;bottom:80px;left:0;right:0;z-index:10001;display:none;justify-content:center;gap:40px;">
      <button onclick="rejectIncomingCall()" style="width:64px;height:64px;border-radius:50%;border:none;background:#f44336;color:#fff;font-size:24px;cursor:pointer;box-shadow:0 4px 16px rgba(244,67,54,0.4);">‚úï</button>
      <button onclick="acceptIncomingCall()" style="width:64px;height:64px;border-radius:50%;border:none;background:#4caf50;color:#fff;font-size:24px;cursor:pointer;box-shadow:0 4px 16px rgba(76,175,80,0.4);">üìû</button>
    </div>

    <!-- Active call controls -->
    <div id="activeCallBtns" style="display:none;position:absolute;bottom:80px;left:0;right:0;z-index:10001;justify-content:center;gap:24px;">
      <button id="muteBtn" onclick="toggleCallMute()" style="width:56px;height:56px;border-radius:50%;border:none;background:rgba(255,255,255,0.15);color:#fff;font-size:20px;cursor:pointer;backdrop-filter:blur(10px);">üé§</button>
      <button id="camToggleBtn" onclick="toggleCallCamera()" style="width:56px;height:56px;border-radius:50%;border:none;background:rgba(255,255,255,0.15);color:#fff;font-size:20px;cursor:pointer;backdrop-filter:blur(10px);display:none;">üì∑</button>
      <button onclick="endCurrentCall()" style="width:64px;height:64px;border-radius:50%;border:none;background:#f44336;color:#fff;font-size:22px;cursor:pointer;box-shadow:0 4px 16px rgba(244,67,54,0.4);">‚úï</button>
    </div>
  </div>

  <script src="/js/qrcode.min.js" integrity="sha384-3zSEDfvllQohrq0PHL1fOXJuC/jSOO34H46t6UQfobFOmxE5BpjjaIJY5F2/bMnU" crossorigin="anonymous"></script>
  <script src="/js/jsQR.js" integrity="sha384-b5Ya4Bq3qCyz39m2ISh+4DxjAIljdeFwK/BsXLuj9gugaNwAcj/ia15fxNZL9Nlx" crossorigin="anonymous"></script>
  <script src="/js/mlkem.bundle.js" integrity="sha384-5MFLjnWWzPLJ8xZQMzwzz8M0mx0mqoMzwG43tueyZi0no25PcQw2AMg6k/JUQFN1" crossorigin="anonymous"></script>
  <script src="/js/nacl-fast.min.js" integrity="sha384-05+sicyRJQ56XpL4U9HJ8YbtSzFDvAg7apPKOGV6A0JsAJKFM68jp5oLnUjG5mEp" crossorigin="anonymous"></script>
  <script src="/js/nacl-util.min.js" integrity="sha384-qpU3wxGxaAPcz02pOLeZTv5B0rNzsh3CETsUqdHxRBP70bO0kHoBopr+f9AcGj04" crossorigin="anonymous"></script>
  <script src="/js/double-ratchet.js" integrity="sha384-AgMXGk5+mUUw2YWWcFLVRj7sJM3eMskKVbdDgWwxBPCA/wk0FElqi4YtGso5LFfO" crossorigin="anonymous"></script>
  <script src="/js/mls-group.js" integrity="sha384-ikW8LAAJS8aZFWIq2eICz7MSnfHOUVLXBZrCc0oTBJs/x+DiRfsLsabPQqiunmOy" crossorigin="anonymous"></script>
  <script src="/js/autho-wire.js" integrity="sha384-EwvW0hNJ1vdF1w9ZOAvuPCsWm1l16rxI20yZYvOx8cldFX0AyxIGJh1lJbgJf1h8" crossorigin="anonymous"></script>
  <script src="/js/autho-call.js"></script>
  <script src="/js/btc.bundle.js"></script>
  <script src="/wallet-auth.js"></script>
  <script>
    let currentConversationId = null;
    let currentRecipientId = null;
    let currentRecipientPublicKey = null;
    let currentItemId = null;
    let myMessagingPrivateKey = null; // Messaging private key (NOT BTC spending key)
    let myMessagingPublicKey = null;  // Messaging public key for key exchange
    let myEncryptionKeyPair = null;   // Derived X25519 keypair for E2E encryption
    let myKyberKeyPair = null;         // ML-KEM-768 keypair for post-quantum hybrid
    const recipientEncryptionKeyCache = new Map();
    const recipientKyberKeyCache = new Map();
    let conversations = [];
    let messagePollingInterval = null;
    let inboxPollingInterval = null;
    let lastIncomingCallerId = null;
    let lastIncomingCallerName = null;
    const POLL_INTERVAL_MS = 5000; // Check for new messages every 5 seconds

    // ============================================================
    // WEBSOCKET REAL-TIME MESSAGING (replaces polling when connected)
    // ============================================================
    let messagingWs = null;
    let messagingWsReconnectTimer = null;
    let messagingWsConnected = false;

    // Optional self-hosted TURN config (no external dependency)
    async function initAutoTurnConfig() {
      try {
        if (window.AUTHO_CALL_TURN) return;

        const turnUrl = localStorage.getItem('autho_turn_url');
        const turnUser = localStorage.getItem('autho_turn_user');
        const turnCred = localStorage.getItem('autho_turn_cred');
        if (turnUrl) {
          window.AUTHO_CALL_TURN = {
            urls: turnUrl.split(',').map(s => s.trim()).filter(Boolean),
            username: turnUser || undefined,
            credential: turnCred || undefined,
          };
          return;
        }

        // Try local operator first
        const localRes = await fetch('/api/network/turn').catch(() => null);
        if (localRes && localRes.ok) {
          const localData = await localRes.json().catch(() => null);
          if (localData && localData.turn) {
            window.AUTHO_CALL_TURN = localData.turn;
            return;
          }
        }

        // Fallback: ask other operators for TURN info
        const opsRes = await fetch('/api/network/operators').catch(() => null);
        const opsData = opsRes && opsRes.ok ? await opsRes.json().catch(() => null) : null;
        const operators = Array.isArray(opsData?.operators) ? opsData.operators : [];

        for (const op of operators) {
          const operatorUrl = String(op?.operatorUrl || '').trim();
          if (!operatorUrl) continue;
          const base = operatorUrl.replace(/\/$/, '');
          try {
            const res = await fetch(base + '/api/network/turn', { mode: 'cors' }).catch(() => null);
            if (res && res.ok) {
              const data = await res.json().catch(() => null);
              if (data && data.turn) {
                window.AUTHO_CALL_TURN = data.turn;
                return;
              }
            }
          } catch {}
        }
      } catch {}
    }

    initAutoTurnConfig();

    function connectMessagingWebSocket() {
      if (messagingWs && messagingWs.readyState <= 1) return; // already open/connecting
      try {
        const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = proto + '//' + location.host + '/ws/messaging';
        messagingWs = new WebSocket(wsUrl);

        messagingWs.onopen = function() {
          messagingWsConnected = true;
          console.log('[WS] Messaging WebSocket connected');
          // Authenticate
          const wallet = WalletAuth.getWallet();
          if (wallet) {
            messagingWs.send(JSON.stringify({
              type: 'auth',
              publicKey: wallet.publicKey,
              ...WalletAuth.getAuthHeaders()
            }));
          }
          // Subscribe to current conversation
          if (currentConversationId) {
            messagingWs.send(JSON.stringify({
              type: 'subscribe',
              conversationId: currentConversationId
            }));
          }
          if (currentGroupId) {
            messagingWs.send(JSON.stringify({
              type: 'subscribe_group',
              groupId: currentGroupId
            }));
          }
        };

        messagingWs.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            if (data.type === 'new_message' && data.conversationId === currentConversationId) {
              // Real-time message received ‚Äî reload messages
              if (currentConversationId) loadMessages(currentConversationId);
            }
            if (data.type === 'new_group_message' && data.groupId === currentGroupId) {
              if (currentGroupId) loadGroupMessages(currentGroupId);
            }
            if (data.type === 'message_sent') {
              // Server confirmed our optimistic message
              updateOptimisticMessage(data.tempId, 'sent');
            }
            // ‚îÄ‚îÄ Reactions ‚îÄ‚îÄ
            if (data.type === 'reaction' && data.conversationId === currentConversationId && data.messageId && data.emoji) {
              applyReaction(data.messageId, data.emoji, data.fromId || 'remote', data.action || 'add');
            }
            // ‚îÄ‚îÄ Typing indicators ‚îÄ‚îÄ
            if (data.type === 'typing' && data.conversationId === currentConversationId) {
              const ti = document.getElementById('typingIndicator');
              if (ti) {
                ti.style.display = data.isTyping ? 'block' : 'none';
              }
            }
            // ‚îÄ‚îÄ Read receipts ‚îÄ‚îÄ
            if (data.type === 'read_receipt' && data.conversationId === currentConversationId) {
              // Update sent message status indicators to "read"
              document.querySelectorAll('.message-status.sent, .message-status.delivered').forEach(function(el) {
                el.textContent = '‚úì‚úì';
                el.classList.add('read');
                el.style.color = '#4caf50';
              });
            }
            // ‚îÄ‚îÄ Call signaling ‚îÄ‚îÄ
            if (data.type === 'call_signal' && data.signal && typeof AutohoCall !== 'undefined') {
              const fromId = data.fromId || data.signal.from;
              if (fromId) {
                data.signal.from = fromId;
                lastIncomingCallerId = fromId;
                lastIncomingCallerName = resolveCallerName(fromId);
                setCallPeerName(lastIncomingCallerName || fromId);
              } else {
                console.warn('[Call] Incoming call signal missing fromId');
              }
              AutohoCall.handleSignal(data.signal, sendCallSignal);
            }
          } catch {}
        };

        messagingWs.onclose = function() {
          messagingWsConnected = false;
          console.log('[WS] Messaging WebSocket closed, reconnecting in 3s...');
          clearTimeout(messagingWsReconnectTimer);
          messagingWsReconnectTimer = setTimeout(connectMessagingWebSocket, 3000);
        };

        messagingWs.onerror = function() {
          messagingWsConnected = false;
        };
      } catch (e) {
        console.warn('[WS] WebSocket connect failed:', e.message);
      }
    }

    async function sha256Utf8(text) {
      const bytes = new TextEncoder().encode(String(text || ''));
      const hash = await crypto.subtle.digest('SHA-256', bytes);
      return new Uint8Array(hash);
    }

    function bytesToBase64(bytes) {
      let binary = '';
      for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }

    function base64ToBytes(b64) {
      const binary = atob(String(b64 || ''));
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
    }

    async function getPrivateContactsAesKey() {
      const secret = String(myMessagingPrivateKey || sessionStorage.getItem('autho_messaging_privateKey') || '').trim();
      if (!secret) throw new Error('Messaging key unavailable');
      const keyMaterial = await sha256Utf8('contacts-v1:' + secret);
      return crypto.subtle.importKey('raw', keyMaterial, 'AES-GCM', false, ['encrypt', 'decrypt']);
    }

    async function encryptPrivateContactsPayload(contacts) {
      const aesKey = await getPrivateContactsAesKey();
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const plaintext = new TextEncoder().encode(JSON.stringify({ contacts, updatedAt: Date.now() }));
      const ciphertext = new Uint8Array(await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, plaintext));
      return {
        alg: 'A256GCM',
        ivB64: bytesToBase64(iv),
        ciphertextB64: bytesToBase64(ciphertext),
      };
    }

    async function decryptPrivateContactsPayload(enc) {
      const aesKey = await getPrivateContactsAesKey();
      const iv = base64ToBytes(enc?.ivB64 || '');
      const ciphertext = base64ToBytes(enc?.ciphertextB64 || '');
      const plaintext = new Uint8Array(await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ciphertext));
      const parsed = JSON.parse(new TextDecoder().decode(plaintext));
      return Array.isArray(parsed?.contacts) ? parsed.contacts : [];
    }

    async function savePrivateContactsVault(contacts) {
      const enc = await encryptPrivateContactsPayload(contacts);
      const response = await fetch('/api/messages/vault', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...WalletAuth.getAuthHeaders()
        },
        body: JSON.stringify({
          vaultEpoch: 'contacts_private_v1',
          vaultVersion: Date.now(),
          kdf: { type: 'sha256_messaging_key_v1' },
          enc,
        })
      });
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to save encrypted contacts');
      }
      return true;
    }

    async function loadPrivateContactsVault() {
      const response = await fetch('/api/messages/vault?vaultEpoch=contacts_private_v1', {
        headers: WalletAuth.getAuthHeaders()
      });
      if (response.status === 404) return null;
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to load encrypted contacts');
      }
      const data = await response.json();
      if (!data?.success || !data?.vault) return null;
      const vault = data.vault;
      if (String(vault.vaultEpoch || '').trim() !== 'contacts_private_v1') return null;
      if (!vault.enc) return [];
      return await decryptPrivateContactsPayload(vault.enc);
    }

    async function syncPrivateContactsFromLocal() {
      const contacts = getLocalContacts();
      await savePrivateContactsVault(contacts);
    }

    async function purgePublicContactsFromServer(contacts) {
      if (!Array.isArray(contacts) || contacts.length === 0) return;
      const headers = WalletAuth.getAuthHeaders();
      await Promise.all(contacts.map((c) => {
        const id = String(c?.accountId || '').trim();
        if (!id) return Promise.resolve();
        return fetch(`/api/messages/contacts/${encodeURIComponent(id)}`, {
          method: 'DELETE',
          headers,
        }).catch(() => {});
      }));
    }

    function sendViaWebSocket(payload) {
      if (messagingWs && messagingWs.readyState === 1) {
        messagingWs.send(JSON.stringify(payload));
        return true;
      }
      return false;
    }

    // ============================================================
    // OPTIMISTIC UI ‚Äî show message instantly before server confirms
    // ============================================================
    let optimisticMsgCounter = 0;

    function renderOptimisticMessage(text) {
      const container = document.getElementById('chatMessages');
      if (!container) return null;
      const tempId = 'opt_' + (++optimisticMsgCounter) + '_' + Date.now();
      const timeStr = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble sent';
      bubble.id = tempId;
      bubble.innerHTML = '<div class="message-text">' + escapeHtml(text) + '</div>' +
        '<div class="message-meta">' + timeStr + ' <span class="msg-status" style="opacity:0.5;">sending...</span></div>';
      container.appendChild(bubble);
      container.scrollTop = container.scrollHeight;
      return tempId;
    }

    function updateOptimisticMessage(tempId, status) {
      const el = document.getElementById(tempId);
      if (!el) return;
      const statusEl = el.querySelector('.msg-status');
      if (statusEl) {
        if (status === 'sent') {
          statusEl.textContent = '‚úì';
          statusEl.style.opacity = '1';
          statusEl.style.color = '#4caf50';
        } else if (status === 'failed') {
          statusEl.textContent = '‚úó failed';
          statusEl.style.opacity = '1';
          statusEl.style.color = '#ff4444';
        }
      }
    }

    // Helper: Check response for auth errors and redirect to login
    function checkAuthAndRedirect(response) {
      if (response.status === 401 || response.status === 403) {
        WalletAuth.lock();
        alert('Session expired. Please log in again.');
        WalletAuth.requireAuth();
        return true;
      }
      return false;
    }

    // ============================================================
    // E2E ENCRYPTION (Signal-grade: Curve25519 + XSalsa20-Poly1305)
    // ============================================================

    // Convert hex string to Uint8Array
    function hexToBytes(hex) {
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
      }
      return bytes;
    }

    // Convert Uint8Array to hex string
    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function sha256Sync(bytes) {
      const K = [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
      ];
      const rotr = (x, n) => (x >>> n) | (x << (32 - n));

      const bitLen = bytes.length * 8;
      const withOne = bytes.length + 1;
      const padLen = (withOne % 64 <= 56) ? (56 - (withOne % 64)) : (56 + (64 - (withOne % 64)));
      const totalLen = withOne + padLen + 8;
      const msg = new Uint8Array(totalLen);
      msg.set(bytes, 0);
      msg[bytes.length] = 0x80;
      const view = new DataView(msg.buffer);
      view.setUint32(totalLen - 8, Math.floor(bitLen / 2 ** 32), false);
      view.setUint32(totalLen - 4, bitLen >>> 0, false);

      let h0 = 0x6a09e667;
      let h1 = 0xbb67ae85;
      let h2 = 0x3c6ef372;
      let h3 = 0xa54ff53a;
      let h4 = 0x510e527f;
      let h5 = 0x9b05688c;
      let h6 = 0x1f83d9ab;
      let h7 = 0x5be0cd19;

      const w = new Uint32Array(64);
      for (let i = 0; i < msg.length; i += 64) {
        for (let t = 0; t < 16; t++) {
          w[t] = view.getUint32(i + t * 4, false);
        }
        for (let t = 16; t < 64; t++) {
          const s0 = (rotr(w[t - 15], 7) ^ rotr(w[t - 15], 18) ^ (w[t - 15] >>> 3)) >>> 0;
          const s1 = (rotr(w[t - 2], 17) ^ rotr(w[t - 2], 19) ^ (w[t - 2] >>> 10)) >>> 0;
          w[t] = (w[t - 16] + s0 + w[t - 7] + s1) >>> 0;
        }

        let a = h0;
        let b = h1;
        let c = h2;
        let d = h3;
        let e = h4;
        let f = h5;
        let g = h6;
        let h = h7;

        for (let t = 0; t < 64; t++) {
          const S1 = (rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)) >>> 0;
          const ch = ((e & f) ^ (~e & g)) >>> 0;
          const temp1 = (h + S1 + ch + K[t] + w[t]) >>> 0;
          const S0 = (rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)) >>> 0;
          const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0;
          const temp2 = (S0 + maj) >>> 0;

          h = g;
          g = f;
          f = e;
          e = (d + temp1) >>> 0;
          d = c;
          c = b;
          b = a;
          a = (temp1 + temp2) >>> 0;
        }

        h0 = (h0 + a) >>> 0;
        h1 = (h1 + b) >>> 0;
        h2 = (h2 + c) >>> 0;
        h3 = (h3 + d) >>> 0;
        h4 = (h4 + e) >>> 0;
        h5 = (h5 + f) >>> 0;
        h6 = (h6 + g) >>> 0;
        h7 = (h7 + h) >>> 0;
      }

      const out = new Uint8Array(32);
      const outView = new DataView(out.buffer);
      outView.setUint32(0, h0, false);
      outView.setUint32(4, h1, false);
      outView.setUint32(8, h2, false);
      outView.setUint32(12, h3, false);
      outView.setUint32(16, h4, false);
      outView.setUint32(20, h5, false);
      outView.setUint32(24, h6, false);
      outView.setUint32(28, h7, false);
      return out;
    }

    async function sha256Bytes(bytes) {
      try {
        if (window.crypto && window.crypto.subtle && window.crypto.subtle.digest) {
          const hashBuffer = await window.crypto.subtle.digest('SHA-256', bytes);
          return new Uint8Array(hashBuffer);
        }
      } catch (e) {
      }
      return sha256Sync(bytes);
    }

    // Derive X25519 keypair from wallet private key using SHA-256
    async function deriveEncryptionKeyPair(privateKeyHex) {
      // Hash the private key to get 32 bytes for X25519 seed
      const privateKeyBytes = hexToBytes(privateKeyHex);
      const seed = await sha256Bytes(privateKeyBytes);
      
      // Generate X25519 keypair from seed
      const keyPair = nacl.box.keyPair.fromSecretKey(seed);
      return keyPair;
    }

    async function publishMyEncryptionPublicKey() {
      if (!myEncryptionKeyPair) return;
      const keyHex = bytesToHex(myEncryptionKeyPair.publicKey);
      // Include Kyber public key if available
      const payload = { encryptionPublicKeyHex: keyHex };
      if (myKyberKeyPair && myKyberKeyPair.publicKey) {
        payload.kyberPublicKeyB64 = nacl.util.encodeBase64(myKyberKeyPair.publicKey);
      }
      const maxRetries = 3;
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const r = await fetch('/api/messages/keys', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              ...WalletAuth.getAuthHeaders(),
            },
            body: JSON.stringify(payload),
          });
          if (r.ok) {
            console.log('[Messaging] Encryption key published successfully' + (payload.kyberPublicKeyB64 ? ' (with PQ Kyber)' : ''));
            return;
          }
          const errData = await r.json().catch(() => ({}));
          console.warn(`[Messaging] Key publish attempt ${attempt + 1} failed (${r.status}):`, errData?.error || r.statusText);
          if (r.status === 401) {
            console.warn('[Messaging] Session may be expired for key publish');
          }
        } catch (e) {
          console.warn(`[Messaging] Key publish attempt ${attempt + 1} network error:`, e?.message || e);
        }
        if (attempt < maxRetries - 1) {
          await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
        }
      }
      console.error('[Messaging] Failed to publish encryption key after all retries');
    }

    async function getRecipientEncryptionPublicKeyBytes(recipientId) {
      const id = String(recipientId || '').trim();
      if (!id) throw new Error('Missing recipient id');

      const cached = recipientEncryptionKeyCache.get(id);
      if (cached && cached.bytes && cached.bytes.length === 32) return cached.bytes;

      const r = await fetch(`/api/messages/keys/${encodeURIComponent(id)}`, {
        headers: {
          ...WalletAuth.getAuthHeaders(),
        },
      });

      if (!r.ok) {
        throw new Error('Recipient messaging key not found');
      }

      const data = await r.json();
      const keyHex = String(data?.encryptionPublicKeyHex || '').trim().toLowerCase();
      if (!/^[0-9a-f]{64}$/.test(keyHex)) {
        throw new Error('Invalid recipient messaging key');
      }

      const bytes = hexToBytes(keyHex);
      if (!bytes || bytes.length !== 32) {
        throw new Error('Invalid recipient messaging key');
      }

      recipientEncryptionKeyCache.set(id, { bytes, updatedAt: Number(data?.updatedAt || Date.now()) });

      // Cache Kyber public key if available (for PQ hybrid)
      if (data?.kyberPublicKeyB64) {
        try {
          const kyberBytes = nacl.util.decodeBase64(data.kyberPublicKeyB64);
          if (kyberBytes && kyberBytes.length > 0) {
            recipientKyberKeyCache.set(id, kyberBytes);
          }
        } catch {}
      }

      return bytes;
    }

    // Encrypt message for recipient (and self)
    async function encryptForRecipient(plaintext, recipientPublicKeyHex) {
      if (!myEncryptionKeyPair) {
        throw new Error('Encryption keys not initialized');
      }
      
      const recipientEncPubKeyBytes = await getRecipientEncryptionPublicKeyBytes(recipientPublicKeyHex);
      // Check for recipient's Kyber key for PQ hybrid
      const recipientKyberPubKey = recipientKyberKeyCache.get(String(recipientPublicKeyHex).trim());
      return encryptForEncryptionPublicKey(plaintext, recipientEncPubKeyBytes, recipientKyberPubKey);
    }

    // Pad plaintext to nearest 256-byte boundary to prevent length-based analysis
    function padMessage(messageBytes) {
      const PAD_BLOCK = 256;
      // Prepend 4-byte big-endian length header
      const len = messageBytes.length;
      const paddedLen = Math.ceil((len + 4) / PAD_BLOCK) * PAD_BLOCK;
      const padded = new Uint8Array(paddedLen);
      // Write length as 4 bytes big-endian
      padded[0] = (len >>> 24) & 0xff;
      padded[1] = (len >>> 16) & 0xff;
      padded[2] = (len >>> 8) & 0xff;
      padded[3] = len & 0xff;
      padded.set(messageBytes, 4);
      // Fill remaining bytes with random padding
      const randomPad = nacl.randomBytes(paddedLen - 4 - len);
      padded.set(randomPad, 4 + len);
      return padded;
    }

    // Remove padding and extract original message
    function unpadMessage(paddedBytes) {
      if (paddedBytes.length < 4) return paddedBytes;
      const len = (paddedBytes[0] << 24) | (paddedBytes[1] << 16) | (paddedBytes[2] << 8) | paddedBytes[3];
      if (len <= 0 || len > paddedBytes.length - 4) return paddedBytes;
      return paddedBytes.slice(4, 4 + len);
    }

    // ============================================================
    // REPLAY PROTECTION: In-memory nonce tracking
    // ============================================================
    const _seenNonces = new Set();
    const _MAX_NONCE_CACHE = 10000;
    function checkAndStoreNonce(nonceB64) {
      if (_seenNonces.has(nonceB64)) return false;
      _seenNonces.add(nonceB64);
      if (_seenNonces.size > _MAX_NONCE_CACHE) {
        const oldest = _seenNonces.values().next().value;
        _seenNonces.delete(oldest);
      }
      return true;
    }

    // ============================================================
    // TIER 4: SIGNED PRE-KEYS WITH ROTATION (X3DH pre-key bundle)
    // ============================================================
    let mySignedPreKeyPair = null;
    let myOneTimePreKeys = [];
    const SIGNED_PREKEY_ROTATION_MS = 7 * 24 * 60 * 60 * 1000; // 7 days

    async function generateSignedPreKey() {
      const preKeyPair = nacl.box.keyPair();
      // Sign the pre-key with our identity key for authentication
      const preKeyPubB64 = nacl.util.encodeBase64(preKeyPair.publicKey);
      const sigPayload = nacl.util.decodeUTF8('AuthoSignedPreKey:' + preKeyPubB64);
      // Use HMAC-SHA256 as signature (identity secret key as HMAC key)
      const hmacKey = await crypto.subtle.importKey('raw', myEncryptionKeyPair.secretKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
      const sig = new Uint8Array(await crypto.subtle.sign('HMAC', hmacKey, sigPayload));
      return {
        keyPair: preKeyPair,
        publicKeyB64: preKeyPubB64,
        signatureB64: nacl.util.encodeBase64(sig),
        createdAt: Date.now()
      };
    }

    async function generateOneTimePreKeys(count) {
      const keys = [];
      for (let i = 0; i < count; i++) {
        const kp = nacl.box.keyPair();
        keys.push({
          keyPair: kp,
          publicKeyB64: nacl.util.encodeBase64(kp.publicKey),
          id: crypto.getRandomValues(new Uint8Array(8)).reduce((s, b) => s + b.toString(16).padStart(2, '0'), '')
        });
      }
      return keys;
    }

    async function publishPreKeyBundle() {
      if (!myEncryptionKeyPair) return;
      try {
        const signedPreKey = await generateSignedPreKey();
        mySignedPreKeyPair = signedPreKey;
        const oneTimeKeys = await generateOneTimePreKeys(10);
        myOneTimePreKeys = oneTimeKeys;

        const bundle = {
          identityKeyB64: nacl.util.encodeBase64(myEncryptionKeyPair.publicKey),
          signedPreKeyB64: signedPreKey.publicKeyB64,
          signedPreKeySigB64: signedPreKey.signatureB64,
          oneTimePreKeys: oneTimeKeys.map(k => ({ id: k.id, keyB64: k.publicKeyB64 })),
          timestamp: Date.now()
        };

        await fetch('/api/messages/prekey-bundle', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...WalletAuth.getAuthHeaders() },
          body: JSON.stringify(bundle)
        });
        console.log('[X3DH] Pre-key bundle published (' + oneTimeKeys.length + ' one-time keys)');

        // Store rotation timestamp
        localStorage.setItem('autho_prekey_published_at', String(Date.now()));
      } catch (e) {
        console.warn('[X3DH] Pre-key bundle publish failed:', e.message);
      }
    }

    async function maybeRotatePreKeys() {
      const lastPublished = parseInt(localStorage.getItem('autho_prekey_published_at') || '0');
      if (Date.now() - lastPublished > SIGNED_PREKEY_ROTATION_MS) {
        await publishPreKeyBundle();
      }
    }

    async function fetchPreKeyBundle(recipientId) {
      try {
        const r = await fetch(`/api/messages/prekey-bundle/${encodeURIComponent(recipientId)}`, {
          headers: WalletAuth.getAuthHeaders()
        });
        if (!r.ok) return null;
        return await r.json();
      } catch {
        return null;
      }
    }

    // ============================================================
    // TIER 4: ENCRYPTED ATTACHMENTS (client-side encrypt before upload)
    // ============================================================

    async function encryptAttachment(fileArrayBuffer) {
      // Generate random file key
      const fileKey = crypto.getRandomValues(new Uint8Array(32));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const aesKey = await crypto.subtle.importKey('raw', fileKey, 'AES-GCM', false, ['encrypt']);
      const encrypted = new Uint8Array(await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, fileArrayBuffer));

      // Compute SHA-256 digest of plaintext for integrity verification
      const digest = new Uint8Array(await crypto.subtle.digest('SHA-256', fileArrayBuffer));

      return {
        encryptedData: encrypted,
        fileKeyB64: nacl.util.encodeBase64(fileKey),
        ivB64: nacl.util.encodeBase64(iv),
        digestB64: nacl.util.encodeBase64(digest),
        size: fileArrayBuffer.byteLength
      };
    }

    async function decryptAttachment(encryptedData, fileKeyB64, ivB64, expectedDigestB64) {
      const fileKey = nacl.util.decodeBase64(fileKeyB64);
      const iv = nacl.util.decodeBase64(ivB64);
      const aesKey = await crypto.subtle.importKey('raw', fileKey, 'AES-GCM', false, ['decrypt']);
      const decrypted = new Uint8Array(await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, encryptedData));

      // Verify integrity
      if (expectedDigestB64) {
        const digest = new Uint8Array(await crypto.subtle.digest('SHA-256', decrypted));
        const digestB64 = nacl.util.encodeBase64(digest);
        if (digestB64 !== expectedDigestB64) {
          throw new Error('SECURITY: Attachment integrity check failed ‚Äî file may have been tampered with');
        }
      }

      return decrypted;
    }

    function stripImageMetadata(arrayBuffer) {
      // Strip EXIF/GPS metadata from JPEG files for privacy
      const view = new DataView(arrayBuffer);
      if (view.byteLength < 4) return arrayBuffer;
      // Check JPEG magic bytes
      if (view.getUint8(0) !== 0xFF || view.getUint8(1) !== 0xD8) return arrayBuffer;

      // Find and remove APP1 (EXIF) segments
      const cleaned = [];
      let i = 0;
      cleaned.push(0xFF, 0xD8); // SOI
      i = 2;
      while (i < view.byteLength - 1) {
        const marker = view.getUint8(i);
        if (marker !== 0xFF) { i++; continue; }
        const type = view.getUint8(i + 1);
        if (type === 0xD9) { // EOI
          cleaned.push(0xFF, 0xD9);
          break;
        }
        if (type === 0xDA) { // SOS ‚Äî rest is image data, copy all
          for (let j = i; j < view.byteLength; j++) {
            cleaned.push(view.getUint8(j));
          }
          break;
        }
        if (i + 3 >= view.byteLength) break;
        const segLen = view.getUint16(i + 2);
        if (type === 0xE1) {
          // APP1 (EXIF/GPS) ‚Äî skip entirely
          i += 2 + segLen;
          continue;
        }
        // Keep other segments
        for (let j = 0; j < segLen + 2; j++) {
          if (i + j < view.byteLength) cleaned.push(view.getUint8(i + j));
        }
        i += 2 + segLen;
      }
      return new Uint8Array(cleaned).buffer;
    }

    // ============================================================
    // TIER 4: SESSION / DEVICE BINDING
    // ============================================================

    function getDeviceFingerprint() {
      let fp = sessionStorage.getItem('autho_device_fingerprint');
      if (fp) return fp;
      // Generate a stable-ish fingerprint from browser properties
      const components = [
        navigator.userAgent || '',
        navigator.language || '',
        screen.width + 'x' + screen.height,
        new Date().getTimezoneOffset().toString(),
        navigator.hardwareConcurrency || '0'
      ];
      fp = components.join('|');
      // Hash it
      let hash = 0;
      for (let i = 0; i < fp.length; i++) {
        hash = ((hash << 5) - hash + fp.charCodeAt(i)) | 0;
      }
      fp = 'dev_' + Math.abs(hash).toString(36);
      sessionStorage.setItem('autho_device_fingerprint', fp);
      return fp;
    }

    function bindSessionToDevice(sessionObj) {
      if (!sessionObj) return sessionObj;
      sessionObj._deviceFingerprint = getDeviceFingerprint();
      sessionObj._boundAt = Date.now();
      return sessionObj;
    }

    function verifySessionDevice(sessionObj) {
      if (!sessionObj || !sessionObj._deviceFingerprint) return true; // no binding = ok
      if (sessionObj._deviceFingerprint !== getDeviceFingerprint()) {
        console.warn('SECURITY: Ratchet session was created on a different device ‚Äî re-initializing');
        return false;
      }
      return true;
    }

    // ============================================================
    // TIER 4: METADATA PROTECTION
    // ============================================================

    // Randomize polling interval to prevent timing analysis
    function getRandomizedPollInterval() {
      // Base 5s ¬± 2s random jitter
      return 3000 + Math.floor(Math.random() * 4000);
    }

    // Uniform message size padding (already have padMessage, this adds extra)
    function padToUniformSize(messageBytes, targetSize) {
      if (!targetSize) targetSize = 1024; // 1KB minimum
      const minSize = Math.max(targetSize, messageBytes.length);
      const paddedSize = Math.ceil(minSize / 1024) * 1024; // Round up to nearest KB
      if (paddedSize <= messageBytes.length) return messageBytes;
      const padded = new Uint8Array(paddedSize);
      padded.set(messageBytes, 0);
      // Fill rest with random bytes
      const randomPad = crypto.getRandomValues(new Uint8Array(paddedSize - messageBytes.length));
      padded.set(randomPad, messageBytes.length);
      return padded;
    }

    // ============================================================
    // DOUBLE RATCHET: Session management + v5 envelope
    // ============================================================

    // Derive a stable encryption key for ratchet state storage from identity key
    function getRatchetStorageKey() {
      if (!myEncryptionKeyPair) return null;
      // Use first 32 bytes of SHA-256(secretKey) as AES key for state encryption
      return myEncryptionKeyPair.secretKey;
    }

    async function getOrCreateRatchetSession(conversationId, recipientEncPubKeyBytes) {
      if (!window.DoubleRatchet) return null;
      const DR = window.DoubleRatchet;

      // Check in-memory cache first
      let session = DR.getSession(conversationId);
      if (session && session.initialized) return session;

      // Try loading from server
      const storageKey = getRatchetStorageKey();
      if (storageKey) {
        session = await DR.loadSessionFromServer(conversationId, storageKey, WalletAuth.getAuthHeaders());
        if (session && session.initialized) {
          DR.setSession(conversationId, session);
          return session;
        }
      }

      // Initialize new session as sender
      try {
        session = await DR.initSender(myEncryptionKeyPair, recipientEncPubKeyBytes, recipientEncPubKeyBytes);
        DR.setSession(conversationId, session);
        // Save to server (non-blocking)
        if (storageKey) {
          DR.saveSessionToServer(conversationId, session, storageKey, WalletAuth.getAuthHeaders()).catch(() => {});
        }
        return session;
      } catch (e) {
        console.warn('[DoubleRatchet] Session init failed:', e.message);
        return null;
      }
    }

    async function encryptWithRatchet(plaintext, conversationId, recipientEncPubKeyBytes) {
      if (!window.DoubleRatchet || !conversationId) return null;

      try {
        const session = await getOrCreateRatchetSession(conversationId, recipientEncPubKeyBytes);
        if (!session) return null;

        // Sealed sender: embed sender identity inside payload
        const wallet = WalletAuth.getWallet();
        const innerPayload = JSON.stringify({
          s: wallet ? wallet.publicKey : '',
          t: Date.now(),
          body: plaintext
        });

        const ratchetMsg = await window.DoubleRatchet.ratchetEncrypt(session, innerPayload);

        // Save updated session state
        const storageKey = getRatchetStorageKey();
        if (storageKey) {
          window.DoubleRatchet.saveSessionToServer(conversationId, session, storageKey, WalletAuth.getAuthHeaders()).catch(() => {});
        }

        return JSON.stringify({
          v: 5,
          h: ratchetMsg.header,
          iv: ratchetMsg.iv,
          c: ratchetMsg.ciphertext
        });
      } catch (e) {
        console.warn('[DoubleRatchet] Encrypt failed, falling back to v3/v4:', e.message);
        return null;
      }
    }

    async function decryptWithRatchet(envelope, conversationId, senderPublicKeyHex) {
      if (!window.DoubleRatchet || !conversationId) return null;
      const DR = window.DoubleRatchet;

      try {
        let session = DR.getSession(conversationId);

        // Try loading from server if not in memory
        if (!session) {
          const storageKey = getRatchetStorageKey();
          if (storageKey) {
            session = await DR.loadSessionFromServer(conversationId, storageKey, WalletAuth.getAuthHeaders());
          }
        }

        // If no session exists, init as receiver
        if (!session) {
          const senderPubKeyBytes = await getRecipientEncryptionPublicKeyBytes(senderPublicKeyHex);
          session = await DR.initReceiver(myEncryptionKeyPair, myEncryptionKeyPair, senderPubKeyBytes, nacl.util.decodeBase64(envelope.h.dh));
        }

        DR.setSession(conversationId, session);

        const decrypted = await DR.ratchetDecrypt(session, {
          header: envelope.h,
          iv: envelope.iv,
          ciphertext: envelope.c
        });

        // Save updated session state
        const storageKey = getRatchetStorageKey();
        if (storageKey) {
          DR.saveSessionToServer(conversationId, session, storageKey, WalletAuth.getAuthHeaders()).catch(() => {});
        }

        // Parse inner payload (sealed sender)
        try {
          const inner = JSON.parse(decrypted);
          if (inner.t && (Date.now() - inner.t) > 86400000) {
            console.warn('SECURITY: v5 ratchet message timestamp >24h old');
          }
          return inner.body || decrypted;
        } catch {
          return decrypted;
        }
      } catch (e) {
        console.warn('[DoubleRatchet] Decrypt failed:', e.message);
        return null;
      }
    }

    // ============================================================
    // v3/v4/v5 ENCRYPTION: Ephemeral keys + Sealed sender + Replay protection
    // v4 adds post-quantum hybrid (ML-KEM-768 + Curve25519)
    // v5 adds Double Ratchet (per-message key rotation)
    // ============================================================
    async function encryptForEncryptionPublicKey(plaintext, recipientEncPubKeyBytes, recipientKyberPubKey) {
      if (!myEncryptionKeyPair) {
        throw new Error('Encryption keys not initialized');
      }

      // ‚îÄ‚îÄ v5: Double Ratchet DISABLED ‚Äî stateless v3/v4 is more reliable ‚îÄ‚îÄ
      // Ratchet state sync issues cause permanent message loss; v3/v4 always work.
      // if (currentConversationId && window.DoubleRatchet) {
      //   const ratchetResult = await encryptWithRatchet(plaintext, currentConversationId, recipientEncPubKeyBytes);
      //   if (ratchetResult) return ratchetResult;
      // }

      // Generate ephemeral keypair ‚Äî destroyed after this call (forward secrecy)
      const ephemeralKeyPair = nacl.box.keyPair();
      const nonce = nacl.randomBytes(24);

      // Sealed sender: embed sender identity inside encrypted payload
      const wallet = WalletAuth.getWallet();
      const innerPayload = JSON.stringify({
        s: wallet ? wallet.publicKey : '',  // sender identity (hidden from server)
        t: Date.now(),                       // timestamp for replay protection
        body: plaintext                      // original message content
      });

      // ‚îÄ‚îÄ Wire protocol: compress before encrypt for smaller payloads ‚îÄ‚îÄ
      let messageBytes;
      if (window.AutohoWire && innerPayload.length > 64) {
        try {
          messageBytes = await window.AutohoWire.compressText(innerPayload);
        } catch { messageBytes = nacl.util.decodeUTF8(innerPayload); }
      } else {
        messageBytes = nacl.util.decodeUTF8(innerPayload);
      }
      const paddedBytes = padMessage(messageBytes);

      // ‚îÄ‚îÄ v4: Post-quantum hybrid DISABLED ‚îÄ‚îÄ
      // Kyber keys are random per session (not deterministic from wallet seed),
      // so they get out of sync across nodes/logins causing decrypt failures.
      // v3 (Curve25519 only) uses deterministic keys and always works.
      // if (recipientKyberPubKey && window.MlKemModule && window.MlKemModule.MlKem768) { ... }

      // ‚îÄ‚îÄ v3 fallback: Curve25519 only (no PQ) ‚îÄ‚îÄ
      const encrypted = nacl.box(paddedBytes, nonce, recipientEncPubKeyBytes, ephemeralKeyPair.secretKey);

      return JSON.stringify({
        v: 3,
        e: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),
        n: nacl.util.encodeBase64(nonce),
        c: nacl.util.encodeBase64(encrypted),
      });
    }

    // Decrypt message from sender (supports v1, v2, v3, and v4 envelopes)
    async function decryptFromSender(encryptedJson, senderPublicKeyHex) {
      try {
        if (!myEncryptionKeyPair) {
          const ok = await ensureEncryptionInitialized();
          if (!ok || !myEncryptionKeyPair) {
            throw new Error('Encryption keys not initialized');
          }
        }

        const envelope = JSON.parse(encryptedJson);

        // ‚îÄ‚îÄ v5: Double Ratchet (per-message key rotation) ‚îÄ‚îÄ
        if (envelope.v === 5 && envelope.h && envelope.iv && envelope.c) {
          // First attempt
          let result = await decryptWithRatchet(envelope, currentConversationId, senderPublicKeyHex);
          if (result) return result;
          // Session might be stale ‚Äî reset and retry as fresh receiver
          if (window.DoubleRatchet) {
            try {
              window.DoubleRatchet.clearSession(currentConversationId);
              result = await decryptWithRatchet(envelope, currentConversationId, senderPublicKeyHex);
              if (result) return result;
            } catch (retryErr) {
              console.warn('[DoubleRatchet] Retry after reset also failed:', retryErr.message);
            }
          }
          console.warn('SECURITY: v5 ratchet decrypt failed ‚Äî session state out of sync');
          return '[Encrypted with outdated session key]';
        }

        // ‚îÄ‚îÄ v4: Post-quantum hybrid (ML-KEM-768 + Curve25519 + AES-GCM) ‚îÄ‚îÄ
        if (envelope.v === 4 && envelope.e && envelope.k && envelope.iv && envelope.c) {
          if (!myKyberKeyPair || !myKyberKeyPair.secretKey) {
            console.warn('SECURITY: v4 message received but no Kyber secret key');
            return null;
          }
          try {
            const kyber = new window.MlKemModule.MlKem768();
            const ephemeralPubKey = nacl.util.decodeBase64(envelope.e);
            const kyberCt = nacl.util.decodeBase64(envelope.k);
            const iv = nacl.util.decodeBase64(envelope.iv);
            const aesCt = nacl.util.decodeBase64(envelope.c);

            // Decapsulate Kyber to get shared secret
            const kyberSs = await kyber.decap(kyberCt, myKyberKeyPair.secretKey);

            // Derive hybrid key: SHA-256(nacl_shared || kyber_shared)
            const naclShared = nacl.box.before(ephemeralPubKey, myEncryptionKeyPair.secretKey);
            const combined = new Uint8Array(naclShared.length + kyberSs.length);
            combined.set(naclShared, 0);
            combined.set(kyberSs, naclShared.length);
            const hybridKey = new Uint8Array(await crypto.subtle.digest('SHA-256', combined));

            // AES-256-GCM decrypt
            const aesKey = await crypto.subtle.importKey('raw', hybridKey, 'AES-GCM', false, ['decrypt']);
            const decryptedBuf = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, aesCt);
            const decrypted = new Uint8Array(decryptedBuf);

            const unpadded = unpadMessage(decrypted);
            // Wire protocol: try decompress, fall back to raw UTF8
            let innerStr;
            if (window.AutohoWire && unpadded.length > 1 && (unpadded[0] === 0x00 || unpadded[0] === 0x01)) {
              try { innerStr = await window.AutohoWire.decompressText(unpadded); } catch { innerStr = nacl.util.encodeUTF8(unpadded); }
            } else {
              innerStr = nacl.util.encodeUTF8(unpadded);
            }

            try {
              const inner = JSON.parse(innerStr);
              if (inner.t && (Date.now() - inner.t) > 86400000) {
                console.warn('SECURITY: v4 message timestamp >24h old');
              }
              return inner.body || innerStr;
            } catch {
              return innerStr;
            }
          } catch (e) {
            console.error('v4 PQ hybrid decrypt failed:', e);
            return null;
          }
        }

        // ‚îÄ‚îÄ v3: Ephemeral-key encryption (forward secrecy + sealed sender) ‚îÄ‚îÄ
        if (envelope.v === 3 && envelope.e && envelope.n && envelope.c) {
          const ephemeralPubKey = nacl.util.decodeBase64(envelope.e);
          const nonce = nacl.util.decodeBase64(envelope.n);
          const ciphertext = nacl.util.decodeBase64(envelope.c);

          const decrypted = nacl.box.open(ciphertext, nonce, ephemeralPubKey, myEncryptionKeyPair.secretKey);
          if (!decrypted) return null;

          const unpadded = unpadMessage(decrypted);
          // Wire protocol: try decompress, fall back to raw UTF8
          let innerStr;
          if (window.AutohoWire && unpadded.length > 1 && (unpadded[0] === 0x00 || unpadded[0] === 0x01)) {
            try { innerStr = await window.AutohoWire.decompressText(unpadded); } catch { innerStr = nacl.util.encodeUTF8(unpadded); }
          } else {
            innerStr = nacl.util.encodeUTF8(unpadded);
          }

          try {
            const inner = JSON.parse(innerStr);
            // Replay protection: warn on old timestamps
            if (inner.t && (Date.now() - inner.t) > 86400000) {
              console.warn('SECURITY: Message timestamp >24h old, possible replay');
            }
            checkAndStoreNonce(envelope.n);
            return inner.body || innerStr;
          } catch {
            return innerStr;
          }
        }

        // ‚îÄ‚îÄ v1/v2 backward compatibility ‚îÄ‚îÄ
        if ((envelope.v === 1 || envelope.v === 2) && envelope.n && envelope.c) {
          const nonce = nacl.util.decodeBase64(envelope.n);
          const ciphertext = nacl.util.decodeBase64(envelope.c);
          const isV2 = envelope.v === 2;

          const candidateSenderKeys = [];

          // v1: sender key embedded in envelope
          const sHex = String(envelope.s || '').trim().toLowerCase();
          if (/^[0-9a-f]{64}$/.test(sHex)) {
            try {
              const k = hexToBytes(sHex);
              if (k && k.length === 32) candidateSenderKeys.push(k);
            } catch {}
          }

          // v2 and fallback: look up sender's encryption key from server
          const sid = String(senderPublicKeyHex || '').trim();
          if (sid) {
            try {
              const k = await getRecipientEncryptionPublicKeyBytes(sid);
              if (k && k.length === 32) candidateSenderKeys.push(k);
            } catch {}
          }

          // Also try own key (for messages encrypted for self)
          if (myEncryptionKeyPair.publicKey) {
            candidateSenderKeys.push(myEncryptionKeyPair.publicKey);
          }

          for (const senderEncPubKey of candidateSenderKeys) {
            const decrypted = nacl.box.open(ciphertext, nonce, senderEncPubKey, myEncryptionKeyPair.secretKey);
            if (decrypted) {
              if (isV2) {
                const unpadded = unpadMessage(decrypted);
                return nacl.util.encodeUTF8(unpadded);
              }
              return nacl.util.encodeUTF8(decrypted);
            }
          }
        }

        return null;
      } catch (e) {
        console.error('Decryption error:', e);
        return null;
      }
    }

    // Wait for nacl library to be available
    async function waitForNacl(maxWaitMs = 5000) {
      const start = Date.now();
      while (!window.nacl || !window.nacl.box) {
        if (Date.now() - start > maxWaitMs) {
          throw new Error('NaCl library failed to load');
        }
        await new Promise(r => setTimeout(r, 100));
      }
      return true;
    }

    // Initialize encryption with retry
    async function initializeEncryption(privateKey, retries = 3) {
      for (let i = 0; i < retries; i++) {
        try {
          await waitForNacl();
          const keyPair = await deriveEncryptionKeyPair(privateKey);
          if (keyPair && keyPair.secretKey && keyPair.publicKey) {
            return keyPair;
          }
        } catch (e) {
          console.warn(`Encryption init attempt ${i + 1} failed:`, e.message);
          if (i < retries - 1) {
            await new Promise(r => setTimeout(r, 500));
          }
        }
      }
      return null;
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      const wallet = WalletAuth.getWallet();
      if (!wallet) {
        WalletAuth.requireAuth();
        return;
      }
      
      // Get messaging keys from sessionStorage (derived from mnemonic, NOT BTC spending key)
      myMessagingPrivateKey = sessionStorage.getItem('autho_messaging_privateKey');
      myMessagingPublicKey = sessionStorage.getItem('autho_messaging_publicKey');

      if (!myMessagingPrivateKey && typeof WalletAuth.ensureMessagingKeys === 'function') {
        try {
          await WalletAuth.ensureMessagingKeys();
        } catch {}
        myMessagingPrivateKey = sessionStorage.getItem('autho_messaging_privateKey');
        myMessagingPublicKey = sessionStorage.getItem('autho_messaging_publicKey');
      }

      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) sendBtn.disabled = true;

      if (!await ensureEncryptionInitialized()) {
        WalletAuth.lock();
        alert('Messaging encryption key missing. Please log in again.');
        WalletAuth.requireAuth();
        return;
      }

      if (sendBtn) sendBtn.disabled = false;
      refreshPrivateContactsToggle();
      
      await loadConversations();
      await loadContacts();
      
      // Start inbox polling for new conversations
      startInboxPolling();

      // Check for URL parameters
      const params = new URLSearchParams(window.location.search);
      const itemId = params.get('itemId');
      const recipientId = params.get('to');
      const contactId = params.get('contact');
      
      if (contactId) {
        // Coming from a shared contact link - add and start chat
        await addContactAndStartChat(contactId);
      } else if (itemId && recipientId) {
        openConversationWithItem(recipientId, itemId);
      }
    });

    function switchTab(tab) {
      document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
      
      document.getElementById('conversationsTab').style.display = tab === 'conversations' ? 'block' : 'none';
      document.getElementById('groupsTab').style.display = tab === 'groups' ? 'block' : 'none';
      document.getElementById('contactsTab').style.display = tab === 'contacts' ? 'block' : 'none';
      
      if (tab === 'groups') {
        loadGroups();
      }
    }

    async function loadConversations() {
      try {
        const response = await fetch('/api/messages/conversations', {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (checkAuthAndRedirect(response)) return;
        
        if (!response.ok) {
          throw new Error('Failed to load conversations');
        }
        
        const data = await response.json();

        if (data.success) {
          conversations = data.conversations;
          renderConversations();
          const contactsTab = document.getElementById('contactsTab');
          if (contactsTab && contactsTab.style.display !== 'none') {
            const localContacts = getLocalContacts();
            renderContacts(localContacts);
            updateAddContactButton(contactExistsInList(localContacts, currentRecipientId));
          }
          document.getElementById('inboxStats').textContent = 
            `${conversations.length} conversation${conversations.length !== 1 ? 's' : ''}`;
        } else if (data.error && data.error.includes('auth')) {
          WalletAuth.lock();
          WalletAuth.requireAuth();
        }
      } catch (error) {
        console.error('Failed to load conversations:', error);
        document.getElementById('conversationList').innerHTML = 
          '<div class="empty-inbox"><div class="empty-inbox-title">Failed to load</div></div>';
      }
    }

    function renderConversations() {
      const container = document.getElementById('conversationList');
      
      if (conversations.length === 0) {
        container.innerHTML = `
          <div class="empty-inbox">
            <div class="empty-inbox-icon">üí¨</div>
            <div class="empty-inbox-title">No messages yet</div>
            <div>Find an item and message its owner to start a conversation</div>
          </div>
        `;
        return;
      }

      const wallet = WalletAuth.getWallet();
      container.innerHTML = conversations.map(conv => {
        const otherParticipant = conv.participantInfo.find(p => p.accountId !== wallet.publicKey);
        const lastMsg = conv.lastMessage;
        const timeAgo = lastMsg ? formatTimeAgo(lastMsg.timestamp) : '';
        
        return `
          <div class="conversation-card ${conv.unreadCount > 0 ? 'unread' : ''}" 
               onclick="openConversation('${conv.conversationId}', '${otherParticipant?.accountId}')">
            <div class="conversation-header">
              <div class="conversation-participant">${escapeHtml(otherParticipant?.displayName || 'Unknown')}</div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                ${conv.unreadCount > 0 ? `<span class="unread-badge">${conv.unreadCount}</span>` : ''}
                <div class="conversation-time">${timeAgo}</div>
              </div>
            </div>
            <div class="conversation-preview">[Encrypted message]</div>
            ${lastMsg?.payload?.itemId ? `<div class="conversation-item-badge">About an item</div>` : ''}
          </div>
        `;
      }).join('');
    }

    // localStorage helpers for contact backup
    function getLocalContacts() {
      try {
        const wallet = WalletAuth.getWallet();
        if (!wallet) return [];
        const key = `contacts_${wallet.publicKey.substring(0, 16)}`;
        return JSON.parse(localStorage.getItem(key) || '[]');
      } catch (e) { return []; }
    }
    
    function saveLocalContacts(contacts) {
      try {
        const wallet = WalletAuth.getWallet();
        if (!wallet) return;
        const key = `contacts_${wallet.publicKey.substring(0, 16)}`;
        localStorage.setItem(key, JSON.stringify(contacts));
      } catch (e) { console.error('Failed to save local contacts:', e); }
    }

    function getPrivateContactsMode() {
      try {
        const wallet = WalletAuth.getWallet();
        if (!wallet) return false;
        const key = `private_contacts_mode_${wallet.publicKey.substring(0, 16)}`;
        return localStorage.getItem(key) === '1';
      } catch (e) {
        return false;
      }
    }

    function setPrivateContactsMode(enabled) {
      try {
        const wallet = WalletAuth.getWallet();
        if (!wallet) return;
        const key = `private_contacts_mode_${wallet.publicKey.substring(0, 16)}`;
        localStorage.setItem(key, enabled ? '1' : '0');
      } catch (e) {
        console.error('Failed to save private contacts mode:', e);
      }
    }

    function refreshPrivateContactsToggle() {
      const toggle = document.getElementById('privateContactsToggle');
      if (!toggle) return;
      const enabled = getPrivateContactsMode();
      toggle.classList.toggle('active', enabled);
      toggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
      toggle.title = enabled ? 'Private contacts mode: ON' : 'Private contacts mode: OFF';
    }

    async function togglePrivateContactsMode() {
      const next = !getPrivateContactsMode();
      setPrivateContactsMode(next);
      refreshPrivateContactsToggle();
      if (next) {
        try {
          const existing = getLocalContacts();
          await savePrivateContactsVault(existing);
          await purgePublicContactsFromServer(existing);
        } catch (e) {
          console.error('Enable private contacts mode failed:', e);
          alert('Failed to sync encrypted contacts: ' + (e?.message || 'Unknown error'));
        }
      }
      await loadContacts();
      if (next) {
        alert('Private contacts mode enabled. Contacts are now encrypted before sync and only readable by your account.');
      }
    }
    
    function addLocalContact(contactId, displayName) {
      const contacts = getLocalContacts();
      if (!contacts.find(c => c.accountId === contactId)) {
        contacts.push({ accountId: contactId, displayName: displayName || contactId.substring(0, 12) + '...' });
        saveLocalContacts(contacts);
      }
    }

    function removeLocalContact(contactId) {
      const contacts = getLocalContacts();
      const next = contacts.filter(c => String(c.accountId || '').trim() !== String(contactId || '').trim());
      saveLocalContacts(next);
    }

    function contactExistsInList(contacts, contactId) {
      const target = String(contactId || '').trim();
      if (!target || !Array.isArray(contacts)) return false;
      return contacts.some(c => String(c?.accountId || c?.contactId || '').trim() === target);
    }

    function getConversationDisplayName(accountId) {
      const target = String(accountId || '').trim();
      if (!target) return '';
      for (const conv of conversations || []) {
        const participant = (conv?.participantInfo || []).find(p => String(p?.accountId || '').trim() === target);
        const name = String(participant?.displayName || '').trim();
        if (name) return name;
      }
      return '';
    }

    function getAccountDisplayName(accountId) {
      const target = String(accountId || '').trim();
      if (!target) return '';

      const conversationName = getConversationDisplayName(target);
      if (conversationName) return conversationName;

      const contacts = getLocalContacts();
      for (const c of contacts) {
        const contactId = String(c?.accountId || c?.contactId || '').trim();
        if (contactId !== target) continue;
        const name = String(c?.displayName || c?.nickname || '').trim();
        if (name) return name;
      }

      return target.substring(0, 8) + '...';
    }

    function normalizeContactShape(contact) {
      const accountId = String(contact?.accountId || contact?.contactId || '').trim();
      if (!accountId) return null;
      const fallbackName = accountId.substring(0, 12) + '...';
      const conversationName = getConversationDisplayName(accountId);
      const displayName = conversationName || String(contact?.displayName || contact?.nickname || '').trim() || fallbackName;
      return {
        ...contact,
        accountId,
        contactId: accountId,
        displayName,
      };
    }

    function isCurrentRecipientInContacts() {
      if (!currentRecipientId || currentGroupId) return false;
      return contactExistsInList(getLocalContacts(), currentRecipientId);
    }

    async function loadContacts() {
      if (getPrivateContactsMode()) {
        let contacts = getLocalContacts();
        try {
          const vaultContacts = await loadPrivateContactsVault();
          if (Array.isArray(vaultContacts)) {
            const merged = new Map();
            for (const c of contacts) {
              const key = String(c?.accountId || c?.contactId || '').trim();
              if (!key) continue;
              merged.set(key, c);
            }
            for (const c of vaultContacts) {
              const key = String(c?.accountId || c?.contactId || '').trim();
              if (!key) continue;
              if (merged.has(key)) {
                const existing = merged.get(key) || {};
                merged.set(key, {
                  ...c,
                  displayName: String(existing?.displayName || c?.displayName || '').trim() || undefined,
                });
              } else {
                merged.set(key, c);
              }
            }
            contacts = Array.from(merged.values());
            saveLocalContacts(contacts);

            const vaultHasAllMerged = contacts.every(c => contactExistsInList(vaultContacts, c?.accountId || c?.contactId));
            if (!vaultHasAllMerged || contacts.length !== vaultContacts.length) {
              await savePrivateContactsVault(contacts);
            }
          } else if (contacts.length > 0) {
            await savePrivateContactsVault(contacts);
          }
        } catch (error) {
          console.error('Encrypted contacts load failed:', error);
        }
        renderContacts(contacts);
        updateAddContactButton(contactExistsInList(contacts, currentRecipientId));
        return;
      }

      try {
        const response = await fetch('/api/messages/contacts', {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (checkAuthAndRedirect(response)) return;
        
        const data = await response.json();

        if (data.success) {
          // Merge server contacts with local backup
          const serverContacts = Array.isArray(data.contacts)
            ? data.contacts.map(normalizeContactShape).filter(Boolean)
            : [];
          const localContacts = getLocalContacts();
          
          // Build merged list (server takes priority for display names)
          const merged = new Map();
          for (const c of localContacts) {
            const normalized = normalizeContactShape(c);
            if (!normalized) continue;
            merged.set(normalized.accountId, normalized);
          }
          for (const c of serverContacts) {
            merged.set(c.accountId, c);
          }
          
          const allContacts = Array.from(merged.values());
          
          // Save merged list back to localStorage
          saveLocalContacts(allContacts);
          
          // Re-add any local-only contacts to server
          for (const local of localContacts) {
            const normalizedLocal = normalizeContactShape(local);
            if (!normalizedLocal) continue;
            if (!serverContacts.find(s => s.accountId === normalizedLocal.accountId)) {
              // Silently re-add to server
              fetch('/api/messages/contacts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', ...WalletAuth.getAuthHeaders() },
                body: JSON.stringify({ contactId: normalizedLocal.accountId, displayName: normalizedLocal.displayName })
              }).catch(() => {});
            }
          }
          
          renderContacts(allContacts);
          updateAddContactButton(contactExistsInList(allContacts, currentRecipientId));
        }
      } catch (error) {
        console.error('Failed to load contacts:', error);
        // Fall back to local contacts
        const localContacts = getLocalContacts();
        if (localContacts.length > 0) {
          renderContacts(localContacts);
        }
        updateAddContactButton(contactExistsInList(localContacts, currentRecipientId));
      }
    }

    function renderContacts(contacts) {
      const container = document.getElementById('contactsList');
      
      if (contacts.length === 0) {
        container.innerHTML = `
          <div class="empty-inbox">
            <div class="empty-inbox-title">No contacts yet</div>
            <div>Message someone to add them to your contacts</div>
          </div>
        `;
        return;
      }

      container.innerHTML = contacts.map(rawContact => {
        const contact = normalizeContactShape(rawContact);
        if (!contact) return '';
        return `
        <div class="contact-card">
          <div class="contact-info">
            <div class="contact-avatar">${contact.displayName[0].toUpperCase()}</div>
            <div>
              <div class="contact-name">${escapeHtml(contact.displayName)}</div>
              <div class="contact-role">
                ${contact.isManufacturer ? 'Manufacturer' : contact.isAuthenticator ? 'Authenticator' : 'User'}
              </div>
            </div>
          </div>
          <div class="contact-actions">
            <button onclick="startConversation('${contact.accountId}')">Message</button>
            <button onclick="removeContact('${contact.accountId}')">Remove</button>
          </div>
        </div>
      `;
      }).join('');
    }

    async function removeContact(contactId) {
      if (!contactId) return;
      if (!confirm('Remove this contact?')) return;

      removeLocalContact(contactId);

      if (getPrivateContactsMode()) {
        try {
          await syncPrivateContactsFromLocal();
        } catch (error) {
          console.error('Encrypted contacts save failed:', error);
        }
        await loadContacts();
        return;
      }

      try {
        const response = await fetch(`/api/messages/contacts/${encodeURIComponent(contactId)}`, {
          method: 'DELETE',
          headers: WalletAuth.getAuthHeaders()
        });

        const data = await response.json().catch(() => ({}));
        if (!response.ok || !data.success) {
          alert(data.error || 'Failed to remove contact');
          return;
        }

        await loadContacts();
      } catch (error) {
        console.error('Remove contact error:', error);
        alert('Contact removed locally. Server sync will retry when available.');
      }
    }

    // ============================================================
    // GROUP CHAT FUNCTIONS
    // ============================================================
    
    let groups = [];
    let currentGroupId = null;
    let currentGroupMembers = [];
    let selectedGroupMembers = new Set();

    async function loadGroups() {
      try {
        const response = await fetch('/api/messages/groups', {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (checkAuthAndRedirect(response)) return;
        
        if (!response.ok) throw new Error('Failed to load groups');
        
        const data = await response.json();
        if (data.success) {
          groups = data.groups;
          renderGroups();
        }
      } catch (error) {
        console.error('Failed to load groups:', error);
        document.getElementById('groupsList').innerHTML = 
          '<div class="empty-inbox"><div class="empty-inbox-title">Failed to load groups</div></div>';
      }
    }

    function renderGroups() {
      const container = document.getElementById('groupsList');
      
      if (groups.length === 0) {
        container.innerHTML = `
          <div class="empty-inbox">
            <div class="empty-inbox-icon">üë•</div>
            <div class="empty-inbox-title">No groups yet</div>
            <div>Create a group to chat with multiple contacts</div>
          </div>
        `;
        return;
      }

      container.innerHTML = groups.map(group => {
        const timeAgo = formatTimeAgo(group.lastMessageAt);
        return `
          <div class="group-card" onclick="openGroupChat('${group.groupId}')">
            <div class="conversation-header">
              <div style="display: flex; align-items: center;">
                <div class="group-icon">üë•</div>
                <div>
                  <div class="group-name">${escapeHtml(group.name)}</div>
                  <div class="group-members-count">${group.members.length} members</div>
                </div>
              </div>
              <div class="conversation-time">${timeAgo}</div>
            </div>
            <div class="conversation-preview">${group.messageCount} messages</div>
          </div>
        `;
      }).join('');
    }

    function showCreateGroupModal() {
      selectedGroupMembers.clear();
      document.getElementById('groupNameInput').value = '';
      
      // Get contacts for member selection
      const localContacts = getLocalContacts();
      const container = document.getElementById('memberSelectList');
      
      if (localContacts.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; padding: 1rem;">Add contacts first to create a group</div>';
      } else {
        container.innerHTML = localContacts.map(contact => `
          <div class="member-select-item" onclick="toggleMemberSelection('${contact.accountId}', this)">
            <input type="checkbox" class="member-checkbox" id="member_${contact.accountId}">
            <div class="contact-avatar" style="width: 32px; height: 32px; font-size: 0.9rem;">${contact.displayName[0].toUpperCase()}</div>
            <span>${escapeHtml(contact.displayName)}</span>
          </div>
        `).join('');
      }
      
      document.getElementById('createGroupModal').style.display = 'flex';
    }

    function toggleMemberSelection(memberId, element) {
      const checkbox = element.querySelector('.member-checkbox');
      
      if (selectedGroupMembers.has(memberId)) {
        selectedGroupMembers.delete(memberId);
        checkbox.checked = false;
        element.classList.remove('selected');
      } else {
        selectedGroupMembers.add(memberId);
        checkbox.checked = true;
        element.classList.add('selected');
      }
    }

    async function createGroup() {
      const name = document.getElementById('groupNameInput').value.trim();
      
      if (!name) {
        alert('Please enter a group name');
        return;
      }
      
      if (selectedGroupMembers.size === 0) {
        alert('Please select at least one member');
        return;
      }

      try {
        const response = await fetch('/api/messages/groups', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({
            name,
            memberIds: Array.from(selectedGroupMembers)
          })
        });

        if (checkAuthAndRedirect(response)) return;

        const data = await response.json();
        if (data.success) {
          closeModals();
          await loadGroups();
          switchTab('groups');
          alert('Group created successfully!');
        } else {
          alert('Failed to create group: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Create group error:', error);
        alert('Failed to create group');
      }
    }

    async function openGroupChat(groupId) {
      currentGroupId = groupId;
      currentConversationId = null;
      currentRecipientId = null;
      
      // Get group info
      const group = groups.find(g => g.groupId === groupId);
      if (!group) {
        alert('Group not found');
        return;
      }
      
      currentGroupMembers = group.members;
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      document.getElementById('chatParticipantName').textContent = 'üë• ' + group.name;
      document.getElementById('chatItemContext').textContent = group.members.length + ' members';
      
      // Update the Add button to show Settings for groups
      const addBtn = document.getElementById('addContactChatBtn');
      addBtn.textContent = '‚öôÔ∏è Settings';
      addBtn.classList.remove('added');
      addBtn.onclick = showManageGroupModal;
      
      await loadGroupMessages(groupId);
      
      stopInboxPolling();
      startGroupMessagePolling();
    }

    async function loadGroupMessages(groupId) {
      try {
        const response = await fetch(`/api/messages/groups/${groupId}/messages`, {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (checkAuthAndRedirect(response)) return;
        
        const data = await response.json();
        if (data.success) {
          renderGroupMessages(data.messages);
        }
      } catch (error) {
        console.error('Failed to load group messages:', error);
      }
    }

    async function renderGroupMessages(messages) {
      const container = document.getElementById('chatMessages');
      const wallet = WalletAuth.getWallet();
      
      if (messages.length === 0) {
        container.innerHTML = '<div class="empty-inbox"><div class="empty-inbox-title">No messages yet</div><div>Start the conversation!</div></div>';
        return;
      }

      const rendered = [];
      for (const msg of messages) {
        const isSent = msg.senderId === wallet.publicKey;
        let content = '[Encrypted]';
        let mlsDecrypted = false;
        
        // Try MLS decryption first (shared group key)
        if (msg.mlsEncryptedContent && window.MLSGroup && currentGroupId && myEncryptionKeyPair) {
          try {
            const envelope = JSON.parse(msg.mlsEncryptedContent);
            if (envelope.v === 'mls1') {
              const groupState = await getOrCreateMLSGroupState(currentGroupId, currentGroupMembers || []);
              if (groupState) {
                content = await window.MLSGroup.decryptGroupMessage(groupState, envelope);
                mlsDecrypted = true;
                // Parse inner content if it's a message envelope
                try {
                  const parsed = JSON.parse(content);
                  content = parsed.content || content;
                } catch {}
              }
            }
          } catch (e) {
            console.warn('[MLS] Group decrypt failed:', e.message);
            content = '[Encrypted]';
          }
        }

        // Fallback: per-member encrypted content (required after relogin if MLS state is missing/stale)
        if (!mlsDecrypted && msg.encryptedContent && myEncryptionKeyPair) {
          try {
            const result = decryptMessage(msg.encryptedContent, msg.senderId);
            if (result && typeof result === 'object' && result.encrypted) {
              content = await decryptMessageAsync(result.data, result.senderId);
            } else {
              content = result;
            }
            if (typeof content === 'string' && content.startsWith('{')) {
              try {
                const parsed = JSON.parse(content);
                if (parsed && typeof parsed === 'object' && typeof parsed.content === 'string') {
                  content = parsed.content;
                }
              } catch {}
            }
          } catch (e) {
            content = '[Unable to decrypt]';
          }
        }
        
        const senderName = isSent ? 'You' : getAccountDisplayName(msg.senderId);
        
        rendered.push(`
          <div class="message-bubble ${isSent ? 'sent' : 'received'}">
            ${!isSent ? `<div class="group-message-sender">${senderName}</div>` : ''}
            <div class="message-text">${escapeHtml(content)}</div>
            <div class="message-meta">${formatTime(msg.timestamp)}</div>
          </div>
        `);
      }

      container.innerHTML = rendered.join('');
      container.scrollTop = container.scrollHeight;
    }

    // ‚îÄ‚îÄ MLS Group State Helpers ‚îÄ‚îÄ
    async function getOrCreateMLSGroupState(groupId, memberPubKeys) {
      if (!window.MLSGroup || !myEncryptionKeyPair) return null;
      const MLS = window.MLSGroup;

      // Check in-memory cache
      let state = MLS.getGroupState(groupId);
      if (state) return state;

      // Try loading from server
      const storageKey = getRatchetStorageKey();
      if (storageKey) {
        state = await MLS.loadGroupStateFromServer(groupId, storageKey, WalletAuth.getAuthHeaders());
        if (state) {
          MLS.setGroupState(groupId, state);
          return state;
        }
      }

      // Create new group state
      try {
        const memberKeys = [];
        for (const pk of memberPubKeys) {
          try {
            const bytes = await getRecipientEncryptionPublicKeyBytes(pk);
            memberKeys.push(bytes);
          } catch {
            memberKeys.push(myEncryptionKeyPair.publicKey); // fallback
          }
        }
        state = await MLS.createGroup(groupId, myEncryptionKeyPair, memberKeys);
        MLS.setGroupState(groupId, state);
        if (storageKey) {
          MLS.saveGroupStateToServer(groupId, state, storageKey, WalletAuth.getAuthHeaders()).catch(() => {});
        }
        return state;
      } catch (e) {
        console.warn('[MLS] Group state creation failed:', e.message);
        return null;
      }
    }

    async function sendGroupMessage() {
      if (!currentGroupId) {
        console.error('No group selected');
        return;
      }
      
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      if (!text) return;

      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) sendBtn.disabled = true;

      try {
        // Create message envelope
        const messageEnvelope = JSON.stringify({
          type: 'text',
          content: text,
          timestamp: Date.now()
        });

        if (!await ensureEncryptionInitialized()) {
          WalletAuth.lock();
          alert('Encryption not initialized. Please log in again.');
          WalletAuth.requireAuth();
          console.error('SECURITY: Attempted to send group message without encryption keys');
          return;
        }

        // ‚îÄ‚îÄ Try MLS shared-key encryption first (O(1) per message) ‚îÄ‚îÄ
        let mlsEncrypted = null;
        if (window.MLSGroup && currentGroupMembers && currentGroupMembers.length > 0) {
          try {
            const groupState = await getOrCreateMLSGroupState(currentGroupId, currentGroupMembers);
            if (groupState) {
              const wallet = WalletAuth.getWallet();
              const senderPubB64 = wallet ? wallet.publicKey : '';
              const envelope = await window.MLSGroup.encryptGroupMessage(groupState, messageEnvelope, senderPubB64);
              mlsEncrypted = JSON.stringify(envelope);
              // Save updated state
              const storageKey = getRatchetStorageKey();
              if (storageKey) {
                window.MLSGroup.saveGroupStateToServer(currentGroupId, groupState, storageKey, WalletAuth.getAuthHeaders()).catch(() => {});
              }
            }
          } catch (e) {
            console.warn('[MLS] Group encrypt failed, falling back to per-member:', e.message);
          }
        }

        // Always send per-member ciphertext map for backend compatibility
        const encryptedContentByMember = {};
        
        for (const memberId of currentGroupMembers) {
          try {
            const wallet = WalletAuth.getWallet();
            const isMe = wallet && memberId === wallet.publicKey;
            const encrypted = isMe
              ? await encryptForEncryptionPublicKey(messageEnvelope, myEncryptionKeyPair.publicKey)
              : await encryptForRecipient(messageEnvelope, memberId);
            encryptedContentByMember[memberId] = encrypted;
          } catch (e) {
            console.error('SECURITY: Failed to encrypt for member:', memberId, e);
          }
        }
        
        // SECURITY: Do NOT send if encryption fails for any member
        if (Object.keys(encryptedContentByMember).length !== currentGroupMembers.length) {
          alert('Failed to encrypt message for a group member. Message not sent.');
          return;
        }

        // Support both API shapes:
        // - operator-node/gateway: encryptedContentByMember
        // - api-server: encryptedContents
        const bodyPayload = {
          encryptedContentByMember,
          encryptedContents: encryptedContentByMember,
        };
        if (mlsEncrypted) {
          bodyPayload.mlsEncryptedContent = mlsEncrypted;
        }
        const body = JSON.stringify(bodyPayload);

        const response = await fetch(`/api/messages/groups/${currentGroupId}/send`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body
        });

        if (checkAuthAndRedirect(response)) return;

        const data = await response.json();
        if (data.success) {
          input.value = '';
          await loadGroupMessages(currentGroupId);
        } else {
          alert('Failed to send message: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Send group message error:', error);
        alert('Failed to send message: ' + error.message);
      } finally {
        if (sendBtn) sendBtn.disabled = false;
      }
    }

    let groupMessagePollingInterval = null;

    function startGroupMessagePolling() {
      stopGroupMessagePolling();
      groupMessagePollingInterval = setInterval(async () => {
        if (currentGroupId) {
          await loadGroupMessages(currentGroupId);
        }
      }, POLL_INTERVAL_MS);
    }

    function stopGroupMessagePolling() {
      if (groupMessagePollingInterval) {
        clearInterval(groupMessagePollingInterval);
        groupMessagePollingInterval = null;
      }
    }

    // ============================================================
    // GROUP MANAGEMENT FUNCTIONS
    // ============================================================

    let currentGroupInfo = null;

    async function showManageGroupModal() {
      if (!currentGroupId) return;
      
      // Fetch fresh group info
      try {
        const response = await fetch(`/api/messages/groups/${currentGroupId}`, {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (!response.ok) throw new Error('Failed to load group');
        
        const data = await response.json();
        if (!data.success) throw new Error(data.error);
        
        currentGroupInfo = data.group;
        
        document.getElementById('manageGroupName').textContent = 'üë• ' + currentGroupInfo.name;
        
        // Show current members
        const wallet = WalletAuth.getWallet();
        const isAdmin = currentGroupInfo.adminId === wallet.publicKey;
        const currentMembersList = document.getElementById('currentMembersList');
        
        currentMembersList.innerHTML = currentGroupInfo.members.map(memberId => {
          const isMe = memberId === wallet.publicKey;
          const isMemberAdmin = memberId === currentGroupInfo.adminId;
          const shortId = memberId.substring(0, 12) + '...';
          
          return `
            <div class="member-select-item">
              <div class="contact-avatar" style="width: 32px; height: 32px; font-size: 0.9rem; margin-right: 0.75rem;">
                ${isMemberAdmin ? 'üëë' : 'üë§'}
              </div>
              <span style="flex: 1;">${isMe ? 'You' : shortId}${isMemberAdmin ? ' (Admin)' : ''}</span>
              ${isAdmin && !isMe ? `<button onclick="removeMemberFromGroup('${memberId}')" style="background: #ff4444; border: none; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.75rem;">Remove</button>` : ''}
            </div>
          `;
        }).join('');
        
        // Show contacts that can be added
        const localContacts = getLocalContacts();
        const nonMembers = localContacts.filter(c => !currentGroupInfo.members.includes(c.accountId));
        const addMembersList = document.getElementById('addMembersList');
        
        if (nonMembers.length === 0) {
          addMembersList.innerHTML = '<div style="color: #888; text-align: center; padding: 0.5rem;">All contacts are already members</div>';
        } else {
          addMembersList.innerHTML = nonMembers.map(contact => `
            <div class="member-select-item" onclick="addMemberToGroup('${contact.accountId}')">
              <div class="contact-avatar" style="width: 32px; height: 32px; font-size: 0.9rem; margin-right: 0.75rem;">${contact.displayName[0].toUpperCase()}</div>
              <span style="flex: 1;">${escapeHtml(contact.displayName)}</span>
              <span style="color: #4CAF50;">+ Add</span>
            </div>
          `).join('');
        }
        
        document.getElementById('manageGroupModal').style.display = 'flex';
        
      } catch (error) {
        console.error('Failed to load group info:', error);
        alert('Failed to load group settings');
      }
    }

    async function addMemberToGroup(memberId) {
      if (!currentGroupId) return;
      
      try {
        const response = await fetch(`/api/messages/groups/${currentGroupId}/members`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ memberId })
        });
        
        const data = await response.json();
        if (data.success) {
          // Refresh group info and modal
          await loadGroups();
          currentGroupMembers.push(memberId);
          await showManageGroupModal();
        } else {
          alert('Failed to add member: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Add member error:', error);
        alert('Failed to add member');
      }
    }

    async function removeMemberFromGroup(memberId) {
      if (!currentGroupId) return;
      
      if (!confirm('Remove this member from the group?')) return;
      
      try {
        const response = await fetch(`/api/messages/groups/${currentGroupId}/members/${memberId}`, {
          method: 'DELETE',
          headers: WalletAuth.getAuthHeaders()
        });
        
        const data = await response.json();
        if (data.success) {
          // Refresh group info and modal
          await loadGroups();
          currentGroupMembers = currentGroupMembers.filter(m => m !== memberId);
          await showManageGroupModal();
        } else {
          alert('Failed to remove member: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Remove member error:', error);
        alert('Failed to remove member');
      }
    }

    async function leaveCurrentGroup() {
      if (!currentGroupId) return;
      
      if (!confirm('Are you sure you want to leave this group?')) return;
      
      try {
        const response = await fetch(`/api/messages/groups/${currentGroupId}/leave`, {
          method: 'POST',
          headers: WalletAuth.getAuthHeaders()
        });
        
        const data = await response.json();
        if (data.success) {
          closeModals();
          showInbox();
          await loadGroups();
          alert('You have left the group');
        } else {
          alert('Failed to leave group: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Leave group error:', error);
        alert('Failed to leave group');
      }
    }

    async function openConversation(conversationId, recipientId) {
      currentConversationId = conversationId;
      currentRecipientId = recipientId;
      currentGroupId = null; // Reset group context
      currentItemId = null;
      document.getElementById('chatItemContext').textContent = '';
      
      // Get recipient's public key for encryption
      currentRecipientPublicKey = recipientId; // In our system, accountId IS the public key
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      
      // Reset the Add button for 1-on-1 chats
      const addBtn = document.getElementById('addContactChatBtn');
      addBtn.textContent = '‚ûï Add';
      addBtn.onclick = addCurrentRecipientToContacts;
      addBtn.disabled = false;
      addBtn.classList.remove('added');
      updateAddContactButton(isCurrentRecipientInContacts());
      
      // Set participant name
      const conv = conversations.find(c => c.conversationId === conversationId);
      const participant = conv?.participantInfo.find(p => p.accountId === recipientId);
      document.getElementById('chatParticipantName').textContent = participant?.displayName || recipientId.substring(0, 12) + '...';
      
      // Load per-conversation disappearing timer settings
      loadDisappearSettings();
      
      await loadMessages(conversationId);
      
      // Reset message count for new conversation
      lastMessageCount = 0;
      
      // Stop inbox polling, start message polling
      stopInboxPolling();
      startMessagePolling();
    }
    
    let lastMessageCount = 0;
    
    function startMessagePolling() {
      stopMessagePolling(); // Clear any existing interval
      // Use randomized interval for metadata protection (anti-timing analysis)
      function scheduleNext() {
        const jitteredInterval = getRandomizedPollInterval();
        messagePollingInterval = setTimeout(async () => {
          if (currentConversationId) {
            await pollForNewMessages(currentConversationId);
          }
          scheduleNext();
        }, jitteredInterval);
      }
      scheduleNext();
    }
    
    async function pollForNewMessages(conversationId) {
      try {
        const response = await fetch(`/api/messages/conversation/${conversationId}`, {
          headers: WalletAuth.getAuthHeaders()
        });
        const data = await response.json();
        
        if (data.success && data.messages) {
          // Only update if message count changed (new messages arrived)
          if (data.messages.length !== lastMessageCount) {
            lastMessageCount = data.messages.length;
            await renderMessages(data.messages);
            
            // Always scroll to bottom so new messages are visible
            const container = document.getElementById('chatMessages');
            if (container) container.scrollTop = container.scrollHeight;
          }
        }
      } catch (error) {
        console.error('Poll error:', error);
      }
    }
    
    function stopMessagePolling() {
      if (messagePollingInterval) {
        clearTimeout(messagePollingInterval);
        messagePollingInterval = null;
      }
    }
    
    function startInboxPolling() {
      stopInboxPolling();
      inboxPollingInterval = setInterval(async () => {
        await loadConversations();
      }, POLL_INTERVAL_MS);
    }
    
    function stopInboxPolling() {
      if (inboxPollingInterval) {
        clearInterval(inboxPollingInterval);
        inboxPollingInterval = null;
      }
    }

    // ============================================================
    // DISAPPEARING MESSAGES FUNCTIONS
    // ============================================================

    function updateDisappearTimer() {
      const select = document.getElementById('disappearTimer');
      const checkbox = document.getElementById('expiresAfterView');
      const timer = parseInt(select.value) || 0;
      const afterView = checkbox ? checkbox.checked : false;
      // Persist per-conversation
      if (currentConversationId) {
        const stored = JSON.parse(localStorage.getItem('autho_disappear_settings') || '{}');
        stored[currentConversationId] = { timer, afterView };
        localStorage.setItem('autho_disappear_settings', JSON.stringify(stored));
      }
    }

    function loadDisappearSettings() {
      if (!currentConversationId) return;
      const stored = JSON.parse(localStorage.getItem('autho_disappear_settings') || '{}');
      const settings = stored[currentConversationId];
      const select = document.getElementById('disappearTimer');
      const checkbox = document.getElementById('expiresAfterView');
      if (settings && select) {
        select.value = String(settings.timer || 0);
        if (checkbox) checkbox.checked = !!settings.afterView;
      } else if (select) {
        select.value = '0';
        if (checkbox) checkbox.checked = false;
      }
    }

    function getDisappearSettings() {
      const select = document.getElementById('disappearTimer');
      const checkbox = document.getElementById('expiresAfterView');
      const timerValue = select ? parseInt(select.value) || 0 : 0;
      const afterView = checkbox ? checkbox.checked : false;
      
      return {
        selfDestructAfter: timerValue > 0 ? timerValue : undefined,
        expiresAfterView: afterView
      };
    }

    function formatTimeRemaining(expiresAt) {
      const now = Date.now();
      const remaining = expiresAt - now;
      
      if (remaining <= 0) return 'Expired';
      
      if (remaining < 60000) {
        return Math.ceil(remaining / 1000) + 's';
      } else if (remaining < 3600000) {
        return Math.ceil(remaining / 60000) + 'm';
      } else if (remaining < 86400000) {
        return Math.ceil(remaining / 3600000) + 'h';
      } else {
        return Math.ceil(remaining / 86400000) + 'd';
      }
    }

    async function deleteMessage(messageId) {
      if (!confirm('Delete this message for everyone?')) return;
      
      try {
        const response = await fetch(`/api/messages/${messageId}`, {
          method: 'DELETE',
          headers: WalletAuth.getAuthHeaders()
        });
        
        const data = await response.json();
        if (data.success) {
          // Refresh messages
          if (currentConversationId) {
            await loadMessages(currentConversationId);
          } else if (currentGroupId) {
            await loadGroupMessages(currentGroupId);
          }
        } else {
          alert('Failed to delete: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Delete message error:', error);
        alert('Failed to delete message');
      }
    }

    async function markMessageViewed(messageId) {
      try {
        await fetch(`/api/messages/${messageId}/viewed`, {
          method: 'POST',
          headers: WalletAuth.getAuthHeaders()
        });
      } catch (error) {
        console.error('Mark viewed error:', error);
      }
    }

    async function openConversationWithItem(recipientId, itemId) {
      currentRecipientId = recipientId;
      currentRecipientPublicKey = recipientId;
      currentItemId = itemId;
      currentGroupId = null;
      
      // Generate conversation ID
      const wallet = WalletAuth.getWallet();
      const sorted = [wallet.publicKey, recipientId].sort();
      const response = await fetch(`/api/registry/item/${itemId}`);
      const itemData = await response.json();
      
      document.getElementById('chatItemContext').textContent = 
        `About: ${itemData.item?.metadata?.name || itemId}`;
      
      // Use the item-specific conversation
      const convId = await generateConversationId(wallet.publicKey, recipientId, itemId);
      currentConversationId = convId;
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      document.getElementById('chatParticipantName').textContent = 'Item Owner';
      const addBtn = document.getElementById('addContactChatBtn');
      addBtn.textContent = '‚ûï Add';
      addBtn.onclick = addCurrentRecipientToContacts;
      addBtn.disabled = false;
      addBtn.classList.remove('added');
      updateAddContactButton(isCurrentRecipientInContacts());
      
      await loadMessages(convId);
      
      // Stop inbox polling, start message polling
      stopInboxPolling();
      startMessagePolling();
    }

    async function generateConversationId(participant1, participant2, itemId = null) {
      const p1 = participant1.toLowerCase();
      const p2 = participant2.toLowerCase();
      const sorted = [p1, p2].sort();
      const base = `${sorted[0]}:${sorted[1]}${itemId ? ':' + itemId : ''}`;
      const encoder = new TextEncoder();
      const digest = await sha256Bytes(encoder.encode(base));
      const hashArray = Array.from(digest);
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 32);
    }

    let encryptionInitPromise = null;

    function getServiceAccountId() {
      const id = String(localStorage.getItem('autho_account_id') || '').trim();
      if (id) return id;
      const wallet = WalletAuth.getWallet();
      return wallet?.publicKey || wallet?.identityAddress || wallet?.paymentAddress || '';
    }

    async function ensureEncryptionInitialized() {
      if (myEncryptionKeyPair) return true;

      if (!encryptionInitPromise) {
        encryptionInitPromise = (async () => {
          // Use messaging keys from sessionStorage (set during login)
          let messagingPrivateKey = sessionStorage.getItem('autho_messaging_privateKey');
          if (!messagingPrivateKey && typeof WalletAuth.ensureMessagingKeys === 'function') {
            try {
              await WalletAuth.ensureMessagingKeys();
            } catch {}
            messagingPrivateKey = sessionStorage.getItem('autho_messaging_privateKey');
          }
          if (!messagingPrivateKey) {
            throw new Error('Messaging key not found - please log in again');
          }
          myPrivateKey = messagingPrivateKey;
          // Use the robust initialization with nacl waiting and retries
          myEncryptionKeyPair = await initializeEncryption(myPrivateKey);
          // Generate ML-KEM-768 (Kyber) keypair for post-quantum hybrid
          try {
            if (window.MlKemModule && window.MlKemModule.MlKem768) {
              const kyber = new window.MlKemModule.MlKem768();
              const [kyberPk, kyberSk] = await kyber.generateKeyPair();
              myKyberKeyPair = { publicKey: kyberPk, secretKey: kyberSk };
              console.log('[Messaging] ML-KEM-768 (post-quantum) keypair generated');
            }
          } catch (e) {
            console.warn('[Messaging] ML-KEM-768 keygen failed (PQ not available):', e.message);
          }
          await publishMyEncryptionPublicKey();
          // Key transparency: publish hash for audit (non-blocking)
          publishKeyTransparencyHash().catch(() => {});
          // X3DH: publish/rotate signed pre-key bundle (non-blocking)
          maybeRotatePreKeys().catch(() => {});
          // Real-time messaging: connect WebSocket (non-blocking)
          try { connectMessagingWebSocket(); } catch {}
          return myEncryptionKeyPair;
        })();
      }

      try {
        await encryptionInitPromise;
        return !!myEncryptionKeyPair;
      } catch (e) {
        console.error('Encryption init failed:', e);
        encryptionInitPromise = null; // Reset so we can retry
        return false;
      }
    }

    async function loadMessages(conversationId) {
      const container = document.getElementById('chatMessages');
      container.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
      
      try {
        const response = await fetch(`/api/messages/conversation/${conversationId}`, {
          headers: WalletAuth.getAuthHeaders()
        });
        const data = await response.json();

        if (data.success) {
          renderMessages(data.messages);
        }
      } catch (error) {
        console.error('Failed to load messages:', error);
        container.innerHTML = '<div style="text-align:center;color:#888;">Failed to load messages</div>';
      }
    }

    function renderMessages(messages) {
      const container = document.getElementById('chatMessages');
      const wallet = WalletAuth.getWallet();
      
      if (messages.length === 0) {
        container.innerHTML = `
          <div style="text-align:center;color:#888;padding:2rem;">
            Start the conversation by sending a message
          </div>
        `;
        return;
      }

      // Track which messages need to be marked as viewed
      const messagesToMarkViewed = [];
      
      container.innerHTML = messages.map(msg => {
        const isSent = msg.senderId === wallet.publicKey;
        const timeStr = new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const expiresIn = formatTimeUntil(msg.expiresAt);
        
        // Mark received messages with expiresAfterView as viewed
        if (!isSent && msg.expiresAfterView && !msg.viewedAt) {
          messagesToMarkViewed.push(msg.messageId);
        }
        
        // Decrypt message (in production, use actual decryption)
        let decryptedText = '[Encrypted]';
        try {
          // For now, show placeholder - real decryption would happen client-side
          decryptedText = decryptMessage(msg.encryptedContent);
        } catch (e) {
          decryptedText = '[Could not decrypt]';
        }
        
        // Show disappearing indicator for expiresAfterView messages
        const disappearIcon = msg.expiresAfterView ? 'üëÅÔ∏è ' : '';
        
        return `
          <div class="message-bubble ${isSent ? 'sent' : 'received'}">
            <div class="message-text">${escapeHtml(decryptedText)}</div>
            <div class="message-meta">
              ${disappearIcon}${timeStr}
              <span class="message-expires">‚Ä¢ expires ${expiresIn}</span>
            </div>
          </div>
        `;
      }).join('');
      
      // Scroll to bottom
      container.scrollTop = container.scrollHeight;
      
      // Mark viewed messages (fire-and-forget, don't await)
      messagesToMarkViewed.forEach(messageId => {
        markMessageViewed(messageId);
      });
    }

    function decryptMessage(encryptedContent, senderId) {
      // Try to decrypt E2E encrypted message
      try {
        const parsed = JSON.parse(encryptedContent);
        
        // v5: Double Ratchet, v4: PQ hybrid, v3: ephemeral key encryption
        if (parsed.v === 5 && parsed.h && parsed.iv && parsed.c) {
          return { encrypted: true, data: encryptedContent, senderId };
        }
        if (parsed.v === 4 && parsed.e && parsed.k && parsed.iv && parsed.c) {
          return { encrypted: true, data: encryptedContent, senderId };
        }
        if (parsed.v === 3 && parsed.e && parsed.n && parsed.c) {
          return { encrypted: true, data: encryptedContent, senderId };
        }
        // v1: legacy encrypted format
        if (parsed.v === 1 && parsed.n && parsed.c && parsed.s) {
          return { encrypted: true, data: encryptedContent, senderId };
        }
        
        // Legacy unencrypted format
        if (parsed.type && parsed.type !== 'text') {
          return JSON.stringify(parsed);
        }
        if (parsed.content) return parsed.content;
      } catch (e) {}
      return encryptedContent;
    }

    // Async decrypt for rendering
    async function decryptMessageAsync(encryptedContent, senderId) {
      try {
        const parsed = JSON.parse(encryptedContent);
        
        // All encrypted envelope versions (v1-v5): use unified decrypt
        if (parsed.v && (parsed.c || parsed.h)) {
          const ok = await ensureEncryptionInitialized();
          if (!ok || !myEncryptionKeyPair) return '[Could not decrypt]';
          try {
            const decrypted = await decryptFromSender(encryptedContent, senderId);
            if (decrypted) return decrypted;
          } catch (decErr) {
            console.warn('[Decrypt] Failed for v' + parsed.v + ':', decErr.message);
          }
          return '[Could not decrypt]';
        }
        
        // Legacy unencrypted format
        if (parsed.type && parsed.type !== 'text') {
          return JSON.stringify(parsed);
        }
        if (parsed.content) return parsed.content;
      } catch (e) {}
      return encryptedContent;
    }

    async function sendMessage() {
      // Route to group message if in group chat
      if (currentGroupId) {
        return sendGroupMessage();
      }
      
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      if (!text || !currentRecipientId) return;

      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;

      // ‚îÄ‚îÄ OPTIMISTIC UI: show message instantly ‚îÄ‚îÄ
      const tempId = renderOptimisticMessage(text);
      input.value = '';
      
      try {
        // Create message envelope
        const messageEnvelope = JSON.stringify({
          type: 'text',
          content: text,
          timestamp: Date.now()
        });
        
        if (!await ensureEncryptionInitialized()) {
          WalletAuth.lock();
          updateOptimisticMessage(tempId, 'failed');
          alert('Encryption not initialized. Please log in again.');
          WalletAuth.requireAuth();
          console.error('SECURITY: Attempted to send message without encryption keys');
          return;
        }
        
        // E2E encrypt the message for recipient
        const encryptedForRecipient = await encryptForRecipient(messageEnvelope, currentRecipientId);
        // Also encrypt for self (so we can read our own sent messages)
        const wallet = WalletAuth.getWallet();
        const encryptedForSender = await encryptForEncryptionPublicKey(messageEnvelope, myEncryptionKeyPair.publicKey);

        // ‚îÄ‚îÄ Wire protocol: compress encrypted content if available ‚îÄ‚îÄ
        let sendPayload = {
          recipientId: currentRecipientId,
          encryptedContent: encryptedForRecipient,
          encryptedForSender: encryptedForSender,
          itemId: currentItemId || undefined,
          conversationId: currentConversationId || undefined,
          mediaType: 'text'
        };

        // Get disappearing message settings
        const disappearSettings = getDisappearSettings();
        if (disappearSettings.selfDestructAfter) sendPayload.selfDestructAfter = disappearSettings.selfDestructAfter;
        if (disappearSettings.expiresAfterView) sendPayload.expiresAfterView = disappearSettings.expiresAfterView;

        // Add wire protocol size metrics (for debugging)
        if (window.AutohoWire) {
          try {
            const metrics = window.AutohoWire.measureSavings(encryptedForRecipient);
            console.log('[Wire] Envelope: ' + metrics.jsonSize + 'B ‚Üí ' + metrics.binarySize + 'B (' + metrics.savedPercent + ' saved)');
          } catch {}
        }
        
        const response = await fetch('/api/messages/send', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify(sendPayload)
        });
        
        const data = await response.json();
        if (data.success) {
          updateOptimisticMessage(tempId, 'sent');
          if (data.conversationId) {
            currentConversationId = data.conversationId;
          }
          // Refresh inbox list so you can see the conversation immediately
          loadConversations();
        } else {
          updateOptimisticMessage(tempId, 'failed');
          alert(data.error || 'Failed to send message');
        }
      } catch (error) {
        console.error('Send error:', error);
        updateOptimisticMessage(tempId, 'failed');
        const errorMsg = error?.message || '';
        if (errorMsg.includes('recipient') || errorMsg.includes('Recipient') || errorMsg.includes('not found')) {
          alert('Cannot send: The recipient has not set up messaging yet. Ask them to log in first.');
        } else if (errorMsg.includes('not initialized')) {
          alert('Encryption error. Please refresh and try again.');
        } else {
          alert('Failed to send message: ' + errorMsg);
        }
      } finally {
        sendBtn.disabled = false;
      }
    }

    function showInbox() {
      document.getElementById('chatView').classList.remove('active');
      document.getElementById('inboxView').style.display = 'block';
      currentConversationId = null;
      currentRecipientId = null;
      currentGroupId = null;
      
      // Stop message polling, start inbox polling
      stopMessagePolling();
      stopGroupMessagePolling();
      startInboxPolling();
      
      loadConversations();
    }

    function startConversation(contactId) {
      openConversation(null, contactId);
    }

    function formatTimeAgo(timestamp) {
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return 'now';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      if (seconds < 86400) return Math.floor(seconds / 3600) + 'h';
      return Math.floor(seconds / 86400) + 'd';
    }

    function formatTime(timestamp) {
      if (!timestamp) return '';
      try {
        return new Date(Number(timestamp)).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } catch {
        return '';
      }
    }

    function formatTimeUntil(timestamp) {
      const seconds = Math.floor((timestamp - Date.now()) / 1000);
      if (seconds < 0) return 'expired';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      if (seconds < 86400) return Math.floor(seconds / 3600) + 'h';
      return Math.floor(seconds / 86400) + 'd';
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ============================================================
    // CONTACT SHARING FUNCTIONS
    // ============================================================

    function showShareModal() {
      const wallet = WalletAuth.getWallet();
      if (!wallet) return;
      
      // Generate shareable link
      const baseUrl = window.location.origin;
      const shareUrl = `${baseUrl}/mobile-messages.html?contact=${wallet.publicKey}`;
      document.getElementById('shareLink').value = shareUrl;
      
      // Generate QR code using qrcodejs library (same as mobile-verify.html)
      const qrContainer = document.getElementById('qrContainer');
      qrContainer.innerHTML = '';
      
      try {
        if (typeof QRCode !== 'function') {
          qrContainer.innerHTML = '<div style="color:#ff6b6b;padding:20px;">QR library not available</div>';
          return;
        }
        new QRCode(qrContainer, {
          text: shareUrl,
          width: 200,
          height: 200,
          correctLevel: QRCode.CorrectLevel.M
        });
      } catch (e) {
        console.error('QR generation error:', e);
        qrContainer.innerHTML = '<div style="color:#ff6b6b;padding:20px;">QR generation failed</div>';
      }
      
      document.getElementById('shareModal').style.display = 'flex';
    }

    function showAddContactModal() {
      document.getElementById('addContactInput').value = '';
      document.getElementById('addContactModal').style.display = 'flex';
    }

    // QR Scanner state
    let qrScannerStream = null;
    let qrScannerActive = false;

    async function toggleQrScanner() {
      if (qrScannerActive) {
        stopQrScanner();
      } else {
        await startQrScanner();
      }
    }

    async function startQrScanner() {
      const container = document.getElementById('qrScannerContainer');
      const video = document.getElementById('qrScannerVideo');
      const status = document.getElementById('qrScannerStatus');
      const btn = document.getElementById('scanQrBtn');
      
      try {
        qrScannerStream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'environment' } 
        });
        video.srcObject = qrScannerStream;
        await video.play();
        
        container.style.display = 'block';
        btn.textContent = '‚úï Stop Scanner';
        btn.style.background = '#c0392b';
        qrScannerActive = true;
        status.textContent = 'Point camera at QR code...';
        
        // Start scanning
        scanQrCode(video, status);
      } catch (e) {
        console.error('Camera error:', e);
        status.textContent = 'Could not access camera';
        alert('Could not access camera. Please grant permission.');
      }
    }

    function stopQrScanner() {
      const container = document.getElementById('qrScannerContainer');
      const video = document.getElementById('qrScannerVideo');
      const btn = document.getElementById('scanQrBtn');
      
      if (qrScannerStream) {
        qrScannerStream.getTracks().forEach(t => t.stop());
        qrScannerStream = null;
      }
      video.srcObject = null;
      container.style.display = 'none';
      btn.textContent = 'üì∑ Scan QR Code';
      btn.style.background = '#333';
      qrScannerActive = false;
    }

    function scanQrCode(video, status) {
      if (!qrScannerActive) return;
      
      // Use canvas to capture frame and analyze
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth || 320;
      canvas.height = video.videoHeight || 240;
      
      const scan = () => {
        if (!qrScannerActive) return;
        
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // Use jsQR library if available, otherwise try BarcodeDetector API
        if (typeof jsQR !== 'undefined') {
          const code = jsQR(imageData.data, canvas.width, canvas.height);
          if (code && code.data) {
            handleQrResult(code.data);
            return;
          }
        } else if ('BarcodeDetector' in window) {
          const detector = new BarcodeDetector({ formats: ['qr_code'] });
          detector.detect(canvas).then(barcodes => {
            if (barcodes.length > 0) {
              handleQrResult(barcodes[0].rawValue);
              return;
            }
          }).catch(() => {});
        }
        
        // Continue scanning
        requestAnimationFrame(scan);
      };
      
      requestAnimationFrame(scan);
    }

    function handleQrResult(data) {
      console.log('QR scanned:', data);
      
      // Stop scanner FIRST and ensure camera is fully released
      stopQrScanner();
      
      // Extract contact ID from scanned data
      let contactId = data;
      if (data.includes('contact=')) {
        const match = data.match(/contact=([^&]+)/);
        if (match) contactId = match[1];
      } else if (data.includes('/m/messages?')) {
        try {
          const url = new URL(data);
          contactId = url.searchParams.get('contact') || data;
        } catch {}
      }
      
      // Close modal and add contact (don't auto-open conversation to avoid camera conflicts)
      closeModals();
      
      if (contactId) {
        // Just add contact to list, don't open conversation immediately
        addContactOnly(contactId);
      }
    }
    
    async function addContactOnly(contactId) {
      const wallet = WalletAuth.getWallet();
      if (!wallet || contactId === wallet.publicKey) {
        alert("You can't add yourself as a contact");
        return;
      }
      
      // Always save to localStorage first (backup)
      addLocalContact(contactId);

      if (getPrivateContactsMode()) {
        try {
          await syncPrivateContactsFromLocal();
        } catch (error) {
          console.error('Encrypted contacts save failed:', error);
          alert('Failed to sync encrypted contacts: ' + (error?.message || 'Unknown error'));
        }
        alert('Contact added to encrypted private contacts.');
        await loadContacts();
        return;
      }
      
      try {
        const res = await fetch('/api/messages/contacts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ contactId: contactId })
        });
        
        if (res.ok) {
          alert('Contact added! Tap their name in the list to start chatting.');
          loadContacts(); // Refresh contacts list
        } else {
          const data = await res.json().catch(() => ({}));
          alert('Failed to add contact: ' + (data.error || 'Unknown error'));
        }
      } catch (e) {
        console.error('Add contact error:', e);
        alert('Contact saved locally. Will sync when server is available.');
      }
    }

    function closeModals() {
      stopQrScanner();
      document.getElementById('shareModal').style.display = 'none';
      document.getElementById('addContactModal').style.display = 'none';
      document.getElementById('createGroupModal').style.display = 'none';
      document.getElementById('manageGroupModal').style.display = 'none';
    }

    function copyShareLink() {
      const input = document.getElementById('shareLink');
      input.select();
      navigator.clipboard.writeText(input.value).then(() => {
        const btn = input.nextElementSibling;
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy', 2000);
      });
    }

    function addContactFromInput() {
      const input = document.getElementById('addContactInput').value.trim();
      if (!input) return;
      
      // Extract accountId from input (could be full URL or just the ID)
      let contactId = input;
      
      // Check if it's a URL with contact parameter
      if (input.includes('contact=')) {
        const match = input.match(/contact=([^&]+)/);
        if (match) contactId = match[1];
      } else if (input.includes('/m/messages?')) {
        const url = new URL(input);
        contactId = url.searchParams.get('contact') || input;
      }
      
      if (contactId) {
        addContactAndStartChat(contactId);
        closeModals();
      }
    }

    async function addContactAndStartChat(contactId) {
      const wallet = WalletAuth.getWallet();
      if (!wallet || contactId === wallet.publicKey) {
        alert("You can't add yourself as a contact");
        return;
      }

      addLocalContact(contactId);

      if (getPrivateContactsMode()) {
        try {
          await syncPrivateContactsFromLocal();
        } catch (error) {
          console.error('Encrypted contacts save failed:', error);
        }
      }
      
      // Add to contacts via API
      if (!getPrivateContactsMode()) {
        try {
          await fetch('/api/messages/contacts', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              ...WalletAuth.getAuthHeaders()
            },
            body: JSON.stringify({ contactId })
          });
        } catch (e) {
          console.log('Contact add request:', e);
        }
      }
      
      // Clear URL parameters
      window.history.replaceState({}, '', '/m/messages');
      
      // Start conversation with the contact
      currentRecipientId = contactId;
      currentRecipientPublicKey = contactId;
      currentItemId = null;
      currentConversationId = null;
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      document.getElementById('chatParticipantName').textContent = contactId.substring(0, 12) + '...';
      document.getElementById('chatItemContext').textContent = '';
      updateAddContactButton(true);
      
      // Load any existing messages (might be empty for new contact)
      const convId = await generateConversationId(wallet.publicKey, contactId, null);
      currentConversationId = convId;
      await loadMessages(convId);
      
      // Refresh contacts
      loadContacts();
    }

    async function addCurrentRecipientToContacts() {
      if (!currentRecipientId) return;
      
      const btn = document.getElementById('addContactChatBtn');
      btn.disabled = true;
      let added = false;

      if (getPrivateContactsMode()) {
        addLocalContact(currentRecipientId, document.getElementById('chatParticipantName')?.textContent || undefined);
        try {
          await syncPrivateContactsFromLocal();
        } catch (error) {
          console.error('Encrypted contacts save failed:', error);
        }
        updateAddContactButton(true);
        await loadContacts();
        return;
      }
      
      try {
        const response = await fetch('/api/messages/contacts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ contactId: currentRecipientId })
        });
        
        const data = await response.json();
        if (data.success) {
          addLocalContact(currentRecipientId, document.getElementById('chatParticipantName')?.textContent || undefined);
          updateAddContactButton(true);
          loadContacts();
          added = true;
        } else {
          alert(data.error || 'Failed to add contact');
        }
      } catch (e) {
        console.error('Add contact error:', e);
      } finally {
        if (!added) btn.disabled = false;
      }
    }

    function updateAddContactButton(isAlreadyContact) {
      const btn = document.getElementById('addContactChatBtn');
      if (!btn || currentGroupId || !currentRecipientId) return;
      if (isAlreadyContact) {
        btn.textContent = '‚úì Contact';
        btn.classList.add('added');
        btn.disabled = true;
        btn.onclick = null;
      } else {
        btn.textContent = '‚ûï Add';
        btn.classList.remove('added');
        btn.disabled = false;
        btn.onclick = addCurrentRecipientToContacts;
      }
    }

    // ============================================================
    // MEDIA MESSAGING FUNCTIONS
    // ============================================================
    
    let pendingMedia = null; // { type: 'image'|'video'|'audio', data: base64, name: string, size: number }
    let audioRecorder = null;
    let audioChunks = [];
    let audioTimerInterval = null;
    let audioStartTime = null;
    const MAX_AUDIO_SECONDS = 30;
    const MAX_VIDEO_SECONDS = 15;
    
    // Premium file tiers (size in bytes, cost in sats)
    const FILE_TIERS = {
      free: { maxSize: 1 * 1024 * 1024, cost: 0, label: '1 MB' },          // 1MB free
      basic: { maxSize: 25 * 1024 * 1024, cost: 10, label: '25 MB' },       // 25MB for 10 sats
      premium: { maxSize: 100 * 1024 * 1024, cost: 25, label: '100 MB' },   // 100MB for 25 sats
      enterprise: { maxSize: 1024 * 1024 * 1024, cost: 50, label: '1 GB' },    // 1GB for 50 sats
    };
    
    let selectedFileTier = 'free';
    const MAX_IMAGE_SIZE = 500 * 1024; // 500KB after compression (free tier)
    const MAX_VIDEO_SIZE = FILE_TIERS.free.maxSize; // Dynamic based on tier

    // Get max file size based on balance
    async function getMaxFileSizeForBalance() {
      await fetchServiceBalance();
      
      if (serviceBalance >= FILE_TIERS.enterprise.cost) {
        return { tier: 'enterprise', ...FILE_TIERS.enterprise };
      } else if (serviceBalance >= FILE_TIERS.premium.cost) {
        return { tier: 'premium', ...FILE_TIERS.premium };
      } else if (serviceBalance >= FILE_TIERS.basic.cost) {
        return { tier: 'basic', ...FILE_TIERS.basic };
      }
      return { tier: 'free', ...FILE_TIERS.free };
    }

    // Check if file needs premium tier and handle payment
    async function checkFileTierAndPay(fileSize, fileName) {
      const tierInfo = await getMaxFileSizeForBalance();
      
      // Determine required tier
      let requiredTier = 'free';
      let requiredCost = 0;
      
      if (fileSize > FILE_TIERS.enterprise.maxSize) {
        alert('File too large. Maximum size is 1 GB.');
        return null;
      } else if (fileSize > FILE_TIERS.premium.maxSize) {
        requiredTier = 'enterprise';
        requiredCost = FILE_TIERS.enterprise.cost;
      } else if (fileSize > FILE_TIERS.basic.maxSize) {
        requiredTier = 'premium';
        requiredCost = FILE_TIERS.premium.cost;
      } else if (fileSize > FILE_TIERS.free.maxSize) {
        requiredTier = 'basic';
        requiredCost = FILE_TIERS.basic.cost;
      }
      
      // If free tier is sufficient, no payment needed
      if (requiredTier === 'free') {
        return { approved: true, cost: 0 };
      }
      
      // Check if user has sufficient balance
      if (serviceBalance < requiredCost) {
        const sizeMB = (fileSize / 1024 / 1024).toFixed(1);
        alert(`File is ${sizeMB} MB. You need ${requiredCost} sats in your service balance to send files this large.\n\nYour balance: ${serviceBalance} sats`);
        showInsufficientBalanceModal(requiredCost);
        return null;
      }
      
      // Confirm payment
      const tierLabel = FILE_TIERS[requiredTier].label;
      if (!confirm(`Sending "${fileName}" (${(fileSize / 1024 / 1024).toFixed(1)} MB) requires the ${tierLabel} tier.\n\nThis will deduct ${requiredCost} sats from your service balance.\n\nContinue?`)) {
        return null;
      }
      
      // Deduct balance
      try {
        const accountId = getServiceAccountId();
        
        const res = await fetch('/api/service/premium/file-transfer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...WalletAuth.getAuthHeaders() },
          body: JSON.stringify({
            accountId,
            tier: requiredTier,
            fileSize,
            fileName,
          }),
        });
        
        const data = await res.json();
        
        if (data.success) {
          serviceBalance = data.newBalance || (serviceBalance - requiredCost);
          // Update the balance display in the header immediately
          const balanceEl = document.getElementById('msgServiceBalance');
          if (balanceEl) balanceEl.textContent = serviceBalance.toLocaleString();
          return { approved: true, cost: requiredCost, tier: requiredTier };
        } else {
          alert(data.error || 'Failed to process file transfer payment');
          return null;
        }
      } catch (e) {
        console.error('File tier payment error:', e);
        alert('Error processing payment: ' + e.message);
        return null;
      }
    }

    let pendingPhotoFile = null;
    let pendingPhotoCompressed = null;
    
    async function handlePhotoSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      try {
        // ‚îÄ‚îÄ Wire protocol: optimize image (WebP + resize to 1600px max) ‚îÄ‚îÄ
        let optimized = null;
        if (window.AutohoWire) {
          try {
            optimized = await window.AutohoWire.optimizeImage(file, 1600, 1600, 0.82);
            console.log('[Wire] Image: ' + (file.size/1024).toFixed(0) + 'KB ‚Üí ' + (optimized.blob.size/1024).toFixed(0) + 'KB (' + optimized.savings + ' saved)');
          } catch (e) {
            console.warn('[Wire] Image optimize failed, using fallback:', e.message);
          }
        }

        if (optimized && optimized.blob.size < file.size) {
          // Use optimized WebP/JPEG
          const reader = new FileReader();
          const data = await new Promise((resolve, reject) => {
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(optimized.blob);
          });
          pendingMedia = {
            type: 'image',
            data: data,
            name: file.name || 'Photo',
            size: optimized.blob.size,
            mime: optimized.type
          };
          showMediaPreview();
        } else {
          // Fallback to existing compression
          const compressed = await compressImage(file, MAX_IMAGE_SIZE);
          if (file.size > FILE_TIERS.free.maxSize) {
            pendingPhotoFile = file;
            pendingPhotoCompressed = compressed;
            showPhotoQualityModal(file, compressed);
            event.target.value = '';
            return;
          }
          pendingMedia = {
            type: 'image',
            data: compressed.data,
            name: file.name || 'Photo',
            size: compressed.size
          };
          showMediaPreview();
        }
      } catch (e) {
        console.error('Photo processing error:', e);
        alert('Failed to process photo');
      }
      event.target.value = ''; // Reset input
    }
    
    function showPhotoQualityModal(file, compressed) {
      const originalMB = (file.size / 1024 / 1024).toFixed(1);
      const compressedKB = Math.round(compressed.size / 1024);
      
      // Determine cost for original
      let originalCost = 0;
      if (file.size > FILE_TIERS.premium.maxSize) {
        originalCost = FILE_TIERS.enterprise.cost;
      } else if (file.size > FILE_TIERS.basic.maxSize) {
        originalCost = FILE_TIERS.premium.cost;
      } else if (file.size > FILE_TIERS.free.maxSize) {
        originalCost = FILE_TIERS.basic.cost;
      }
      
      const modal = document.createElement('div');
      modal.id = 'photoQualityModal';
      modal.className = 'modal active';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 340px;">
          <h3 style="margin-bottom: 12px;">üì∑ Photo Quality</h3>
          <p style="font-size: 14px; color: #666; margin-bottom: 16px;">
            Original: ${originalMB} MB<br>
            Compressed: ${compressedKB} KB
          </p>
          <button id="sendCompressedBtn" class="btn btn-primary" style="width: 100%; margin-bottom: 10px; padding: 14px;">
            ‚úì Send Compressed (FREE)
          </button>
          <button id="sendOriginalBtn" class="btn btn-secondary" style="width: 100%; margin-bottom: 10px; padding: 14px;">
            Send Original (${originalCost} sats)
          </button>
          <button id="cancelPhotoBtn" class="btn" style="width: 100%; padding: 12px; background: #f5f5f5; color: #666;">
            Cancel
          </button>
        </div>
      `;
      document.body.appendChild(modal);
      
      document.getElementById('sendCompressedBtn').onclick = () => {
        closePhotoQualityModal();
        pendingMedia = {
          type: 'image',
          data: pendingPhotoCompressed.data,
          name: pendingPhotoFile.name || 'Photo',
          size: pendingPhotoCompressed.size
        };
        showMediaPreview();
        pendingPhotoFile = null;
        pendingPhotoCompressed = null;
      };
      
      document.getElementById('sendOriginalBtn').onclick = async () => {
        closePhotoQualityModal();
        const tierResult = await checkFileTierAndPay(pendingPhotoFile.size, pendingPhotoFile.name);
        if (!tierResult) {
          pendingPhotoFile = null;
          pendingPhotoCompressed = null;
          return;
        }
        const data = await fileToBase64(pendingPhotoFile);
        pendingMedia = {
          type: 'image',
          data: data,
          name: pendingPhotoFile.name || 'Photo (Original)',
          size: pendingPhotoFile.size,
          tierCost: tierResult.cost
        };
        showMediaPreview();
        pendingPhotoFile = null;
        pendingPhotoCompressed = null;
      };
      
      document.getElementById('cancelPhotoBtn').onclick = () => {
        closePhotoQualityModal();
        pendingPhotoFile = null;
        pendingPhotoCompressed = null;
      };
    }
    
    function closePhotoQualityModal() {
      const modal = document.getElementById('photoQualityModal');
      if (modal) modal.remove();
    }

    async function handleVideoSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Check file tier and process payment if needed
      const tierResult = await checkFileTierAndPay(file.size, file.name);
      if (!tierResult) {
        event.target.value = '';
        return;
      }
      
      try {
        const data = await fileToBase64(file);
        pendingMedia = {
          type: 'video',
          data: data,
          name: file.name || 'Video',
          size: file.size,
          tierCost: tierResult.cost
        };
        showMediaPreview();
      } catch (e) {
        console.error('Video processing error:', e);
        alert('Failed to process video');
      }
      event.target.value = '';
    }

    async function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;

      const tierResult = await checkFileTierAndPay(file.size, file.name);
      if (!tierResult) {
        event.target.value = '';
        return;
      }

      try {
        const data = await fileToBase64(file);
        pendingMedia = {
          type: 'file',
          data,
          name: file.name || 'File',
          size: file.size,
          mime: file.type || 'application/octet-stream',
          tierCost: tierResult.cost,
        };
        showMediaPreview();
      } catch (e) {
        console.error('File processing error:', e);
        alert('Failed to process file');
      }

      event.target.value = '';
    }

    async function compressImage(file, maxSize) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;
            
            // Scale down if needed
            const maxDim = 1200;
            if (width > maxDim || height > maxDim) {
              if (width > height) {
                height = Math.round(height * maxDim / width);
                width = maxDim;
              } else {
                width = Math.round(width * maxDim / height);
                height = maxDim;
              }
            }
            
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            // Try different quality levels
            let quality = 0.8;
            let data = canvas.toDataURL('image/jpeg', quality);
            
            while (data.length > maxSize * 1.37 && quality > 0.1) { // base64 is ~37% larger
              quality -= 0.1;
              data = canvas.toDataURL('image/jpeg', quality);
            }
            
            resolve({
              data: data,
              size: Math.round(data.length * 0.73) // Approximate actual size
            });
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    // Detect iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    
    // Convert base64 data URL to Blob URL for better mobile video compatibility
    function base64ToBlobUrl(base64DataUrl) {
      try {
        const parts = base64DataUrl.split(',');
        const mimeMatch = parts[0].match(/:(.*?);/);
        const mime = mimeMatch ? mimeMatch[1] : 'video/mp4';
        const bstr = atob(parts[1]);
        let n = bstr.length;
        const u8arr = new Uint8Array(n);
        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }
        const blob = new Blob([u8arr], { type: mime });
        return { url: URL.createObjectURL(blob), mime: mime };
      } catch (e) {
        console.error('Failed to convert base64 to blob:', e);
        return { url: base64DataUrl, mime: 'video/mp4' };
      }
    }
    
    // Track blob URLs and base64 for cleanup/fallback
    const videoBlobUrls = new Map();
    const videoBase64Data = new Map();

    function showMediaPreview() {
      if (!pendingMedia) return;
      
      const preview = document.getElementById('mediaPreview');
      const thumb = document.getElementById('mediaPreviewThumb');
      const name = document.getElementById('mediaPreviewName');
      const size = document.getElementById('mediaPreviewSize');
      
      name.textContent = pendingMedia.type === 'file'
        ? (pendingMedia.name || 'File')
        : pendingMedia.type.charAt(0).toUpperCase() + pendingMedia.type.slice(1);
      size.textContent = formatFileSize(pendingMedia.size);
      
      if (pendingMedia.type === 'image') {
        thumb.innerHTML = `<img src="${pendingMedia.data}" alt="Preview">`;
      } else if (pendingMedia.type === 'video') {
        thumb.innerHTML = `<video src="${pendingMedia.data}" muted></video>`;
      } else if (pendingMedia.type === 'audio') {
        thumb.innerHTML = `<div style="font-size:2rem">üéµ</div>`;
      } else if (pendingMedia.type === 'file') {
        thumb.innerHTML = `<div style="font-size:2rem">üìé</div>`;
      }
      
      preview.classList.add('active');
    }

    function clearMediaPreview() {
      pendingMedia = null;
      document.getElementById('mediaPreview').classList.remove('active');
      document.getElementById('mediaPreviewThumb').innerHTML = '';
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
      return (bytes / 1024 / 1024).toFixed(1) + ' MB';
    }

    // Audio Recording - detect best supported format for iOS/Android compatibility
    function getSupportedAudioMimeType() {
      const types = [
        'audio/mp4',           // iOS Safari preferred
        'audio/aac',           // iOS fallback
        'audio/webm;codecs=opus', // Chrome/Firefox preferred
        'audio/webm',          // Generic WebM
        'audio/ogg;codecs=opus',
        ''                     // Let browser choose default
      ];
      for (const type of types) {
        if (type === '' || MediaRecorder.isTypeSupported(type)) {
          return type;
        }
      }
      return '';
    }

    let audioMimeType = '';

    async function toggleAudioRecording() {
      if (audioRecorder && audioRecorder.state === 'recording') {
        // Already recording - stop will be handled by sendAudioRecording
        return;
      }
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Use iOS-compatible format if available
        audioMimeType = getSupportedAudioMimeType();
        const options = audioMimeType ? { mimeType: audioMimeType } : {};
        
        audioRecorder = new MediaRecorder(stream, options);
        audioChunks = [];
        
        console.log('Recording with MIME type:', audioRecorder.mimeType);
        
        audioRecorder.ondataavailable = (e) => {
          audioChunks.push(e.data);
        };
        
        audioRecorder.onstop = () => {
          stream.getTracks().forEach(t => t.stop());
        };
        
        audioRecorder.start();
        audioStartTime = Date.now();
        
        // Show recorder UI
        document.getElementById('audioRecorder').classList.add('active');
        document.getElementById('audioBtn').classList.add('recording');
        
        // Start timer
        audioTimerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - audioStartTime) / 1000);
          document.getElementById('audioTimer').textContent = 
            `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
          
          // Auto-stop at max duration
          if (elapsed >= MAX_AUDIO_SECONDS) {
            sendAudioRecording();
          }
        }, 100);
        
      } catch (e) {
        console.error('Audio recording error:', e);
        alert('Could not access microphone. Please grant permission.');
      }
    }

    function cancelAudioRecording() {
      if (audioRecorder && audioRecorder.state === 'recording') {
        audioRecorder.stop();
      }
      clearAudioRecorder();
    }

    function clearAudioRecorder() {
      if (audioTimerInterval) {
        clearInterval(audioTimerInterval);
        audioTimerInterval = null;
      }
      audioRecorder = null;
      audioChunks = [];
      audioStartTime = null;
      document.getElementById('audioRecorder').classList.remove('active');
      document.getElementById('audioBtn').classList.remove('recording');
      document.getElementById('audioTimer').textContent = '0:00';
    }

    async function sendAudioRecording() {
      if (!audioRecorder || audioRecorder.state !== 'recording') return;
      
      audioRecorder.stop();
      
      // Wait for data to be available
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Use the actual MIME type from the recorder (handles iOS MP4 vs Chrome WebM)
      const actualMimeType = audioRecorder?.mimeType || audioMimeType || 'audio/webm';
      const blob = new Blob(audioChunks, { type: actualMimeType });
      console.log('Audio blob created with type:', actualMimeType);
      const data = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
      
      pendingMedia = {
        type: 'audio',
        data: data,
        name: 'Voice message',
        size: blob.size
      };
      
      clearAudioRecorder();
      
      // Send immediately
      await sendMediaMessage();
    }

    async function sendMediaMessage() {
      if (!pendingMedia || !currentRecipientId) return;
      
      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;

      // ‚îÄ‚îÄ OPTIMISTIC UI: show media message instantly ‚îÄ‚îÄ
      const mediaLabel = pendingMedia.type === 'image' ? 'üì∑ Photo' :
                         pendingMedia.type === 'video' ? 'üé• Video' :
                         pendingMedia.type === 'audio' ? 'üéµ Voice message' : 'üìé File';
      const tempId = renderOptimisticMessage(mediaLabel + ' (' + formatFileSize(pendingMedia.size) + ')');
      
      try {
        // ‚îÄ‚îÄ Strip EXIF metadata from JPEG images for privacy ‚îÄ‚îÄ
        let mediaData = pendingMedia.data;
        if (pendingMedia.type === 'image' && typeof stripImageMetadata === 'function') {
          try {
            // Convert base64 to ArrayBuffer, strip, convert back
            const b64Part = mediaData.split(',')[1];
            if (b64Part) {
              const raw = atob(b64Part);
              const arr = new Uint8Array(raw.length);
              for (let i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);
              const stripped = stripImageMetadata(arr.buffer);
              if (stripped.byteLength < arr.buffer.byteLength) {
                const strippedArr = new Uint8Array(stripped);
                const b64 = btoa(String.fromCharCode.apply(null, strippedArr));
                const prefix = mediaData.split(',')[0];
                mediaData = prefix + ',' + b64;
                console.log('[Wire] EXIF stripped: ' + arr.length + 'B ‚Üí ' + strippedArr.length + 'B');
              }
            }
          } catch (e) {
            console.warn('[Wire] EXIF strip failed:', e.message);
          }
        }

        // Create media envelope
        const mediaEnvelope = JSON.stringify({
          type: pendingMedia.type,
          content: mediaData,
          name: pendingMedia.name,
          size: pendingMedia.size,
          mime: pendingMedia.mime,
          timestamp: Date.now()
        });
        
        if (!await ensureEncryptionInitialized()) {
          updateOptimisticMessage(tempId, 'failed');
          alert('Encryption not initialized. Please refresh the page and try again.');
          console.error('SECURITY: Attempted to send media without encryption keys');
          return;
        }
        
        // E2E encrypt the media for recipient
        const encryptedForRecipient = await encryptForRecipient(mediaEnvelope, currentRecipientId);
        // Also encrypt for self
        const wallet = WalletAuth.getWallet();
        const encryptedForSender = await encryptForEncryptionPublicKey(mediaEnvelope, myEncryptionKeyPair.publicKey);
        
        // Get disappearing message settings
        const disappearSettings = getDisappearSettings();
        
        const response = await fetch('/api/messages/send', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({
            recipientId: currentRecipientId,
            encryptedContent: encryptedForRecipient,
            encryptedForSender: encryptedForSender,
            itemId: currentItemId || undefined,
            conversationId: currentConversationId || undefined,
            mediaType: pendingMedia.type,
            selfDestructAfter: disappearSettings.selfDestructAfter,
            expiresAfterView: disappearSettings.expiresAfterView
          })
        });
        
        const data = await response.json();
        if (data.success) {
          updateOptimisticMessage(tempId, 'sent');
          clearMediaPreview();
          if (data.conversationId) {
            currentConversationId = data.conversationId;
          }
          loadConversations();
        } else {
          updateOptimisticMessage(tempId, 'failed');
          alert(data.error || 'Failed to send media');
        }
      } catch (error) {
        console.error('Send media error:', error);
        updateOptimisticMessage(tempId, 'failed');
        alert('Failed to send media');
      } finally {
        sendBtn.disabled = false;
      }
    }

    // Override sendMessage to handle pending media
    const originalSendMessage = sendMessage;
    sendMessage = async function() {
      if (pendingMedia) {
        await sendMediaMessage();
      } else {
        await originalSendMessage();
      }
    };

    // ============================================================
    // PUSH-TO-TALK (WALKIE-TALKIE) FUNCTIONS
    // ============================================================
    
    let pttRecorder = null;
    let pttChunks = [];
    let pttStream = null;
    let pttActive = false;
    
    function initPushToTalk() {
      const pttBtn = document.getElementById('pttBtn');
      if (!pttBtn) return;
      
      // Mouse events (desktop)
      pttBtn.addEventListener('mousedown', startPTT);
      pttBtn.addEventListener('mouseup', stopPTT);
      pttBtn.addEventListener('mouseleave', stopPTT);
      
      // Touch events (mobile)
      pttBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        startPTT();
      });
      pttBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        stopPTT();
      });
      pttBtn.addEventListener('touchcancel', stopPTT);
    }
    
    async function startPTT() {
      if (pttActive || !currentRecipientId) return;
      
      try {
        pttStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        const mimeType = getSupportedAudioMimeType();
        const options = mimeType ? { mimeType } : {};
        
        pttRecorder = new MediaRecorder(pttStream, options);
        pttChunks = [];
        
        pttRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) pttChunks.push(e.data);
        };
        
        pttRecorder.onstop = async () => {
          // Clean up stream
          if (pttStream) {
            pttStream.getTracks().forEach(t => t.stop());
            pttStream = null;
          }
          
          // Only send if we have audio data
          if (pttChunks.length > 0) {
            await sendPTTAudio();
          }
        };
        
        pttRecorder.start();
        pttActive = true;
        
        // Show recording UI
        document.getElementById('pttBtn').classList.add('recording');
        document.getElementById('pttRecording').classList.add('active');
        
      } catch (e) {
        console.error('PTT start error:', e);
        alert('Could not access microphone');
      }
    }
    
    function stopPTT() {
      if (!pttActive || !pttRecorder) return;
      
      pttActive = false;
      document.getElementById('pttBtn').classList.remove('recording');
      document.getElementById('pttRecording').classList.remove('active');
      
      if (pttRecorder.state === 'recording') {
        pttRecorder.stop();
      }
    }
    
    async function sendPTTAudio() {
      if (pttChunks.length === 0) return;
      
      const actualMimeType = pttRecorder?.mimeType || 'audio/webm';
      const blob = new Blob(pttChunks, { type: actualMimeType });
      
      // Convert to base64
      const data = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
      
      // Set as pending media and send
      pendingMedia = {
        type: 'audio',
        data: data,
        name: 'Voice message',
        size: blob.size,
        isPTT: true // Mark as push-to-talk for auto-play
      };
      
      pttChunks = [];
      pttRecorder = null;
      
      await sendMediaMessage();
    }
    
    // Initialize PTT when DOM is ready
    document.addEventListener('DOMContentLoaded', initPushToTalk);

    // Fullscreen media viewer
    function openFullscreen(srcOrId, type) {
      const container = document.getElementById('fullscreenContent');
      if (type === 'image') {
        container.innerHTML = `<img src="${srcOrId}" alt="Fullscreen">`;
      } else if (type === 'video') {
        // srcOrId might be a video element ID - get the blob URL from our map
        const blobUrl = videoBlobUrls.get(srcOrId) || srcOrId;
        container.innerHTML = `<video src="${blobUrl}" controls autoplay playsinline webkit-playsinline></video>`;
      }
      document.getElementById('mediaFullscreen').classList.add('active');
    }

    function closeFullscreen() {
      document.getElementById('mediaFullscreen').classList.remove('active');
      document.getElementById('fullscreenContent').innerHTML = '';
    }

    // Update renderMessages to show media with async E2E decryption
    const originalRenderMessages = renderMessages;
    renderMessages = async function(messages) {
      const container = document.getElementById('chatMessages');
      const wallet = WalletAuth.getWallet();
      
      if (messages.length === 0) {
        container.innerHTML = `
          <div style="text-align:center;color:#888;padding:2rem;">
            Start the conversation by sending a message
          </div>
        `;
        return;
      }

      // Process messages with async decryption
      const processedMessages = await Promise.all(messages.map(async (msg) => {
        const isSent = msg.senderId === wallet.publicKey;
        const timeStr = new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const expiresIn = formatTimeUntil(msg.expiresAt);
        
        // Backend already returns correct encryptedContent for current user
        const contentToDecrypt = msg.encryptedContent;
        
        let content = '';
        try {
          // Async decrypt the message
          const decrypted = await decryptMessageAsync(contentToDecrypt || msg.encryptedContent, msg.senderId);
          const parsed = JSON.parse(decrypted);
          
          if (parsed.type === 'image') {
            content = `
              <div class="message-media">
                <img src="${parsed.content}" alt="Photo" onclick="openFullscreen(this.src, 'image')">
              </div>
            `;
          } else if (parsed.type === 'video') {
            // Convert base64 to Blob URL for mobile compatibility
            const videoId = 'vid_' + msg.timestamp + '_' + Math.random().toString(36).substr(2, 9);
            const blobData = base64ToBlobUrl(parsed.content);
            videoBlobUrls.set(videoId, blobData.url);
            videoBase64Data.set(videoId, parsed.content); // Keep base64 as fallback for iOS
            
            // iOS needs special handling - use source element without fragment
            if (isIOS) {
              content = `
                <div class="message-media">
                  <video id="${videoId}" controls playsinline webkit-playsinline preload="auto"
                         onclick="openFullscreen('${videoId}', 'video')">
                    <source src="${blobData.url}" type="${blobData.mime}">
                    Your browser does not support video.
                  </video>
                </div>
              `;
            } else {
              content = `
                <div class="message-media">
                  <video id="${videoId}" src="${blobData.url}#t=0.1" controls playsinline webkit-playsinline preload="metadata"
                         onclick="openFullscreen('${videoId}', 'video')"></video>
                </div>
              `;
            }
          } else if (parsed.type === 'audio') {
            content = `
              <div class="message-media">
                <audio src="${parsed.content}" controls></audio>
              </div>
            `;
          } else if (parsed.type === 'file') {
            const fileName = escapeHtml(parsed.name || 'File');
            const fileSize = parsed.size ? formatFileSize(parsed.size) : '';
            content = `
              <div class="message-media" style="padding: 0.5rem;">
                <div style="display:flex;align-items:center;gap:0.5rem;">
                  <div style="font-size:1.3rem;">üìé</div>
                  <div style="flex:1;min-width:0;">
                    <div style="font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${fileName}</div>
                    <div style="font-size:0.75rem;color:#888;">${escapeHtml(fileSize)}</div>
                  </div>
                </div>
                <div style="margin-top:0.4rem;">
                  <a href="${parsed.content}" download="${fileName}" style="color:#8b5cf6;text-decoration:underline;">Download</a>
                </div>
              </div>
            `;
          } else {
            content = `<div class="message-text">${escapeHtml(parsed.content || decrypted)}</div>`;
          }
        } catch (e) {
          // Fallback for legacy or failed decryption
          try {
            const fallback = await decryptMessageAsync(msg.encryptedContent, msg.senderId);
            content = `<div class="message-text">${escapeHtml(fallback)}</div>`;
          } catch (e2) {
            content = `<div class="message-text" style="color:#ff6b6b;">[Could not decrypt]</div>`;
          }
        }
        
        return `
          <div class="message-bubble ${isSent ? 'sent' : 'received'}" data-message-id="${msg.id || msg.messageId || ''}">
            ${content}
            <div class="message-meta">
              ${timeStr}
              <span class="message-expires">‚Ä¢ expires ${expiresIn}</span>
            </div>
          </div>
        `;
      }));

      container.innerHTML = processedMessages.join('');
      container.scrollTop = container.scrollHeight;
    };

    // ============================================================
    // ENCRYPTION INFO & PREMIUM ACTIONS
    // ============================================================

    let serviceBalance = 0;
    let selectedMessageId = null;
    let selectedMessageText = '';

    // Pricing constants (sats)
    const PRICING = {
      message_delete: 10,
      message_edit: 10,
      profile_update: 10,
      group_create: 10,
    };

    // Fetch service balance
    async function fetchServiceBalance() {
      try {
        const accountId = getServiceAccountId();
        if (!accountId) return 0;

        const res = await fetch(`/api/accounts/${accountId}/service-balance`, {
          headers: WalletAuth.getAuthHeaders(),
        });
        if (res.ok) {
          const data = await res.json();
          if (data.success) {
            serviceBalance = data.serviceBalanceSats || 0;
            // Update the service balance indicator in header
            const balanceEl = document.getElementById('msgServiceBalance');
            if (balanceEl) balanceEl.textContent = serviceBalance.toLocaleString();
            return serviceBalance;
          }
        }
      } catch (e) {
        console.error('Failed to fetch service balance:', e);
      }
      return 0;
    }
    
    // Fetch balance on page load
    fetchServiceBalance();

    // ============================================================
    // SAFETY NUMBERS: Key verification (like Signal)
    // ============================================================
    async function generateSafetyNumber(myEncPubKeyBytes, theirEncPubKeyBytes) {
      // Sort keys deterministically so both sides compute the same number
      const myHex = bytesToHex(myEncPubKeyBytes);
      const theirHex = bytesToHex(theirEncPubKeyBytes);
      const keys = [myEncPubKeyBytes, theirEncPubKeyBytes];
      if (myHex > theirHex) keys.reverse();
      
      // Concatenate sorted keys
      const combined = new Uint8Array(keys[0].length + keys[1].length);
      combined.set(keys[0], 0);
      combined.set(keys[1], keys[0].length);
      
      // SHA-256 hash
      const hash = await crypto.subtle.digest('SHA-256', combined);
      const hashBytes = new Uint8Array(hash);
      
      // Format as 12 groups of 5 digits (60 digits total, like Signal)
      let result = '';
      for (let i = 0; i < 30; i += 2.5) {
        const idx = Math.floor(i);
        const val = ((hashBytes[idx] << 8) | (hashBytes[idx + 1] || 0)) % 100000;
        result += val.toString().padStart(5, '0') + ' ';
        if ((result.trim().split(' ').length) % 4 === 0) result += '\n';
      }
      return result.trim();
    }

    async function showSafetyNumber() {
      if (!currentRecipientId || !myEncryptionKeyPair) {
        alert('Encryption not initialized or no contact selected.');
        return;
      }
      
      const modal = document.getElementById('safetyNumberModal');
      const display = document.getElementById('safetyNumberDisplay');
      const qrContainer = document.getElementById('safetyNumberQR');
      const statusEl = document.getElementById('verifiedStatus');
      
      display.textContent = 'Computing...';
      qrContainer.innerHTML = '';
      modal.style.display = 'flex';
      
      try {
        // Get recipient's encryption public key
        const recipientEncPubKeyBytes = await getRecipientEncryptionPublicKeyBytes(currentRecipientId);
        if (!recipientEncPubKeyBytes) {
          display.textContent = 'Could not load contact key';
          return;
        }
        
        const safetyNumber = await generateSafetyNumber(myEncryptionKeyPair.publicKey, recipientEncPubKeyBytes);
        display.textContent = safetyNumber;
        
        // Generate QR code of safety number ‚Äî large, high-contrast, sharp
        try {
          const qrWrapper = document.createElement('div');
          qrWrapper.style.cssText = 'background:#fff; padding:12px; border-radius:10px; display:inline-block;';
          qrContainer.appendChild(qrWrapper);
          new QRCode(qrWrapper, {
            text: safetyNumber.replace(/\s+/g, ''),
            width: 256,
            height: 256,
            colorDark: '#000000',
            colorLight: '#ffffff',
            correctLevel: QRCode.CorrectLevel.H
          });
          // QRCode lib creates both canvas + img; hide canvas, keep only the img
          setTimeout(() => {
            const canvas = qrWrapper.querySelector('canvas');
            if (canvas) canvas.style.display = 'none';
            const img = qrWrapper.querySelector('img');
            if (img) img.style.cssText = 'image-rendering:pixelated; width:256px; height:256px; display:block;';
          }, 50);
        } catch {}
        
        // Check verified status
        const verifiedContacts = JSON.parse(localStorage.getItem('autho_verified_contacts') || '{}');
        const storedHash = verifiedContacts[currentRecipientId];
        const currentHash = safetyNumber.replace(/\s+/g, '');
        
        if (storedHash === currentHash) {
          statusEl.innerHTML = '<span style="color:#4caf50;">&#10003; Verified</span> ‚Äî Key has not changed since verification';
        } else if (storedHash) {
          statusEl.innerHTML = '<span style="color:#ff4444;">&#9888; Key changed!</span> ‚Äî Re-verify this contact';
        } else {
          statusEl.textContent = 'Not yet verified';
        }
      } catch (e) {
        console.error('Safety number error:', e);
        display.textContent = 'Error generating safety number';
      }
    }

    let safetyQrStream = null;
    let safetyQrAnimFrame = null;
    let safetyQrScanning = false;

    function closeSafetyNumberModal() {
      stopSafetyQrScanner();
      document.getElementById('safetyNumberModal').style.display = 'none';
    }

    async function toggleSafetyQrScanner() {
      if (safetyQrScanning) {
        stopSafetyQrScanner();
        return;
      }
      
      const container = document.getElementById('safetyQrScannerContainer');
      const video = document.getElementById('safetyQrVideo');
      const statusEl = document.getElementById('safetyQrScanStatus');
      const btn = document.getElementById('scanQrBtn');
      
      try {
        safetyQrStream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'environment' } 
        });
        video.srcObject = safetyQrStream;
        await video.play();
        
        container.style.display = 'block';
        btn.textContent = '‚èπ Stop Scan';
        btn.style.background = '#e53935';
        statusEl.textContent = 'Point camera at contact\'s QR code...';
        statusEl.style.color = '#888';
        safetyQrScanning = true;
        
        // Start scanning frames with jsQR
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        function scanFrame() {
          if (!safetyQrScanning || video.readyState !== video.HAVE_ENOUGH_DATA) {
            safetyQrAnimFrame = requestAnimationFrame(scanFrame);
            return;
          }
          
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          
          const code = jsQR(imageData.data, imageData.width, imageData.height, {
            inversionAttempts: 'dontInvert',
          });
          
          if (code && code.data) {
            // QR decoded ‚Äî compare with our safety number
            handleScannedSafetyQR(code.data, statusEl);
          } else {
            safetyQrAnimFrame = requestAnimationFrame(scanFrame);
          }
        }
        
        safetyQrAnimFrame = requestAnimationFrame(scanFrame);
      } catch (e) {
        console.error('QR scanner error:', e);
        alert('Could not access camera: ' + (e.message || e));
      }
    }

    function stopSafetyQrScanner() {
      safetyQrScanning = false;
      if (safetyQrAnimFrame) {
        cancelAnimationFrame(safetyQrAnimFrame);
        safetyQrAnimFrame = null;
      }
      if (safetyQrStream) {
        safetyQrStream.getTracks().forEach(t => t.stop());
        safetyQrStream = null;
      }
      const video = document.getElementById('safetyQrVideo');
      if (video) video.srcObject = null;
      
      const container = document.getElementById('safetyQrScannerContainer');
      if (container) container.style.display = 'none';
      
      const btn = document.getElementById('scanQrBtn');
      if (btn) { btn.textContent = 'üì∑ Scan QR'; btn.style.background = '#1a73e8'; }
    }

    async function handleScannedSafetyQR(scannedData, statusEl) {
      // Get our own safety number (digits only)
      const displayEl = document.getElementById('safetyNumberDisplay');
      const ourSafetyNumber = (displayEl?.textContent || '').replace(/\s+/g, '');
      const scannedClean = scannedData.replace(/\s+/g, '');
      
      if (!ourSafetyNumber || ourSafetyNumber.length < 20) {
        statusEl.textContent = 'Safety number not loaded yet. Try again.';
        statusEl.style.color = '#ff9800';
        setTimeout(() => { if (safetyQrScanning) safetyQrAnimFrame = requestAnimationFrame(arguments.callee); }, 1000);
        return;
      }
      
      if (scannedClean === ourSafetyNumber) {
        // Match ‚Äî auto-verify!
        statusEl.innerHTML = '<span style="color:#4caf50; font-weight:bold;">‚úÖ QR matches! Conversation verified.</span>';
        stopSafetyQrScanner();
        
        // Auto-mark as verified
        await markContactVerified();
        
        // Show success feedback
        const verifiedEl = document.getElementById('verifiedStatus');
        if (verifiedEl) {
          verifiedEl.innerHTML = '<span style="color:#4caf50; font-size:14px;">&#10003; Verified via QR scan</span> ‚Äî Keys confirmed in person';
        }
      } else {
        // Mismatch ‚Äî warning!
        statusEl.innerHTML = '<span style="color:#ff4444; font-weight:bold;">‚ö†Ô∏è QR does NOT match! Keys may be compromised.</span>';
        stopSafetyQrScanner();
      }
    }

    async function markContactVerified() {
      if (!currentRecipientId || !myEncryptionKeyPair) return;
      
      try {
        const recipientEncPubKeyBytes = await getRecipientEncryptionPublicKeyBytes(currentRecipientId);
        const safetyNumber = await generateSafetyNumber(myEncryptionKeyPair.publicKey, recipientEncPubKeyBytes);
        const hash = safetyNumber.replace(/\s+/g, '');
        
        const verifiedContacts = JSON.parse(localStorage.getItem('autho_verified_contacts') || '{}');
        verifiedContacts[currentRecipientId] = hash;
        localStorage.setItem('autho_verified_contacts', JSON.stringify(verifiedContacts));
        
        document.getElementById('verifiedStatus').innerHTML = 
          '<span style="color:#4caf50;">&#10003; Verified</span> ‚Äî Key has not changed since verification';
        
        // Update verify button to show verified state
        const btn = document.getElementById('verifyContactBtn');
        if (btn) { btn.style.borderColor = '#4caf50'; btn.style.color = '#4caf50'; btn.textContent = '‚úÖ Verified'; }
      } catch (e) {
        console.error('Mark verified error:', e);
      }
    }

    // ============================================================
    // KEY TRANSPARENCY: Publish key hash to ledger for audit
    // ============================================================
    async function publishKeyTransparencyHash() {
      if (!myEncryptionKeyPair) return;
      
      try {
        const wallet = WalletAuth.getWallet();
        if (!wallet) return;
        
        // Hash the encryption public key
        const pubKeyHash = await crypto.subtle.digest('SHA-256', myEncryptionKeyPair.publicKey);
        const hashHex = Array.from(new Uint8Array(pubKeyHash)).map(b => b.toString(16).padStart(2, '0')).join('');
        
        // Publish to transparency log
        await fetch('/api/messages/key-transparency', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({
            publicKeyHash: hashHex,
            algorithm: 'curve25519',
            timestamp: Date.now()
          })
        });
      } catch (e) {
        // Non-critical: don't block messaging if transparency log fails
        console.warn('Key transparency publish failed:', e.message);
      }
    }

    // Show encryption info modal
    function showEncryptionInfo() {
      document.getElementById('encryptionModal').classList.add('active');
    }

    function closeEncryptionModal() {
      document.getElementById('encryptionModal').classList.remove('active');
    }

    // Insufficient balance modal
    function showInsufficientBalanceModal(required) {
      document.getElementById('currentBalanceDisplay').textContent = serviceBalance.toLocaleString();
      document.getElementById('requiredAmountDisplay').textContent = required.toLocaleString();
      document.getElementById('insufficientBalanceModal').classList.add('active');
    }

    function closeInsufficientBalanceModal() {
      document.getElementById('insufficientBalanceModal').classList.remove('active');
    }

    // Message context menu
    function showMessageContextMenu(event, messageId, messageText, isSent) {
      event.preventDefault();
      event.stopPropagation();
      
      selectedMessageId = messageId;
      selectedMessageText = messageText;
      contextMenuMessageId = messageId;
      
      const menu = document.getElementById('messageContextMenu');
      // Show/hide edit+delete based on ownership (reactions always visible)
      const editItem = menu.querySelector('.context-menu-item:nth-child(3)'); // Edit
      const deleteItem = menu.querySelector('.context-menu-item.delete');     // Delete
      if (editItem) editItem.style.display = isSent ? '' : 'none';
      if (deleteItem) deleteItem.style.display = isSent ? '' : 'none';

      const x = Math.min(event.clientX, window.innerWidth - 180);
      const y = Math.min(event.clientY, window.innerHeight - 150);
      
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      menu.classList.add('active');
    }

    function hideMessageContextMenu() {
      document.getElementById('messageContextMenu').classList.remove('active');
      selectedMessageId = null;
      selectedMessageText = '';
    }

    // Close context menu when clicking elsewhere
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.message-context-menu')) {
        hideMessageContextMenu();
      }
    });

    // Copy message text
    function copyMessageText() {
      if (selectedMessageText) {
        navigator.clipboard.writeText(selectedMessageText).then(() => {
          hideMessageContextMenu();
        });
      }
    }

    // Delete message with auto-deduct
    async function deleteMessageWithPayment() {
      console.log('Delete requested for messageId:', selectedMessageId);
      
      if (!selectedMessageId) {
        alert('No message selected. Please tap on a message first.');
        return;
      }
      
      const required = PRICING.message_delete;
      await fetchServiceBalance();
      
      if (serviceBalance < required) {
        hideMessageContextMenu();
        showInsufficientBalanceModal(required);
        return;
      }
      
      // Confirm deletion
      if (!confirm(`Delete this message? This will deduct ${required} sats from your service balance.`)) {
        hideMessageContextMenu();
        return;
      }
      
      try {
        const accountId = getServiceAccountId();
        console.log('Deleting message:', { messageId: selectedMessageId, accountId });
        
        const res = await fetch('/api/service/premium/message-delete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...WalletAuth.getAuthHeaders() },
          body: JSON.stringify({
            accountId,
            messageId: selectedMessageId,
          }),
        });
        
        const data = await res.json();
        console.log('Delete response:', data);
        
        if (data.success) {
          // Remove message from UI
          const msgElements = document.querySelectorAll(`[data-message-id="${selectedMessageId}"]`);
          msgElements.forEach(el => el.remove());
          
          serviceBalance = data.newBalance || (serviceBalance - required);
          const balEl = document.getElementById('msgServiceBalance');
          if (balEl) balEl.textContent = serviceBalance.toLocaleString();
          hideMessageContextMenu();
        } else {
          alert(data.error || 'Failed to delete message');
        }
      } catch (e) {
        console.error('Delete message error:', e);
        alert('Error deleting message: ' + e.message);
      }
      
      hideMessageContextMenu();
    }

    // Edit message with auto-deduct
    async function editMessage() {
      if (!selectedMessageId) return;
      
      const required = PRICING.message_edit;
      await fetchServiceBalance();
      
      if (serviceBalance < required) {
        hideMessageContextMenu();
        showInsufficientBalanceModal(required);
        return;
      }
      
      const newText = prompt('Edit message:', selectedMessageText);
      if (!newText || newText === selectedMessageText) {
        hideMessageContextMenu();
        return;
      }
      
      try {
        const accountId = getServiceAccountId();
        
        const res = await fetch('/api/service/premium/message-edit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...WalletAuth.getAuthHeaders() },
          body: JSON.stringify({
            accountId,
            messageId: selectedMessageId,
            newContent: newText,
          }),
        });
        
        const data = await res.json();
        
        if (data.success) {
          // Update message in UI
          const msgElements = document.querySelectorAll(`[data-message-id="${selectedMessageId}"] .message-text`);
          msgElements.forEach(el => {
            el.textContent = newText;
            el.innerHTML += ' <span style="font-size:0.7em;color:#888;">(edited)</span>';
          });
          
          serviceBalance = data.newBalance || (serviceBalance - required);
          const balEl2 = document.getElementById('msgServiceBalance');
          if (balEl2) balEl2.textContent = serviceBalance.toLocaleString();
        } else {
          alert(data.error || 'Failed to edit message');
        }
      } catch (e) {
        console.error('Edit message error:', e);
        alert('Error editing message: ' + e.message);
      }
      
      hideMessageContextMenu();
    }

    // Add context menu to message bubbles
    function addContextMenuToMessages() {
      document.querySelectorAll('.message-bubble.sent').forEach(bubble => {
        if (bubble.dataset.contextMenuAdded) return;
        bubble.dataset.contextMenuAdded = 'true';

        function eventLikeFromTouch(t) {
          return {
            clientX: t.clientX,
            clientY: t.clientY,
            preventDefault() {},
            stopPropagation() {},
          };
        }
        
        bubble.addEventListener('contextmenu', (e) => {
          const messageId = bubble.dataset.messageId || bubble.closest('[data-message-id]')?.dataset.messageId;
          const textEl = bubble.querySelector('.message-text');
          const text = textEl ? textEl.textContent : '';
          showMessageContextMenu(e, messageId, text, true);
        });

        bubble.addEventListener('click', (e) => {
          if (e.target.closest('.message-media')) return;
          const messageId = bubble.dataset.messageId || bubble.closest('[data-message-id]')?.dataset.messageId;
          const textEl = bubble.querySelector('.message-text');
          const text = textEl ? textEl.textContent : '';
          showMessageContextMenu(e, messageId, text, true);
        });
        
        // Long-press for mobile
        let pressTimer;
        bubble.addEventListener('touchstart', (e) => {
          pressTimer = setTimeout(() => {
            const messageId = bubble.dataset.messageId || bubble.closest('[data-message-id]')?.dataset.messageId;
            const textEl = bubble.querySelector('.message-text');
            const text = textEl ? textEl.textContent : '';
            const touch = e.touches && e.touches[0];
            if (touch) showMessageContextMenu(eventLikeFromTouch(touch), messageId, text, true);
          }, 500);
        });
        
        bubble.addEventListener('touchend', () => clearTimeout(pressTimer));
        bubble.addEventListener('touchmove', () => clearTimeout(pressTimer));
      });
    }

    // Re-add context menus after messages render
    const originalRenderMessagesWithContext = renderMessages;
    renderMessages = async function(messages) {
      await originalRenderMessagesWithContext(messages);
      setTimeout(addContextMenuToMessages, 100);
    };

    // Initial balance fetch
    fetchServiceBalance();

    // ============================================================
    // MESSAGE SEARCH
    // ============================================================
    let searchDebounce = null;

    function handleMessageSearch(query) {
      clearTimeout(searchDebounce);
      const resultsEl = document.getElementById('messageSearchResults');
      if (!query || query.length < 2) {
        resultsEl.style.display = 'none';
        resultsEl.innerHTML = '';
        return;
      }
      searchDebounce = setTimeout(async function() {
        await performMessageSearch(query);
      }, 300);
    }

    async function performMessageSearch(query) {
      const resultsEl = document.getElementById('messageSearchResults');
      resultsEl.style.display = 'block';
      resultsEl.innerHTML = '<div style="padding:12px;color:#888;font-size:13px;">Searching...</div>';

      try {
        const wallet = WalletAuth.getWallet();
        if (!wallet) return;

        // Fetch all conversations
        const convResp = await fetch('/api/messages/conversations', {
          headers: WalletAuth.getAuthHeaders()
        });
        const convData = await convResp.json();
        if (!convData.success || !convData.conversations) {
          resultsEl.innerHTML = '<div style="padding:12px;color:#888;font-size:13px;">No results</div>';
          return;
        }

        const results = [];
        const lowerQuery = query.toLowerCase();

        // Search through each conversation's recent messages
        for (const conv of convData.conversations.slice(0, 20)) {
          try {
            const msgResp = await fetch('/api/messages/conversation/' + conv.conversationId + '?limit=50', {
              headers: WalletAuth.getAuthHeaders()
            });
            const msgData = await msgResp.json();
            if (!msgData.success || !msgData.messages) continue;

            for (const msg of msgData.messages) {
              try {
                // Try to decrypt the message to search its content
                let plaintext = '';
                const isSelf = msg.senderId === wallet.publicKey;
                const encrypted = isSelf ? msg.encryptedForSender : msg.encryptedContent;
                if (!encrypted) continue;
                plaintext = await decryptFromSender(encrypted, msg.senderId);
                if (!plaintext) continue;

                // Parse the decrypted envelope
                let envelope;
                try { envelope = JSON.parse(plaintext); } catch { continue; }
                const content = envelope.content || envelope.text || '';
                if (content.toLowerCase().includes(lowerQuery)) {
                  const other = conv.participants?.find(p => p.accountId !== wallet.publicKey);
                  results.push({
                    conversationId: conv.conversationId,
                    recipientId: other?.accountId,
                    displayName: other?.displayName || 'Unknown',
                    content: content,
                    timestamp: msg.timestamp,
                    messageId: msg.eventId
                  });
                }
                if (results.length >= 20) break;
              } catch {}
            }
          } catch {}
          if (results.length >= 20) break;
        }

        if (results.length === 0) {
          resultsEl.innerHTML = '<div style="padding:12px;color:#888;font-size:13px;">No messages found</div>';
          return;
        }

        resultsEl.innerHTML = results.map(function(r) {
          const preview = r.content.length > 60 ? r.content.substring(0, 60) + '...' : r.content;
          const time = new Date(r.timestamp).toLocaleDateString();
          // Highlight match
          const highlighted = escapeHtml(preview).replace(new RegExp('(' + escapeHtml(query).replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ')', 'gi'), '<mark style="background:#f7931a;color:#000;border-radius:2px;padding:0 2px;">$1</mark>');
          return '<div onclick="openConversation(\'' + r.conversationId + '\', \'' + (r.recipientId || '') + '\')" style="padding:10px 14px;border-bottom:1px solid #222;cursor:pointer;">' +
            '<div style="display:flex;justify-content:space-between;margin-bottom:4px;">' +
            '<span style="color:#fff;font-size:13px;font-weight:600;">' + escapeHtml(r.displayName) + '</span>' +
            '<span style="color:#666;font-size:11px;">' + time + '</span></div>' +
            '<div style="color:#aaa;font-size:12px;line-height:1.4;">' + highlighted + '</div></div>';
        }).join('');
      } catch (e) {
        console.warn('[Search] Error:', e);
        resultsEl.innerHTML = '<div style="padding:12px;color:#888;font-size:13px;">Search failed</div>';
      }
    }

    // ============================================================
    // MESSAGE REACTIONS (emoji)
    // ============================================================
    const messageReactions = new Map(); // messageId -> Map<emoji, Set<userId>>
    let contextMenuMessageId = null;

    function reactToMessage(emoji) {
      if (!contextMenuMessageId || !currentConversationId) return;
      // Close context menu
      const menu = document.getElementById('messageContextMenu');
      if (menu) menu.style.display = 'none';

      // Send reaction via WebSocket
      if (messagingWs && messagingWsConnected) {
        messagingWs.send(JSON.stringify({
          type: 'reaction',
          conversationId: currentConversationId,
          messageId: contextMenuMessageId,
          emoji: emoji,
          action: 'add'
        }));
      }

      // Apply locally immediately (optimistic)
      applyReaction(contextMenuMessageId, emoji, 'self', 'add');
    }

    function applyReaction(messageId, emoji, fromId, action) {
      if (!messageReactions.has(messageId)) messageReactions.set(messageId, new Map());
      const msgReactions = messageReactions.get(messageId);
      if (!msgReactions.has(emoji)) msgReactions.set(emoji, new Set());

      if (action === 'add') {
        msgReactions.get(emoji).add(fromId);
      } else {
        msgReactions.get(emoji).delete(fromId);
        if (msgReactions.get(emoji).size === 0) msgReactions.delete(emoji);
      }

      // Render reactions below the message bubble
      const bubble = document.querySelector('[data-message-id="' + messageId + '"]');
      if (!bubble) return;
      let reactionsEl = bubble.querySelector('.message-reactions');
      if (!reactionsEl) {
        reactionsEl = document.createElement('div');
        reactionsEl.className = 'message-reactions';
        reactionsEl.style.cssText = 'display:flex;gap:4px;margin-top:4px;flex-wrap:wrap;';
        bubble.appendChild(reactionsEl);
      }
      reactionsEl.innerHTML = '';
      for (const [em, users] of msgReactions.entries()) {
        if (users.size === 0) continue;
        const badge = document.createElement('span');
        badge.style.cssText = 'background:rgba(255,255,255,0.1);border-radius:12px;padding:2px 6px;font-size:12px;cursor:pointer;';
        badge.textContent = em + (users.size > 1 ? ' ' + users.size : '');
        badge.title = users.size + ' reaction(s)';
        reactionsEl.appendChild(badge);
      }
    }

    // ============================================================
    // TYPING INDICATORS + READ RECEIPTS
    // ============================================================
    let typingTimeout = null;
    let isTypingSent = false;

    // Send typing indicator when user types
    const msgInput = document.getElementById('messageInput');
    if (msgInput) {
      msgInput.addEventListener('input', function() {
        if (!messagingWs || !messagingWsConnected || !currentConversationId) return;
        if (!isTypingSent) {
          isTypingSent = true;
          messagingWs.send(JSON.stringify({
            type: 'typing',
            conversationId: currentConversationId,
            isTyping: true
          }));
        }
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(function() {
          isTypingSent = false;
          if (messagingWs && messagingWsConnected && currentConversationId) {
            messagingWs.send(JSON.stringify({
              type: 'typing',
              conversationId: currentConversationId,
              isTyping: false
            }));
          }
        }, 2000);
      });
    }

    // Send read receipt when messages are viewed
    function sendReadReceipt() {
      if (!messagingWs || !messagingWsConnected || !currentConversationId) return;
      messagingWs.send(JSON.stringify({
        type: 'read_receipt',
        conversationId: currentConversationId,
        lastReadTimestamp: Date.now()
      }));
    }

    // Hook into loadMessages to send read receipt after viewing
    const _originalLoadMessages = typeof loadMessages === 'function' ? loadMessages : null;
    if (_originalLoadMessages) {
      const _wrappedLoadMessages = loadMessages;
      loadMessages = async function() {
        const result = await _wrappedLoadMessages.apply(this, arguments);
        sendReadReceipt();
        return result;
      };
    }

    // ============================================================
    // ENCRYPTED VOICE / VIDEO CALLS (WebRTC + Autho signaling)
    // ============================================================

    // Send call signal as an encrypted message through the messaging WebSocket
    function sendCallSignal(signal) {
      if (!currentRecipientId && !AutohoCall.getPeerId()) {
        console.warn('[Call] No recipient to signal');
        return;
      }
      const peerId = currentRecipientId || AutohoCall.getPeerId();
      // Send via WebSocket as a lightweight call signal
      if (messagingWs && messagingWsConnected) {
        try {
          messagingWs.send(JSON.stringify({
            type: 'call_signal',
            targetId: peerId,
            signal: signal
          }));
        } catch (e) {
          console.error('[Call] Failed to send signal via WebSocket:', e.message);
        }
      } else {
        console.warn('[Call] Messaging WebSocket not connected ‚Äî signal dropped');
      }
    }

    function startVoiceCall() {
      if (!currentRecipientId) { alert('Open a conversation first'); return; }
      if (currentGroupId) { alert('Voice calls are 1-to-1 only'); return; }
      if (!messagingWs || !messagingWsConnected) {
        alert('Messaging connection not ready. Please wait a moment and try again.');
        return;
      }
      document.getElementById('callPeerName').textContent = document.getElementById('chatParticipantName').textContent || 'Unknown';
      document.getElementById('callStatusText').textContent = 'Calling...';
      document.getElementById('callDuration').textContent = '';
      showCallOverlay('calling', 'voice');
      AutohoCall.startCall(currentRecipientId, 'voice', sendCallSignal);
    }

    function startVideoCall() {
      if (!currentRecipientId) { alert('Open a conversation first'); return; }
      if (currentGroupId) { alert('Video calls are 1-to-1 only'); return; }
      if (!messagingWs || !messagingWsConnected) {
        alert('Messaging connection not ready. Please wait a moment and try again.');
        return;
      }
      document.getElementById('callPeerName').textContent = document.getElementById('chatParticipantName').textContent || 'Unknown';
      document.getElementById('callStatusText').textContent = 'Calling...';
      document.getElementById('callDuration').textContent = '';
      showCallOverlay('calling', 'video');
      AutohoCall.startCall(currentRecipientId, 'video', sendCallSignal);
    }

    async function acceptIncomingCall() {
      try {
        const result = await AutohoCall.acceptCall();
        if (!result) {
          console.error('[Call] acceptCall returned false');
        }
      } catch (e) {
        alert('Call failed: ' + e.name + ' - ' + e.message);
        console.error('[Call] acceptIncomingCall error:', e);
      }
    }

    function rejectIncomingCall() {
      AutohoCall.rejectCall();
      hideCallOverlay();
    }

    function endCurrentCall() {
      AutohoCall.endCall(sendCallSignal);
    }

    function toggleCallMute() {
      const muted = AutohoCall.toggleMute();
      document.getElementById('muteBtn').textContent = muted ? 'üîá' : 'üé§';
      document.getElementById('muteBtn').style.background = muted ? 'rgba(244,67,54,0.4)' : 'rgba(255,255,255,0.15)';
    }

    function toggleCallCamera() {
      const off = AutohoCall.toggleVideo();
      document.getElementById('camToggleBtn').textContent = off ? 'üö´' : 'üì∑';
      document.getElementById('camToggleBtn').style.background = off ? 'rgba(244,67,54,0.4)' : 'rgba(255,255,255,0.15)';
    }

    function showCallOverlay(state, type) {
      const overlay = document.getElementById('callOverlay');
      overlay.style.display = 'flex';
      const inBtns = document.getElementById('incomingCallBtns');
      const actBtns = document.getElementById('activeCallBtns');
      const camBtn = document.getElementById('camToggleBtn');

      if (state === 'ringing') {
        inBtns.style.display = 'flex';
        actBtns.style.display = 'none';
      } else {
        inBtns.style.display = 'none';
        actBtns.style.display = 'flex';
      }
      camBtn.style.display = (type === 'video') ? 'block' : 'none';
    }

    function hideCallOverlay() {
      document.getElementById('callOverlay').style.display = 'none';
      document.getElementById('remoteVideo').style.display = 'none';
      document.getElementById('localVideo').style.display = 'none';
      document.getElementById('remoteVideo').srcObject = null;
      document.getElementById('localVideo').srcObject = null;
      document.getElementById('remoteAudio').srcObject = null;
    }

    function resolveCallerName(callerId) {
      if (!callerId) return 'Unknown';
      const conv = conversations.find(c => (c.participantInfo || []).some(p => p.accountId === callerId));
      const participant = conv?.participantInfo?.find(p => p.accountId === callerId);
      return participant?.displayName || (callerId.substring(0, 12) + '...');
    }

    function setCallPeerName(name) {
      const el = document.getElementById('callPeerName');
      if (el) el.textContent = name || 'Unknown';
    }

    // Wire AutohoCall callbacks
    if (typeof AutohoCall !== 'undefined') {
      AutohoCall.onStateChange(function(state, type, peerId) {
        console.log('[Call] State:', state, type);
        const statusEl = document.getElementById('callStatusText');
        switch (state) {
          case 'calling':
            statusEl.textContent = 'Calling...';
            break;
          case 'ringing':
            statusEl.textContent = 'Incoming ' + (type === 'video' ? 'video' : 'voice') + ' call...';
            setCallPeerName(lastIncomingCallerName || resolveCallerName(peerId));
            showCallOverlay('ringing', type);
            // Play ringtone sound (simple oscillator)
            try {
              const actx = new AudioContext();
              const osc = actx.createOscillator();
              const gain = actx.createGain();
              osc.type = 'sine'; osc.frequency.value = 440;
              gain.gain.value = 0.15;
              osc.connect(gain); gain.connect(actx.destination);
              osc.start(); setTimeout(() => { osc.stop(); actx.close(); }, 2000);
            } catch {}
            break;
          case 'active':
            statusEl.textContent = 'Connected';
            showCallOverlay('active', type);
            // Attach local video
            const ls = AutohoCall.getLocalStream();
            if (ls && type === 'video') {
              const lv = document.getElementById('localVideo');
              lv.srcObject = ls;
              lv.style.display = 'block';
            }
            break;
          case 'ended':
            statusEl.textContent = 'Call ended';
            setTimeout(hideCallOverlay, 1500);
            break;
          case 'idle':
            hideCallOverlay();
            break;
        }
      });

      AutohoCall.onRemoteStream(function(stream) {
        const rv = document.getElementById('remoteVideo');
        const ra = document.getElementById('remoteAudio');
        rv.srcObject = stream;
        rv.style.display = 'block';
        ra.srcObject = stream;
        try { rv.play(); } catch {}
        try { ra.play(); } catch {}
      });

      AutohoCall.onDuration(function(dur) {
        document.getElementById('callDuration').textContent = dur;
      });
    }
  </script>
</body>
</html>
