<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Messages - Autho</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Georgia', 'Times New Roman', serif;
      background: linear-gradient(180deg, #0d0d0d 0%, #1a1a1a 50%, #0a0a0a 100%);
      color: #fff;
      min-height: 100vh;
    }
    .messages-container {
      max-width: 600px;
      margin: 0 auto;
      padding: 1rem;
    }

    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(212, 175, 55, 0.2);
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .back-to-dashboard {
      color: #d4af37;
      text-decoration: none;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.4rem 0.75rem;
      border: 1px solid rgba(212, 175, 55, 0.4);
      border-radius: 6px;
      background: rgba(212, 175, 55, 0.1);
      transition: all 0.2s;
    }

    .back-to-dashboard:hover {
      background: rgba(212, 175, 55, 0.2);
      border-color: #d4af37;
    }

    .page-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #d4af37;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .inbox-stats {
      font-size: 0.875rem;
      color: #888;
    }

    .conversation-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .conversation-card {
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .conversation-card:hover {
      border-color: #d4af37;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(212, 175, 55, 0.15);
    }

    .conversation-card.unread {
      border-left: 3px solid #d4af37;
    }

    .conversation-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.5rem;
    }

    .conversation-participant {
      font-weight: 600;
      color: #fff;
    }

    .conversation-time {
      font-size: 0.75rem;
      color: #888;
    }

    .conversation-preview {
      font-size: 0.875rem;
      color: #aaa;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .conversation-item-badge {
      display: inline-block;
      background: rgba(212, 175, 55, 0.2);
      color: #d4af37;
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      margin-top: 0.5rem;
    }

    .unread-badge {
      background: #d4af37;
      color: #000;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 0.2rem 0.5rem;
      border-radius: 10px;
      min-width: 1.2rem;
      text-align: center;
    }

    .empty-inbox {
      text-align: center;
      padding: 3rem 1rem;
      color: #888;
    }

    .empty-inbox-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .empty-inbox-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #aaa;
      margin-bottom: 0.5rem;
    }

    /* Chat View */
    .chat-view {
      display: none;
      flex-direction: column;
      height: calc(100vh - 120px);
    }

    .chat-view.active {
      display: flex;
    }

    .chat-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border-bottom: 2px solid rgba(212, 175, 55, 0.4);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .chat-back-btn {
      background: none;
      border: none;
      color: #d4af37;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem;
    }

    .chat-participant-name {
      font-weight: 600;
      color: #fff;
    }

    .chat-item-context {
      font-size: 0.75rem;
      color: #888;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .message-bubble {
      max-width: 80%;
      padding: 0.75rem 1rem;
      border-radius: 16px;
      position: relative;
    }

    .message-bubble.sent {
      align-self: flex-end;
      background: linear-gradient(135deg, #d4af37, #b8962e);
      color: #0d0d0d;
      border-bottom-right-radius: 4px;
      box-shadow: 0 2px 10px rgba(212, 175, 55, 0.3);
    }

    .message-bubble.received {
      align-self: flex-start;
      background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
      border: 1px solid rgba(212, 175, 55, 0.2);
      color: #fff;
      border-bottom-left-radius: 4px;
    }

    .message-text {
      word-wrap: break-word;
    }

    .message-meta {
      font-size: 0.65rem;
      opacity: 0.7;
      margin-top: 0.25rem;
      text-align: right;
    }

    .message-expires {
      font-size: 0.6rem;
      color: #888;
    }

    .media-buttons-row {
      display: flex;
      justify-content: center;
      gap: 0.75rem;
      padding: 0.5rem 0.75rem;
      background: linear-gradient(180deg, #1a1a1a, #0d0d0d);
      border-top: 1px solid rgba(212, 175, 55, 0.3);
    }

    .media-buttons-row .media-btn {
      flex: 1;
      max-width: 100px;
      padding: 0.4rem 0.6rem;
      background: rgba(50, 50, 50, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      color: #d4af37;
      font-size: 0.75rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
    }

    .media-buttons-row .media-btn:active {
      background: rgba(212, 175, 55, 0.2);
    }

    .chat-input-row {
      display: flex;
      padding: 0.5rem 0.75rem;
      background: linear-gradient(180deg, #1a1a1a, #0d0d0d);
    }

    .chat-actions-row {
      display: flex;
      gap: 0.75rem;
      padding: 0.5rem 0.75rem 0.75rem;
      background: linear-gradient(180deg, #0d0d0d, #0a0a0a);
      justify-content: center;
    }

    .chat-input {
      flex: 1;
      background: rgba(50, 50, 50, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 20px;
      padding: 0.75rem 1rem;
      color: #fff;
      font-size: 1rem;
    }

    .chat-input:focus {
      outline: none;
      border-color: #d4af37;
    }

    .chat-send-btn {
      background: linear-gradient(135deg, #d4af37, #b8962e);
      border: 1px solid #d4af37;
      border-radius: 12px;
      flex: 1;
      height: 44px;
      color: #0d0d0d;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
      transition: all 0.2s;
    }

    .chat-send-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
    }

    .chat-send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Push-to-Talk Button */
    .ptt-btn {
      background: linear-gradient(145deg, #2a5d2a, #1a3d1a);
      border: 2px solid #4CAF50;
      border-radius: 12px;
      flex: 1;
      height: 44px;
      color: #fff;
      cursor: pointer;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: all 0.2s;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }

    .ptt-btn:active, .ptt-btn.recording {
      background: linear-gradient(145deg, #4CAF50, #2E7D32);
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
    }

    .ptt-icon {
      font-size: 1.1rem;
      line-height: 1;
    }

    .ptt-text {
      font-size: 0.5rem;
      font-weight: bold;
      text-transform: uppercase;
    }

    .ptt-recording {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #4CAF50;
      border-radius: 20px;
      padding: 2rem 3rem;
      z-index: 1000;
      text-align: center;
    }

    .ptt-recording.active {
      display: block;
    }

    .ptt-pulse {
      width: 60px;
      height: 60px;
      background: #4CAF50;
      border-radius: 50%;
      margin: 0 auto 1rem;
      animation: ptt-pulse 1s ease-in-out infinite;
    }

    @keyframes ptt-pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
    }

    .ptt-status {
      color: #fff;
      font-size: 1rem;
      font-weight: 500;
    }

    /* Auto-play indicator for voice messages */
    .voice-message {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid rgba(76, 175, 80, 0.4);
      border-radius: 12px;
      padding: 0.5rem;
    }

    .voice-message.new {
      animation: voice-new 0.5s ease-out;
    }

    @keyframes voice-new {
      0% { transform: scale(0.9); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    .encryption-notice {
      text-align: center;
      font-size: 0.7rem;
      color: #666;
      padding: 0.5rem;
    }

    .encryption-notice span {
      color: #4CAF50;
    }

    .loading-spinner {
      display: flex;
      justify-content: center;
      padding: 2rem;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(212, 175, 55, 0.2);
      border-top-color: #d4af37;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .nav-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .nav-tab {
      flex: 1;
      padding: 0.75rem;
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      color: #ccc;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    .nav-tab.active {
      background: rgba(212, 175, 55, 0.2);
      border-color: #d4af37;
      color: #d4af37;
    }

    .contacts-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .contact-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      transition: all 0.2s;
    }

    .contact-card:hover {
      border-color: #d4af37;
      box-shadow: 0 4px 15px rgba(212, 175, 55, 0.15);
    }

    .contact-info {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .contact-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(212, 175, 55, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #d4af37;
      font-weight: 600;
    }

    .contact-name {
      font-weight: 500;
      color: #fff;
    }

    .contact-role {
      font-size: 0.75rem;
      color: #888;
    }

    .contact-actions button {
      background: none;
      border: 1px solid rgba(212, 175, 55, 0.3);
      color: #d4af37;
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .share-btn {
      background: rgba(212, 175, 55, 0.2);
      border: 1px solid #d4af37;
      color: #d4af37;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .add-contact-btn {
      background: #d4af37;
      border: none;
      color: #000;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .contact-buttons {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 1rem;
    }

    .modal-content {
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border: 2px solid rgba(212, 175, 55, 0.4);
      border-radius: 16px;
      padding: 1.5rem;
      max-width: 400px;
      width: 100%;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(212, 175, 55, 0.1);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #d4af37;
    }

    .modal-close {
      background: none;
      border: none;
      color: #888;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .qr-container {
      background: #fff;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 1rem;
    }

    .qr-container canvas, .qr-container img {
      max-width: 200px;
    }

    .share-link-container {
      background: rgba(50, 50, 50, 0.5);
      border: 1px solid rgba(212, 175, 55, 0.2);
      border-radius: 8px;
      padding: 0.75rem;
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .share-link-input {
      flex: 1;
      background: none;
      border: none;
      color: #fff;
      font-size: 0.8rem;
      outline: none;
    }

    .copy-btn {
      background: #d4af37;
      border: none;
      color: #000;
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .modal-input {
      width: 100%;
      background: rgba(50, 50, 50, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      padding: 0.75rem;
      color: #fff;
      font-size: 1rem;
      margin-bottom: 1rem;
    }

    .modal-input:focus {
      outline: none;
      border-color: #d4af37;
    }

    .modal-btn {
      width: 100%;
      background: linear-gradient(135deg, #d4af37, #b8962e);
      border: 1px solid #d4af37;
      color: #0d0d0d;
      padding: 0.75rem;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
    }

    .modal-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
    }

    .modal-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .share-instructions {
      text-align: center;
      color: #888;
      font-size: 0.875rem;
      margin-bottom: 1rem;
    }

    .add-contact-chat-btn {
      background: rgba(212, 175, 55, 0.2);
      border: 1px solid #d4af37;
      color: #d4af37;
      padding: 0.4rem 0.75rem;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      white-space: nowrap;
    }

    .add-contact-chat-btn.added {
      background: rgba(76, 175, 80, 0.2);
      border-color: #4CAF50;
      color: #4CAF50;
    }

    /* Media Messaging Styles */
    .media-buttons {
      display: flex;
      gap: 0.25rem;
      padding-right: 0.5rem;
    }

    .media-btn {
      background: transparent;
      border: none;
      color: #888;
      font-size: 1.25rem;
      padding: 0.5rem;
      cursor: pointer;
      border-radius: 50%;
      transition: all 0.2s;
    }

    .media-btn:hover {
      color: #d4af37;
      background: rgba(212, 175, 55, 0.1);
    }

    .media-btn.recording {
      color: #ff4444;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .media-preview {
      background: rgba(30, 30, 30, 0.95);
      padding: 0.75rem;
      border-top: 1px solid rgba(212, 175, 55, 0.2);
      display: none;
    }

    .media-preview.active {
      display: block;
    }

    .media-preview-content {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .media-preview img,
    .media-preview video {
      max-width: 120px;
      max-height: 80px;
      border-radius: 8px;
      object-fit: cover;
    }

    .media-preview-info {
      flex: 1;
      color: #888;
      font-size: 0.75rem;
    }

    .media-preview-name {
      color: #fff;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .media-preview-remove {
      background: rgba(255, 68, 68, 0.2);
      border: none;
      color: #ff4444;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
    }

    .audio-recorder {
      display: none;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: rgba(30, 30, 30, 0.95);
      border-top: 1px solid rgba(212, 175, 55, 0.2);
    }

    .audio-recorder.active {
      display: flex;
    }

    .audio-timer {
      color: #ff4444;
      font-family: monospace;
      font-size: 1rem;
      min-width: 50px;
    }

    .audio-waveform {
      flex: 1;
      height: 30px;
      background: rgba(255, 68, 68, 0.1);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
    }

    .audio-bar {
      width: 3px;
      background: #ff4444;
      border-radius: 2px;
      animation: audioWave 0.5s ease-in-out infinite;
    }

    @keyframes audioWave {
      0%, 100% { height: 5px; }
      50% { height: 20px; }
    }

    .audio-cancel-btn {
      background: rgba(255, 68, 68, 0.2);
      border: none;
      color: #ff4444;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
    }

    .audio-send-btn {
      background: #d4af37;
      border: none;
      color: #000;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
    }

    .message-media {
      margin-top: 0.5rem;
      max-width: 250px;
    }

    .message-media img {
      width: 100%;
      border-radius: 8px;
      cursor: pointer;
    }

    .message-media video {
      width: 100%;
      border-radius: 8px;
    }

    .message-media audio {
      width: 100%;
      height: 36px;
    }

    .media-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .media-fullscreen.active {
      display: flex;
    }

    .media-fullscreen img,
    .media-fullscreen video {
      max-width: 95%;
      max-height: 95%;
      object-fit: contain;
    }

    .media-fullscreen-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .hidden-input {
      display: none;
    }

    /* Group Chat Styles */
    .group-card {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid rgba(76, 175, 80, 0.3);
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .group-card:hover {
      border-color: #4CAF50;
      transform: translateY(-2px);
    }

    .group-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(76, 175, 80, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #4CAF50;
      font-size: 1.2rem;
      margin-right: 0.75rem;
    }

    .group-name {
      font-weight: 600;
      color: #fff;
    }

    .group-members-count {
      font-size: 0.75rem;
      color: #888;
    }

    .create-group-btn {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid #4CAF50;
      color: #4CAF50;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .member-select-list {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 1rem;
    }

    .member-select-item {
      display: flex;
      align-items: center;
      padding: 0.5rem;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .member-select-item:hover {
      background: rgba(212, 175, 55, 0.1);
    }

    .member-select-item.selected {
      background: rgba(76, 175, 80, 0.2);
    }

    .member-checkbox {
      width: 20px;
      height: 20px;
      margin-right: 0.75rem;
      accent-color: #4CAF50;
    }

    .group-header-info {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .group-message-sender {
      font-size: 0.7rem;
      color: #4CAF50;
      margin-bottom: 0.25rem;
    }

    .section-divider {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin: 1rem 0;
      color: #666;
      font-size: 0.8rem;
    }

    .section-divider::before,
    .section-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: rgba(212, 175, 55, 0.2);
    }

    /* Disappearing Messages Styles */
    .timer-selector {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: rgba(30, 30, 30, 0.9);
      border-radius: 8px;
      margin-bottom: 0.5rem;
    }

    .timer-selector select {
      background: #333;
      border: 1px solid #555;
      color: #fff;
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .timer-label {
      color: #888;
      font-size: 0.8rem;
    }

    .message-expiry {
      font-size: 0.65rem;
      color: #ff9800;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }

    .message-expiry.urgent {
      color: #f44336;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .message-delete-btn {
      position: absolute;
      top: 0.25rem;
      right: 0.25rem;
      background: rgba(244, 67, 54, 0.8);
      border: none;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      font-size: 0.7rem;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .message-bubble:hover .message-delete-btn {
      opacity: 1;
    }

    .message-bubble {
      position: relative;
    }

    .disappearing-indicator {
      display: inline-block;
      margin-left: 0.25rem;
      color: #ff9800;
    }

    .media-type-badge {
      font-size: 0.65rem;
      background: rgba(255, 255, 255, 0.1);
      padding: 0.1rem 0.3rem;
      border-radius: 4px;
      margin-left: 0.25rem;
    }

    /* Message Context Menu */
    .message-context-menu {
      position: fixed;
      background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
      border: 1px solid rgba(212, 175, 55, 0.4);
      border-radius: 12px;
      padding: 0.5rem 0;
      min-width: 160px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      z-index: 2000;
      display: none;
    }

    .message-context-menu.active {
      display: block;
    }

    .context-menu-item {
      padding: 0.75rem 1rem;
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: background 0.2s;
    }

    .context-menu-item:hover {
      background: rgba(212, 175, 55, 0.1);
    }

    .context-menu-item.delete {
      color: #ff5757;
    }

    .context-menu-item .price-tag {
      margin-left: auto;
      font-size: 0.75rem;
      color: #888;
      background: rgba(99, 102, 241, 0.2);
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
    }

    /* Encryption Info Modal */
    .encryption-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .encryption-modal.active {
      display: flex;
    }

    .encryption-modal-content {
      background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
      border: 2px solid rgba(99, 102, 241, 0.4);
      border-radius: 20px;
      padding: 1.5rem;
      max-width: 400px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .encryption-modal-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.25rem;
      color: #6366f1;
      font-size: 1.25rem;
      font-weight: 600;
    }

    .encryption-feature {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      padding: 0.75rem 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .encryption-feature:last-child {
      border-bottom: none;
    }

    .encryption-feature-icon {
      font-size: 1.25rem;
      min-width: 28px;
    }

    .encryption-feature-text {
      flex: 1;
    }

    .encryption-feature-title {
      color: #fff;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .encryption-feature-desc {
      color: #888;
      font-size: 0.85rem;
      line-height: 1.4;
    }

    .encryption-close-btn {
      width: 100%;
      margin-top: 1rem;
      padding: 0.75rem;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      border: none;
      border-radius: 10px;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }

    /* Premium File Tiers */
    .file-tier-selector {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .file-tier-btn {
      flex: 1;
      padding: 0.5rem;
      background: rgba(50, 50, 50, 0.6);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      color: #ccc;
      font-size: 0.7rem;
      cursor: pointer;
      text-align: center;
    }

    .file-tier-btn.active {
      background: rgba(99, 102, 241, 0.2);
      border-color: #6366f1;
      color: #6366f1;
    }

    .file-tier-btn .tier-size {
      font-weight: 600;
      display: block;
    }

    .file-tier-btn .tier-price {
      font-size: 0.65rem;
      color: #888;
    }
  </style>
</head>
<body>
  <div class="messages-container">
    <!-- Inbox View -->
    <div id="inboxView">
      <div class="page-header">
        <a href="/m/wallet" class="back-to-dashboard">‚Üê Dashboard</a>
        <div class="page-title">
          <span>üí¨</span> Messages
        </div>
        <div class="inbox-stats" id="inboxStats">Loading...</div>
      </div>

      <!-- Service Balance Bar -->
      <div id="serviceBalanceBar" style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 10px 16px; display: flex; justify-content: space-between; align-items: center; border-radius: 10px; margin: 0 16px 12px 16px;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <span style="font-size: 16px;">‚ö°</span>
          <span style="color: #fff; font-size: 14px;">Service Credits:</span>
          <span id="msgServiceBalance" style="color: #fff; font-weight: 700; font-size: 16px;">0</span>
          <span style="color: rgba(255,255,255,0.8); font-size: 12px;">sats</span>
        </div>
        <button onclick="window.location.href='/m/wallet#service-balance'" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: #fff; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
          + Fund
        </button>
      </div>

      <div class="nav-tabs">
        <div class="nav-tab active" data-tab="conversations" onclick="switchTab('conversations')">
          Chats
        </div>
        <div class="nav-tab" data-tab="groups" onclick="switchTab('groups')">
          Groups
        </div>
        <div class="nav-tab" data-tab="contacts" onclick="switchTab('contacts')">
          Contacts
        </div>
      </div>

      <div id="conversationsTab">
        <div id="conversationList" class="conversation-list">
          <div class="loading-spinner">
            <div class="spinner"></div>
          </div>
        </div>
      </div>

      <div id="groupsTab" style="display: none;">
        <div class="contact-buttons" style="margin-bottom: 1rem;">
          <button class="create-group-btn" onclick="showCreateGroupModal()">
            <span>üë•</span> Create Group
          </button>
        </div>
        <div id="groupsList" class="conversation-list"></div>
      </div>

      <div id="contactsTab" style="display: none;">
        <div class="contact-buttons">
          <button class="share-btn" onclick="showShareModal()">
            <span>üì§</span> Share My Contact
          </button>
          <button class="add-contact-btn" onclick="showAddContactModal()">
            <span>‚ûï</span> Add Contact
          </button>
        </div>
        <div id="contactsList" class="contacts-list"></div>
      </div>

      <div class="encryption-notice" onclick="showEncryptionInfo()">
        <span>üîê</span> Military-grade E2E encryption ‚Ä¢ Messages auto-delete ‚Ä¢ <span style="text-decoration: underline; cursor: pointer;">Learn more</span>
      </div>
    </div>

    <!-- Chat View -->
    <div id="chatView" class="chat-view">
      <div class="chat-header">
        <button class="chat-back-btn" onclick="showInbox()">‚Üê</button>
        <div style="flex:1">
          <div class="chat-participant-name" id="chatParticipantName">Loading...</div>
          <div class="chat-item-context" id="chatItemContext"></div>
        </div>
        <button class="add-contact-chat-btn" id="addContactChatBtn" onclick="addCurrentRecipientToContacts()">
          ‚ûï Add
        </button>
      </div>

      <div class="chat-messages" id="chatMessages"></div>

      <div class="encryption-notice" onclick="showEncryptionInfo()">
        <span>üîê</span> AES-256 + Curve25519 encrypted ‚Ä¢ Zero-knowledge architecture
      </div>

      <!-- Media Preview -->
      <div class="media-preview" id="mediaPreview">
        <div class="media-preview-content">
          <div id="mediaPreviewThumb"></div>
          <div class="media-preview-info">
            <div class="media-preview-name" id="mediaPreviewName">Photo</div>
            <div id="mediaPreviewSize">0 KB</div>
          </div>
          <button class="media-preview-remove" onclick="clearMediaPreview()">√ó</button>
        </div>
      </div>

      <!-- Audio Recorder -->
      <div class="audio-recorder" id="audioRecorder">
        <div class="audio-timer" id="audioTimer">0:00</div>
        <div class="audio-waveform">
          <div class="audio-bar" style="animation-delay: 0s"></div>
          <div class="audio-bar" style="animation-delay: 0.1s"></div>
          <div class="audio-bar" style="animation-delay: 0.2s"></div>
          <div class="audio-bar" style="animation-delay: 0.3s"></div>
          <div class="audio-bar" style="animation-delay: 0.4s"></div>
        </div>
        <button class="audio-cancel-btn" onclick="cancelAudioRecording()">Cancel</button>
        <button class="audio-send-btn" onclick="sendAudioRecording()">Send</button>
      </div>

      <!-- Media buttons row (above input) -->
      <div class="media-buttons-row">
        <button class="media-btn" onclick="document.getElementById('photoInput').click()" title="Send photo">üì∑ Photo</button>
        <button class="media-btn" onclick="document.getElementById('videoInput').click()" title="Send video">üé• Video</button>
        <button class="media-btn" onclick="document.getElementById('fileInput').click()" title="Send file">üìé File</button>
        <button class="media-btn" id="audioBtn" onclick="toggleAudioRecording()" title="Record audio">üé§ Audio</button>
      </div>
      
      <!-- Disappearing message timer selector -->
      <div class="timer-selector" id="timerSelector">
        <span class="timer-label">‚è±Ô∏è Auto-delete:</span>
        <select id="disappearTimer" onchange="updateDisappearTimer()">
          <option value="0">Default (by media type)</option>
          <option value="30000">30 seconds</option>
          <option value="300000">5 minutes</option>
          <option value="3600000">1 hour</option>
          <option value="86400000">24 hours</option>
          <option value="259200000">3 days</option>
          <option value="864000000">10 days</option>
        </select>
        <label style="display: flex; align-items: center; gap: 0.25rem; color: #888; font-size: 0.75rem;">
          <input type="checkbox" id="expiresAfterView"> After view
        </label>
      </div>
      
      <!-- Text input row -->
      <div class="chat-input-row">
        <input type="text" class="chat-input" id="messageInput" placeholder="Type a message..." 
               onkeypress="if(event.key==='Enter')sendMessage()">
      </div>
      
      <!-- Action buttons row (below input) -->
      <div class="chat-actions-row">
        <button class="ptt-btn" id="pttBtn" title="Hold to talk">
          <span class="ptt-icon">üéôÔ∏è</span>
          <span class="ptt-text">Hold to Talk</span>
        </button>
        <button class="chat-send-btn" onclick="sendMessage()" id="sendBtn">‚û§ Send</button>
      </div>
      
      <!-- Push-to-Talk Recording Indicator -->
      <div class="ptt-recording" id="pttRecording">
        <div class="ptt-pulse"></div>
        <div class="ptt-status">üéôÔ∏è Recording... Release to send</div>
      </div>

      <!-- Hidden file inputs -->
      <input type="file" id="photoInput" class="hidden-input" accept="image/*" capture="environment" onchange="handlePhotoSelect(event)">
      <input type="file" id="videoInput" class="hidden-input" accept="video/*" capture="environment" onchange="handleVideoSelect(event)">
      <input type="file" id="fileInput" class="hidden-input" onchange="handleFileSelect(event)">
    </div>
  </div>

  <!-- Fullscreen Media Viewer -->
  <div class="media-fullscreen" id="mediaFullscreen" onclick="closeFullscreen()">
    <button class="media-fullscreen-close">√ó</button>
    <div id="fullscreenContent"></div>
  </div>

  <!-- Message Context Menu -->
  <div class="message-context-menu" id="messageContextMenu">
    <div class="context-menu-item" onclick="copyMessageText()">
      <span>üìã</span> Copy Text
    </div>
    <div class="context-menu-item" onclick="editMessage()">
      <span>‚úèÔ∏è</span> Edit <span class="price-tag">25 sats</span>
    </div>
    <div class="context-menu-item delete" onclick="deleteMessageWithPayment()">
      <span>üóëÔ∏è</span> Delete Now <span class="price-tag">50 sats</span>
    </div>
  </div>

  <!-- Encryption Info Modal -->
  <div class="encryption-modal" id="encryptionModal" onclick="if(event.target===this)closeEncryptionModal()">
    <div class="encryption-modal-content">
      <div class="encryption-modal-header">
        <span>üîê</span> Military-Grade Encryption
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üîí</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">AES-256 Encryption</div>
          <div class="encryption-feature-desc">Same encryption used by governments and banks. Would take billions of years to crack with current technology.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üîë</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Curve25519 Key Exchange</div>
          <div class="encryption-feature-desc">Your private keys never leave your device. Not even we can read your messages.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üö´</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Zero-Knowledge Architecture</div>
          <div class="encryption-feature-desc">We cannot comply with data requests because we literally don't have access to your data.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üåê</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Decentralized Network</div>
          <div class="encryption-feature-desc">No central server to hack or subpoena. Your data is distributed across a global mesh network.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">‚è±Ô∏è</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Auto-Deleting Messages</div>
          <div class="encryption-feature-desc">Messages automatically disappear after the set time. Perfect for sensitive communications.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">‚úÖ</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Open Source & Auditable</div>
          <div class="encryption-feature-desc">Our encryption code is publicly available for security researchers to verify.</div>
        </div>
      </div>
      
      <button class="encryption-close-btn" onclick="closeEncryptionModal()">Got It</button>
    </div>
  </div>

  <!-- Insufficient Balance Modal -->
  <div class="encryption-modal" id="insufficientBalanceModal" onclick="if(event.target===this)closeInsufficientBalanceModal()">
    <div class="encryption-modal-content">
      <div class="encryption-modal-header">
        <span>‚ö°</span> Insufficient Service Balance
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üí∞</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Current Balance: <span id="currentBalanceDisplay">0</span> sats</div>
          <div class="encryption-feature-desc">You need <span id="requiredAmountDisplay">50</span> sats for this action.</div>
        </div>
      </div>
      
      <div class="encryption-feature">
        <div class="encryption-feature-icon">üì±</div>
        <div class="encryption-feature-text">
          <div class="encryption-feature-title">Fund Your Balance</div>
          <div class="encryption-feature-desc">Go to your wallet to add funds via Bitcoin payment.</div>
        </div>
      </div>
      
      <button class="encryption-close-btn" onclick="window.location.href='/m/wallet'" style="background: linear-gradient(135deg, #d4af37, #b8962e);">
        Go to Wallet
      </button>
      <button class="encryption-close-btn" onclick="closeInsufficientBalanceModal()" style="background: transparent; border: 1px solid #666; margin-top: 0.5rem;">
        Cancel
      </button>
    </div>
  </div>

  <!-- Share Contact Modal -->
  <div id="shareModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeModals()">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">üì§ Share My Contact</div>
        <button class="modal-close" onclick="closeModals()">√ó</button>
      </div>
      <div class="share-instructions">
        Others can scan this QR code or use the link to message you
      </div>
      <div class="qr-container" id="qrContainer"></div>
      <div class="share-link-container">
        <input type="text" class="share-link-input" id="shareLink" readonly>
        <button class="copy-btn" onclick="copyShareLink()">Copy</button>
      </div>
    </div>
  </div>

  <!-- Create Group Modal -->
  <div id="createGroupModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeModals()">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">üë• Create Group</div>
        <button class="modal-close" onclick="closeModals()">√ó</button>
      </div>
      <input type="text" class="modal-input" id="groupNameInput" placeholder="Group name...">
      <div class="share-instructions">Select members from your contacts:</div>
      <div class="member-select-list" id="memberSelectList"></div>
      <button class="modal-btn" onclick="createGroup()">Create Group</button>
    </div>
  </div>

  <!-- Manage Group Modal -->
  <div id="manageGroupModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeModals()">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">‚öôÔ∏è Group Settings</div>
        <button class="modal-close" onclick="closeModals()">√ó</button>
      </div>
      <div id="manageGroupName" style="font-weight: 600; margin-bottom: 1rem; color: #fff;"></div>
      <div class="share-instructions">Current members:</div>
      <div class="member-select-list" id="currentMembersList"></div>
      <div class="section-divider">Add members</div>
      <div class="member-select-list" id="addMembersList"></div>
      <button class="modal-btn" style="background: #ff4444; margin-top: 1rem;" onclick="leaveCurrentGroup()">üö™ Leave Group</button>
    </div>
  </div>

  <!-- Add Contact Modal -->
  <div id="addContactModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeModals()">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">‚ûï Add Contact</div>
        <button class="modal-close" onclick="closeModals()">√ó</button>
      </div>
      <div class="share-instructions">
        Scan a contact QR code or paste their link/ID
      </div>
      <div id="qrScannerContainer" style="display: none; margin-bottom: 15px;">
        <video id="qrScannerVideo" style="width: 100%; max-height: 250px; border-radius: 12px; background: #000;"></video>
        <div id="qrScannerStatus" style="text-align: center; color: #999; font-size: 13px; margin-top: 8px;">Point camera at QR code...</div>
      </div>
      <button class="modal-btn" id="scanQrBtn" onclick="toggleQrScanner()" style="margin-bottom: 15px; background: #333;">
        üì∑ Scan QR Code
      </button>
      <input type="text" class="modal-input" id="addContactInput" placeholder="Or paste link / account ID...">
      <button class="modal-btn" onclick="addContactFromInput()">Add & Start Chat</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
  <script src="/js/nacl-fast.min.js" integrity="sha384-05+sicyRJQ56XpL4U9HJ8YbtSzFDvAg7apPKOGV6A0JsAJKFM68jp5oLnUjG5mEp" crossorigin="anonymous"></script>
  <script src="/js/nacl-util.min.js" integrity="sha384-qpU3wxGxaAPcz02pOLeZTv5B0rNzsh3CETsUqdHxRBP70bO0kHoBopr+f9AcGj04" crossorigin="anonymous"></script>
  <script src="/js/btc.bundle.js"></script>
  <script src="/wallet-auth.js"></script>
  <script>
    let currentConversationId = null;
    let currentRecipientId = null;
    let currentRecipientPublicKey = null;
    let currentItemId = null;
    let myMessagingPrivateKey = null; // Messaging private key (NOT BTC spending key)
    let myMessagingPublicKey = null;  // Messaging public key for key exchange
    let myEncryptionKeyPair = null;   // Derived X25519 keypair for E2E encryption
    const recipientEncryptionKeyCache = new Map();
    let conversations = [];
    let messagePollingInterval = null;
    let inboxPollingInterval = null;
    const POLL_INTERVAL_MS = 5000; // Check for new messages every 5 seconds

    // Helper: Check response for auth errors and redirect to login
    function checkAuthAndRedirect(response) {
      if (response.status === 401 || response.status === 403) {
        WalletAuth.lock();
        alert('Session expired. Please log in again.');
        WalletAuth.requireAuth();
        return true;
      }
      return false;
    }

    // ============================================================
    // E2E ENCRYPTION (Signal-grade: Curve25519 + XSalsa20-Poly1305)
    // ============================================================

    // Convert hex string to Uint8Array
    function hexToBytes(hex) {
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
      }
      return bytes;
    }

    // Convert Uint8Array to hex string
    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function sha256Sync(bytes) {
      const K = [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
      ];
      const rotr = (x, n) => (x >>> n) | (x << (32 - n));

      const bitLen = bytes.length * 8;
      const withOne = bytes.length + 1;
      const padLen = (withOne % 64 <= 56) ? (56 - (withOne % 64)) : (56 + (64 - (withOne % 64)));
      const totalLen = withOne + padLen + 8;
      const msg = new Uint8Array(totalLen);
      msg.set(bytes, 0);
      msg[bytes.length] = 0x80;
      const view = new DataView(msg.buffer);
      view.setUint32(totalLen - 8, Math.floor(bitLen / 2 ** 32), false);
      view.setUint32(totalLen - 4, bitLen >>> 0, false);

      let h0 = 0x6a09e667;
      let h1 = 0xbb67ae85;
      let h2 = 0x3c6ef372;
      let h3 = 0xa54ff53a;
      let h4 = 0x510e527f;
      let h5 = 0x9b05688c;
      let h6 = 0x1f83d9ab;
      let h7 = 0x5be0cd19;

      const w = new Uint32Array(64);
      for (let i = 0; i < msg.length; i += 64) {
        for (let t = 0; t < 16; t++) {
          w[t] = view.getUint32(i + t * 4, false);
        }
        for (let t = 16; t < 64; t++) {
          const s0 = (rotr(w[t - 15], 7) ^ rotr(w[t - 15], 18) ^ (w[t - 15] >>> 3)) >>> 0;
          const s1 = (rotr(w[t - 2], 17) ^ rotr(w[t - 2], 19) ^ (w[t - 2] >>> 10)) >>> 0;
          w[t] = (w[t - 16] + s0 + w[t - 7] + s1) >>> 0;
        }

        let a = h0;
        let b = h1;
        let c = h2;
        let d = h3;
        let e = h4;
        let f = h5;
        let g = h6;
        let h = h7;

        for (let t = 0; t < 64; t++) {
          const S1 = (rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)) >>> 0;
          const ch = ((e & f) ^ (~e & g)) >>> 0;
          const temp1 = (h + S1 + ch + K[t] + w[t]) >>> 0;
          const S0 = (rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)) >>> 0;
          const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0;
          const temp2 = (S0 + maj) >>> 0;

          h = g;
          g = f;
          f = e;
          e = (d + temp1) >>> 0;
          d = c;
          c = b;
          b = a;
          a = (temp1 + temp2) >>> 0;
        }

        h0 = (h0 + a) >>> 0;
        h1 = (h1 + b) >>> 0;
        h2 = (h2 + c) >>> 0;
        h3 = (h3 + d) >>> 0;
        h4 = (h4 + e) >>> 0;
        h5 = (h5 + f) >>> 0;
        h6 = (h6 + g) >>> 0;
        h7 = (h7 + h) >>> 0;
      }

      const out = new Uint8Array(32);
      const outView = new DataView(out.buffer);
      outView.setUint32(0, h0, false);
      outView.setUint32(4, h1, false);
      outView.setUint32(8, h2, false);
      outView.setUint32(12, h3, false);
      outView.setUint32(16, h4, false);
      outView.setUint32(20, h5, false);
      outView.setUint32(24, h6, false);
      outView.setUint32(28, h7, false);
      return out;
    }

    async function sha256Bytes(bytes) {
      try {
        if (window.crypto && window.crypto.subtle && window.crypto.subtle.digest) {
          const hashBuffer = await window.crypto.subtle.digest('SHA-256', bytes);
          return new Uint8Array(hashBuffer);
        }
      } catch (e) {
      }
      return sha256Sync(bytes);
    }

    // Derive X25519 keypair from wallet private key using SHA-256
    async function deriveEncryptionKeyPair(privateKeyHex) {
      // Hash the private key to get 32 bytes for X25519 seed
      const privateKeyBytes = hexToBytes(privateKeyHex);
      const seed = await sha256Bytes(privateKeyBytes);
      
      // Generate X25519 keypair from seed
      const keyPair = nacl.box.keyPair.fromSecretKey(seed);
      return keyPair;
    }

    async function publishMyEncryptionPublicKey() {
      if (!myEncryptionKeyPair) return;
      const keyHex = bytesToHex(myEncryptionKeyPair.publicKey);
      const maxRetries = 3;
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const r = await fetch('/api/messages/keys', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              ...WalletAuth.getAuthHeaders(),
            },
            body: JSON.stringify({ encryptionPublicKeyHex: keyHex }),
          });
          if (r.ok) {
            console.log('[Messaging] Encryption key published successfully');
            return;
          }
          const errData = await r.json().catch(() => ({}));
          console.warn(`[Messaging] Key publish attempt ${attempt + 1} failed (${r.status}):`, errData?.error || r.statusText);
          if (r.status === 401) {
            // Session expired - try to re-read session from storage
            console.warn('[Messaging] Session may be expired for key publish');
          }
        } catch (e) {
          console.warn(`[Messaging] Key publish attempt ${attempt + 1} network error:`, e?.message || e);
        }
        if (attempt < maxRetries - 1) {
          await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
        }
      }
      console.error('[Messaging] Failed to publish encryption key after all retries');
    }

    async function getRecipientEncryptionPublicKeyBytes(recipientId) {
      const id = String(recipientId || '').trim();
      if (!id) throw new Error('Missing recipient id');

      const cached = recipientEncryptionKeyCache.get(id);
      if (cached && cached.bytes && cached.bytes.length === 32) return cached.bytes;

      const r = await fetch(`/api/messages/keys/${encodeURIComponent(id)}`, {
        headers: {
          ...WalletAuth.getAuthHeaders(),
        },
      });

      if (!r.ok) {
        throw new Error('Recipient messaging key not found');
      }

      const data = await r.json();
      const keyHex = String(data?.encryptionPublicKeyHex || '').trim().toLowerCase();
      if (!/^[0-9a-f]{64}$/.test(keyHex)) {
        throw new Error('Invalid recipient messaging key');
      }

      const bytes = hexToBytes(keyHex);
      if (!bytes || bytes.length !== 32) {
        throw new Error('Invalid recipient messaging key');
      }

      recipientEncryptionKeyCache.set(id, { bytes, updatedAt: Number(data?.updatedAt || Date.now()) });
      return bytes;
    }

    // Encrypt message for recipient (and self)
    async function encryptForRecipient(plaintext, recipientPublicKeyHex) {
      if (!myEncryptionKeyPair) {
        throw new Error('Encryption keys not initialized');
      }
      
      const recipientEncPubKeyBytes = await getRecipientEncryptionPublicKeyBytes(recipientPublicKeyHex);
      return encryptForEncryptionPublicKey(plaintext, recipientEncPubKeyBytes);
    }

    // Pad plaintext to nearest 256-byte boundary to prevent length-based analysis
    function padMessage(messageBytes) {
      const PAD_BLOCK = 256;
      const len = messageBytes.length;
      const paddedLen = Math.ceil((len + 4) / PAD_BLOCK) * PAD_BLOCK;
      const padded = new Uint8Array(paddedLen);
      padded[0] = (len >>> 24) & 0xff;
      padded[1] = (len >>> 16) & 0xff;
      padded[2] = (len >>> 8) & 0xff;
      padded[3] = len & 0xff;
      padded.set(messageBytes, 4);
      const randomPad = nacl.randomBytes(paddedLen - 4 - len);
      padded.set(randomPad, 4 + len);
      return padded;
    }

    function unpadMessage(paddedBytes) {
      if (paddedBytes.length < 4) return paddedBytes;
      const len = (paddedBytes[0] << 24) | (paddedBytes[1] << 16) | (paddedBytes[2] << 8) | paddedBytes[3];
      if (len <= 0 || len > paddedBytes.length - 4) return paddedBytes;
      return paddedBytes.slice(4, 4 + len);
    }

    async function encryptForEncryptionPublicKey(plaintext, recipientEncPubKeyBytes) {
      if (!myEncryptionKeyPair) {
        throw new Error('Encryption keys not initialized');
      }

      const nonce = nacl.randomBytes(24);
      const messageBytes = nacl.util.decodeUTF8(plaintext);
      const paddedBytes = padMessage(messageBytes);
      const encrypted = nacl.box(paddedBytes, nonce, recipientEncPubKeyBytes, myEncryptionKeyPair.secretKey);

      return JSON.stringify({
        v: 2,
        n: nacl.util.encodeBase64(nonce),
        c: nacl.util.encodeBase64(encrypted),
      });
    }

    // Decrypt message from sender (supports v1 and v2 envelopes)
    async function decryptFromSender(encryptedJson, senderPublicKeyHex) {
      try {
        if (!myEncryptionKeyPair) {
          const ok = await ensureEncryptionInitialized();
          if (!ok || !myEncryptionKeyPair) {
            throw new Error('Encryption keys not initialized');
          }
        }

        const envelope = JSON.parse(encryptedJson);
        
        if ((!envelope.v || (envelope.v !== 1 && envelope.v !== 2)) || !envelope.n || !envelope.c) {
          return null;
        }
        
        const nonce = nacl.util.decodeBase64(envelope.n);
        const ciphertext = nacl.util.decodeBase64(envelope.c);
        const isV2 = envelope.v === 2;

        const candidateSenderKeys = [];

        const sHex = String(envelope.s || '').trim().toLowerCase();
        if (/^[0-9a-f]{64}$/.test(sHex)) {
          try {
            const k = hexToBytes(sHex);
            if (k && k.length === 32) candidateSenderKeys.push(k);
          } catch {}
        }

        const sid = String(senderPublicKeyHex || '').trim();
        if (sid) {
          try {
            const k = await getRecipientEncryptionPublicKeyBytes(sid);
            if (k && k.length === 32) candidateSenderKeys.push(k);
          } catch {}
        }

        if (myEncryptionKeyPair.publicKey) {
          candidateSenderKeys.push(myEncryptionKeyPair.publicKey);
        }

        for (const senderEncPubKey of candidateSenderKeys) {
          const decrypted = nacl.box.open(ciphertext, nonce, senderEncPubKey, myEncryptionKeyPair.secretKey);
          if (decrypted) {
            if (isV2) {
              const unpadded = unpadMessage(decrypted);
              return nacl.util.encodeUTF8(unpadded);
            }
            return nacl.util.encodeUTF8(decrypted);
          }
        }

        return null;
      } catch (e) {
        console.error('Decryption error:', e);
        return null;
      }
    }

    // Wait for nacl library to be available
    async function waitForNacl(maxWaitMs = 5000) {
      const start = Date.now();
      while (!window.nacl || !window.nacl.box) {
        if (Date.now() - start > maxWaitMs) {
          throw new Error('NaCl library failed to load');
        }
        await new Promise(r => setTimeout(r, 100));
      }
      return true;
    }

    // Initialize encryption with retry
    async function initializeEncryption(privateKey, retries = 3) {
      for (let i = 0; i < retries; i++) {
        try {
          await waitForNacl();
          const keyPair = await deriveEncryptionKeyPair(privateKey);
          if (keyPair && keyPair.secretKey && keyPair.publicKey) {
            return keyPair;
          }
        } catch (e) {
          console.warn(`Encryption init attempt ${i + 1} failed:`, e.message);
          if (i < retries - 1) {
            await new Promise(r => setTimeout(r, 500));
          }
        }
      }
      return null;
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      const wallet = WalletAuth.getWallet();
      if (!wallet) {
        WalletAuth.requireAuth();
        return;
      }
      
      // Get messaging keys from sessionStorage (derived from mnemonic, NOT BTC spending key)
      myMessagingPrivateKey = sessionStorage.getItem('autho_messaging_privateKey');
      myMessagingPublicKey = sessionStorage.getItem('autho_messaging_publicKey');

      if (!myMessagingPrivateKey && typeof WalletAuth.ensureMessagingKeys === 'function') {
        try {
          await WalletAuth.ensureMessagingKeys();
        } catch {}
        myMessagingPrivateKey = sessionStorage.getItem('autho_messaging_privateKey');
        myMessagingPublicKey = sessionStorage.getItem('autho_messaging_publicKey');
      }

      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) sendBtn.disabled = true;

      if (!await ensureEncryptionInitialized()) {
        WalletAuth.lock();
        alert('Messaging encryption key missing. Please log in again.');
        WalletAuth.requireAuth();
        return;
      }

      if (sendBtn) sendBtn.disabled = false;
      
      await loadConversations();
      await loadContacts();
      
      // Start inbox polling for new conversations
      startInboxPolling();

      // Check for URL parameters
      const params = new URLSearchParams(window.location.search);
      const itemId = params.get('itemId');
      const recipientId = params.get('to');
      const contactId = params.get('contact');
      
      if (contactId) {
        // Coming from a shared contact link - add and start chat
        await addContactAndStartChat(contactId);
      } else if (itemId && recipientId) {
        openConversationWithItem(recipientId, itemId);
      }
    });

    function switchTab(tab) {
      document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
      
      document.getElementById('conversationsTab').style.display = tab === 'conversations' ? 'block' : 'none';
      document.getElementById('groupsTab').style.display = tab === 'groups' ? 'block' : 'none';
      document.getElementById('contactsTab').style.display = tab === 'contacts' ? 'block' : 'none';
      
      if (tab === 'groups') {
        loadGroups();
      }
    }

    async function loadConversations() {
      try {
        const response = await fetch('/api/messages/conversations', {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (checkAuthAndRedirect(response)) return;
        
        if (!response.ok) {
          throw new Error('Failed to load conversations');
        }
        
        const data = await response.json();

        if (data.success) {
          conversations = data.conversations;
          renderConversations();
          document.getElementById('inboxStats').textContent = 
            `${conversations.length} conversation${conversations.length !== 1 ? 's' : ''}`;
        } else if (data.error && data.error.includes('auth')) {
          WalletAuth.lock();
          WalletAuth.requireAuth();
        }
      } catch (error) {
        console.error('Failed to load conversations:', error);
        document.getElementById('conversationList').innerHTML = 
          '<div class="empty-inbox"><div class="empty-inbox-title">Failed to load</div></div>';
      }
    }

    function renderConversations() {
      const container = document.getElementById('conversationList');
      
      if (conversations.length === 0) {
        container.innerHTML = `
          <div class="empty-inbox">
            <div class="empty-inbox-icon">üí¨</div>
            <div class="empty-inbox-title">No messages yet</div>
            <div>Find an item and message its owner to start a conversation</div>
          </div>
        `;
        return;
      }

      const wallet = WalletAuth.getWallet();
      container.innerHTML = conversations.map(conv => {
        const otherParticipant = conv.participantInfo.find(p => p.accountId !== wallet.publicKey);
        const lastMsg = conv.lastMessage;
        const timeAgo = lastMsg ? formatTimeAgo(lastMsg.timestamp) : '';
        
        return `
          <div class="conversation-card ${conv.unreadCount > 0 ? 'unread' : ''}" 
               onclick="openConversation('${conv.conversationId}', '${otherParticipant?.accountId}')">
            <div class="conversation-header">
              <div class="conversation-participant">${escapeHtml(otherParticipant?.displayName || 'Unknown')}</div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                ${conv.unreadCount > 0 ? `<span class="unread-badge">${conv.unreadCount}</span>` : ''}
                <div class="conversation-time">${timeAgo}</div>
              </div>
            </div>
            <div class="conversation-preview">[Encrypted message]</div>
            ${lastMsg?.payload?.itemId ? `<div class="conversation-item-badge">About an item</div>` : ''}
          </div>
        `;
      }).join('');
    }

    // localStorage helpers for contact backup
    function getLocalContacts() {
      try {
        const wallet = WalletAuth.getWallet();
        if (!wallet) return [];
        const key = `contacts_${wallet.publicKey.substring(0, 16)}`;
        return JSON.parse(localStorage.getItem(key) || '[]');
      } catch (e) { return []; }
    }
    
    function saveLocalContacts(contacts) {
      try {
        const wallet = WalletAuth.getWallet();
        if (!wallet) return;
        const key = `contacts_${wallet.publicKey.substring(0, 16)}`;
        localStorage.setItem(key, JSON.stringify(contacts));
      } catch (e) { console.error('Failed to save local contacts:', e); }
    }
    
    function addLocalContact(contactId, displayName) {
      const contacts = getLocalContacts();
      if (!contacts.find(c => c.accountId === contactId)) {
        contacts.push({ accountId: contactId, displayName: displayName || contactId.substring(0, 12) + '...' });
        saveLocalContacts(contacts);
      }
    }

    async function loadContacts() {
      try {
        const response = await fetch('/api/messages/contacts', {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (checkAuthAndRedirect(response)) return;
        
        const data = await response.json();

        if (data.success) {
          // Merge server contacts with local backup
          const serverContacts = data.contacts || [];
          const localContacts = getLocalContacts();
          
          // Build merged list (server takes priority for display names)
          const merged = new Map();
          for (const c of localContacts) {
            merged.set(c.accountId, c);
          }
          for (const c of serverContacts) {
            merged.set(c.accountId, c);
          }
          
          const allContacts = Array.from(merged.values());
          
          // Save merged list back to localStorage
          saveLocalContacts(allContacts);
          
          // Re-add any local-only contacts to server
          for (const local of localContacts) {
            if (!serverContacts.find(s => s.accountId === local.accountId)) {
              // Silently re-add to server
              fetch('/api/messages/contacts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', ...WalletAuth.getAuthHeaders() },
                body: JSON.stringify({ contactId: local.accountId, displayName: local.displayName })
              }).catch(() => {});
            }
          }
          
          renderContacts(allContacts);
        }
      } catch (error) {
        console.error('Failed to load contacts:', error);
        // Fall back to local contacts
        const localContacts = getLocalContacts();
        if (localContacts.length > 0) {
          renderContacts(localContacts);
        }
      }
    }

    function renderContacts(contacts) {
      const container = document.getElementById('contactsList');
      
      if (contacts.length === 0) {
        container.innerHTML = `
          <div class="empty-inbox">
            <div class="empty-inbox-title">No contacts yet</div>
            <div>Message someone to add them to your contacts</div>
          </div>
        `;
        return;
      }

      container.innerHTML = contacts.map(contact => `
        <div class="contact-card">
          <div class="contact-info">
            <div class="contact-avatar">${contact.displayName[0].toUpperCase()}</div>
            <div>
              <div class="contact-name">${escapeHtml(contact.displayName)}</div>
              <div class="contact-role">
                ${contact.isManufacturer ? 'Manufacturer' : contact.isAuthenticator ? 'Authenticator' : 'User'}
              </div>
            </div>
          </div>
          <div class="contact-actions">
            <button onclick="startConversation('${contact.accountId}')">Message</button>
          </div>
        </div>
      `).join('');
    }

    // ============================================================
    // GROUP CHAT FUNCTIONS
    // ============================================================
    
    let groups = [];
    let currentGroupId = null;
    let currentGroupMembers = [];
    let selectedGroupMembers = new Set();

    async function loadGroups() {
      try {
        const response = await fetch('/api/messages/groups', {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (checkAuthAndRedirect(response)) return;
        
        if (!response.ok) throw new Error('Failed to load groups');
        
        const data = await response.json();
        if (data.success) {
          groups = data.groups;
          renderGroups();
        }
      } catch (error) {
        console.error('Failed to load groups:', error);
        document.getElementById('groupsList').innerHTML = 
          '<div class="empty-inbox"><div class="empty-inbox-title">Failed to load groups</div></div>';
      }
    }

    function renderGroups() {
      const container = document.getElementById('groupsList');
      
      if (groups.length === 0) {
        container.innerHTML = `
          <div class="empty-inbox">
            <div class="empty-inbox-icon">üë•</div>
            <div class="empty-inbox-title">No groups yet</div>
            <div>Create a group to chat with multiple contacts</div>
          </div>
        `;
        return;
      }

      container.innerHTML = groups.map(group => {
        const timeAgo = formatTimeAgo(group.lastMessageAt);
        return `
          <div class="group-card" onclick="openGroupChat('${group.groupId}')">
            <div class="conversation-header">
              <div style="display: flex; align-items: center;">
                <div class="group-icon">üë•</div>
                <div>
                  <div class="group-name">${escapeHtml(group.name)}</div>
                  <div class="group-members-count">${group.members.length} members</div>
                </div>
              </div>
              <div class="conversation-time">${timeAgo}</div>
            </div>
            <div class="conversation-preview">${group.messageCount} messages</div>
          </div>
        `;
      }).join('');
    }

    function showCreateGroupModal() {
      selectedGroupMembers.clear();
      document.getElementById('groupNameInput').value = '';
      
      // Get contacts for member selection
      const localContacts = getLocalContacts();
      const container = document.getElementById('memberSelectList');
      
      if (localContacts.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; padding: 1rem;">Add contacts first to create a group</div>';
      } else {
        container.innerHTML = localContacts.map(contact => `
          <div class="member-select-item" onclick="toggleMemberSelection('${contact.accountId}', this)">
            <input type="checkbox" class="member-checkbox" id="member_${contact.accountId}">
            <div class="contact-avatar" style="width: 32px; height: 32px; font-size: 0.9rem;">${contact.displayName[0].toUpperCase()}</div>
            <span>${escapeHtml(contact.displayName)}</span>
          </div>
        `).join('');
      }
      
      document.getElementById('createGroupModal').style.display = 'flex';
    }

    function toggleMemberSelection(memberId, element) {
      const checkbox = element.querySelector('.member-checkbox');
      
      if (selectedGroupMembers.has(memberId)) {
        selectedGroupMembers.delete(memberId);
        checkbox.checked = false;
        element.classList.remove('selected');
      } else {
        selectedGroupMembers.add(memberId);
        checkbox.checked = true;
        element.classList.add('selected');
      }
    }

    async function createGroup() {
      const name = document.getElementById('groupNameInput').value.trim();
      
      if (!name) {
        alert('Please enter a group name');
        return;
      }
      
      if (selectedGroupMembers.size === 0) {
        alert('Please select at least one member');
        return;
      }

      try {
        const response = await fetch('/api/messages/groups', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({
            name,
            memberIds: Array.from(selectedGroupMembers)
          })
        });

        if (checkAuthAndRedirect(response)) return;

        const data = await response.json();
        if (data.success) {
          closeModals();
          await loadGroups();
          switchTab('groups');
          alert('Group created successfully!');
        } else {
          alert('Failed to create group: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Create group error:', error);
        alert('Failed to create group');
      }
    }

    async function openGroupChat(groupId) {
      currentGroupId = groupId;
      currentConversationId = null;
      currentRecipientId = null;
      
      // Get group info
      const group = groups.find(g => g.groupId === groupId);
      if (!group) {
        alert('Group not found');
        return;
      }
      
      currentGroupMembers = group.members;
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      document.getElementById('chatParticipantName').textContent = 'üë• ' + group.name;
      document.getElementById('chatItemContext').textContent = group.members.length + ' members';
      
      // Update the Add button to show Settings for groups
      const addBtn = document.getElementById('addContactChatBtn');
      addBtn.textContent = '‚öôÔ∏è Settings';
      addBtn.classList.remove('added');
      addBtn.onclick = showManageGroupModal;
      
      await loadGroupMessages(groupId);
      
      stopInboxPolling();
      startGroupMessagePolling();
    }

    async function loadGroupMessages(groupId) {
      try {
        const response = await fetch(`/api/messages/groups/${groupId}/messages`, {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (checkAuthAndRedirect(response)) return;
        
        const data = await response.json();
        if (data.success) {
          renderGroupMessages(data.messages);
        }
      } catch (error) {
        console.error('Failed to load group messages:', error);
      }
    }

    function renderGroupMessages(messages) {
      const container = document.getElementById('chatMessages');
      const wallet = WalletAuth.getWallet();
      
      if (messages.length === 0) {
        container.innerHTML = '<div class="empty-inbox"><div class="empty-inbox-title">No messages yet</div><div>Start the conversation!</div></div>';
        return;
      }

      container.innerHTML = messages.map(msg => {
        const isSent = msg.senderId === wallet.publicKey;
        let content = '[Encrypted]';
        
        // Decrypt message
        if (msg.encryptedContent && myEncryptionKeyPair) {
          try {
            content = decryptMessage(msg.encryptedContent, msg.senderId);
          } catch (e) {
            content = '[Unable to decrypt]';
          }
        }
        
        const senderName = isSent ? 'You' : (msg.senderId.substring(0, 8) + '...');
        
        return `
          <div class="message-bubble ${isSent ? 'sent' : 'received'}">
            ${!isSent ? `<div class="group-message-sender">${senderName}</div>` : ''}
            <div class="message-text">${escapeHtml(content)}</div>
            <div class="message-meta">${formatTime(msg.timestamp)}</div>
          </div>
        `;
      }).join('');
      
      container.scrollTop = container.scrollHeight;
    }

    async function sendGroupMessage() {
      if (!currentGroupId) {
        console.error('No group selected');
        return;
      }
      
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      if (!text) return;

      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) sendBtn.disabled = true;

      try {
        // Create message envelope
        const messageEnvelope = JSON.stringify({
          type: 'text',
          content: text,
          timestamp: Date.now()
        });

        if (!await ensureEncryptionInitialized()) {
          WalletAuth.lock();
          alert('Encryption not initialized. Please log in again.');
          WalletAuth.requireAuth();
          console.error('SECURITY: Attempted to send group message without encryption keys');
          return;
        }

        // Encrypt message for each group member
        const encryptedContentByMember = {};
        
        for (const memberId of currentGroupMembers) {
          try {
            const wallet = WalletAuth.getWallet();
            const isMe = wallet && memberId === wallet.publicKey;
            const encrypted = isMe
              ? await encryptForEncryptionPublicKey(messageEnvelope, myEncryptionKeyPair.publicKey)
              : await encryptForRecipient(messageEnvelope, memberId);
            encryptedContentByMember[memberId] = encrypted;
          } catch (e) {
            console.error('SECURITY: Failed to encrypt for member:', memberId, e);
          }
        }
        
        // SECURITY: Do NOT send if encryption fails for any member
        if (Object.keys(encryptedContentByMember).length !== currentGroupMembers.length) {
          alert(`Failed to encrypt message for a group member. Message not sent.`);
          return;
        }

        const response = await fetch(`/api/messages/groups/${currentGroupId}/send`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ encryptedContentByMember })
        });

        if (checkAuthAndRedirect(response)) return;

        const data = await response.json();
        if (data.success) {
          input.value = '';
          await loadGroupMessages(currentGroupId);
        } else {
          alert('Failed to send message: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Send group message error:', error);
        alert('Failed to send message: ' + error.message);
      } finally {
        if (sendBtn) sendBtn.disabled = false;
      }
    }

    let groupMessagePollingInterval = null;

    function startGroupMessagePolling() {
      stopGroupMessagePolling();
      groupMessagePollingInterval = setInterval(async () => {
        if (currentGroupId) {
          await loadGroupMessages(currentGroupId);
        }
      }, POLL_INTERVAL_MS);
    }

    function stopGroupMessagePolling() {
      if (groupMessagePollingInterval) {
        clearInterval(groupMessagePollingInterval);
        groupMessagePollingInterval = null;
      }
    }

    // ============================================================
    // GROUP MANAGEMENT FUNCTIONS
    // ============================================================

    let currentGroupInfo = null;

    async function showManageGroupModal() {
      if (!currentGroupId) return;
      
      // Fetch fresh group info
      try {
        const response = await fetch(`/api/messages/groups/${currentGroupId}`, {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (!response.ok) throw new Error('Failed to load group');
        
        const data = await response.json();
        if (!data.success) throw new Error(data.error);
        
        currentGroupInfo = data.group;
        
        document.getElementById('manageGroupName').textContent = 'üë• ' + currentGroupInfo.name;
        
        // Show current members
        const wallet = WalletAuth.getWallet();
        const isAdmin = currentGroupInfo.adminId === wallet.publicKey;
        const currentMembersList = document.getElementById('currentMembersList');
        
        currentMembersList.innerHTML = currentGroupInfo.members.map(memberId => {
          const isMe = memberId === wallet.publicKey;
          const isMemberAdmin = memberId === currentGroupInfo.adminId;
          const shortId = memberId.substring(0, 12) + '...';
          
          return `
            <div class="member-select-item">
              <div class="contact-avatar" style="width: 32px; height: 32px; font-size: 0.9rem; margin-right: 0.75rem;">
                ${isMemberAdmin ? 'üëë' : 'üë§'}
              </div>
              <span style="flex: 1;">${isMe ? 'You' : shortId}${isMemberAdmin ? ' (Admin)' : ''}</span>
              ${isAdmin && !isMe ? `<button onclick="removeMemberFromGroup('${memberId}')" style="background: #ff4444; border: none; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.75rem;">Remove</button>` : ''}
            </div>
          `;
        }).join('');
        
        // Show contacts that can be added
        const localContacts = getLocalContacts();
        const nonMembers = localContacts.filter(c => !currentGroupInfo.members.includes(c.accountId));
        const addMembersList = document.getElementById('addMembersList');
        
        if (nonMembers.length === 0) {
          addMembersList.innerHTML = '<div style="color: #888; text-align: center; padding: 0.5rem;">All contacts are already members</div>';
        } else {
          addMembersList.innerHTML = nonMembers.map(contact => `
            <div class="member-select-item" onclick="addMemberToGroup('${contact.accountId}')">
              <div class="contact-avatar" style="width: 32px; height: 32px; font-size: 0.9rem; margin-right: 0.75rem;">${contact.displayName[0].toUpperCase()}</div>
              <span style="flex: 1;">${escapeHtml(contact.displayName)}</span>
              <span style="color: #4CAF50;">+ Add</span>
            </div>
          `).join('');
        }
        
        document.getElementById('manageGroupModal').style.display = 'flex';
        
      } catch (error) {
        console.error('Failed to load group info:', error);
        alert('Failed to load group settings');
      }
    }

    async function addMemberToGroup(memberId) {
      if (!currentGroupId) return;
      
      try {
        const response = await fetch(`/api/messages/groups/${currentGroupId}/members`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ memberId })
        });
        
        const data = await response.json();
        if (data.success) {
          // Refresh group info and modal
          await loadGroups();
          currentGroupMembers.push(memberId);
          await showManageGroupModal();
        } else {
          alert('Failed to add member: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Add member error:', error);
        alert('Failed to add member');
      }
    }

    async function removeMemberFromGroup(memberId) {
      if (!currentGroupId) return;
      
      if (!confirm('Remove this member from the group?')) return;
      
      try {
        const response = await fetch(`/api/messages/groups/${currentGroupId}/members/${memberId}`, {
          method: 'DELETE',
          headers: WalletAuth.getAuthHeaders()
        });
        
        const data = await response.json();
        if (data.success) {
          // Refresh group info and modal
          await loadGroups();
          currentGroupMembers = currentGroupMembers.filter(m => m !== memberId);
          await showManageGroupModal();
        } else {
          alert('Failed to remove member: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Remove member error:', error);
        alert('Failed to remove member');
      }
    }

    async function leaveCurrentGroup() {
      if (!currentGroupId) return;
      
      if (!confirm('Are you sure you want to leave this group?')) return;
      
      try {
        const response = await fetch(`/api/messages/groups/${currentGroupId}/leave`, {
          method: 'POST',
          headers: WalletAuth.getAuthHeaders()
        });
        
        const data = await response.json();
        if (data.success) {
          closeModals();
          showInbox();
          await loadGroups();
          alert('You have left the group');
        } else {
          alert('Failed to leave group: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Leave group error:', error);
        alert('Failed to leave group');
      }
    }

    async function openConversation(conversationId, recipientId) {
      currentConversationId = conversationId;
      currentRecipientId = recipientId;
      currentGroupId = null; // Reset group context
      currentItemId = null;
      document.getElementById('chatItemContext').textContent = '';
      
      // Get recipient's public key for encryption
      currentRecipientPublicKey = recipientId; // In our system, accountId IS the public key
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      
      // Reset the Add button for 1-on-1 chats
      const addBtn = document.getElementById('addContactChatBtn');
      addBtn.textContent = '‚ûï Add';
      addBtn.onclick = addCurrentRecipientToContacts;
      
      // Set participant name
      const conv = conversations.find(c => c.conversationId === conversationId);
      const participant = conv?.participantInfo.find(p => p.accountId === recipientId);
      document.getElementById('chatParticipantName').textContent = participant?.displayName || recipientId.substring(0, 12) + '...';
      
      await loadMessages(conversationId);
      
      // Reset message count for new conversation
      lastMessageCount = 0;
      
      // Stop inbox polling, start message polling
      stopInboxPolling();
      startMessagePolling();
    }
    
    let lastMessageCount = 0;
    
    function startMessagePolling() {
      stopMessagePolling(); // Clear any existing interval
      messagePollingInterval = setInterval(async () => {
        if (currentConversationId) {
          await pollForNewMessages(currentConversationId);
        }
      }, POLL_INTERVAL_MS);
    }
    
    async function pollForNewMessages(conversationId) {
      try {
        const response = await fetch(`/api/messages/conversation/${conversationId}`, {
          headers: WalletAuth.getAuthHeaders()
        });
        const data = await response.json();
        
        if (data.success && data.messages) {
          // Only update if message count changed (new messages arrived)
          if (data.messages.length !== lastMessageCount) {
            const container = document.getElementById('chatMessages');
            const wasAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;
            
            lastMessageCount = data.messages.length;
            await renderMessages(data.messages);
            
            // Auto-scroll to bottom only if user was already at bottom
            if (wasAtBottom) {
              container.scrollTop = container.scrollHeight;
            }
          }
        }
      } catch (error) {
        console.error('Poll error:', error);
      }
    }
    
    function stopMessagePolling() {
      if (messagePollingInterval) {
        clearInterval(messagePollingInterval);
        messagePollingInterval = null;
      }
    }
    
    function startInboxPolling() {
      stopInboxPolling();
      inboxPollingInterval = setInterval(async () => {
        await loadConversations();
      }, POLL_INTERVAL_MS);
    }
    
    function stopInboxPolling() {
      if (inboxPollingInterval) {
        clearInterval(inboxPollingInterval);
        inboxPollingInterval = null;
      }
    }

    // ============================================================
    // DISAPPEARING MESSAGES FUNCTIONS
    // ============================================================

    function updateDisappearTimer() {
      // Called on change for UI feedback if needed
      const select = document.getElementById('disappearTimer');
      const timer = parseInt(select.value) || 0;
      console.log('[Disappear] Timer changed to:', timer, 'ms');
    }

    function getDisappearSettings() {
      // Always read directly from DOM to get current values
      const select = document.getElementById('disappearTimer');
      const checkbox = document.getElementById('expiresAfterView');
      const timerValue = select ? parseInt(select.value) || 0 : 0;
      const afterView = checkbox ? checkbox.checked : false;
      
      console.log('[Disappear] Sending with timer:', timerValue, 'afterView:', afterView);
      
      return {
        selfDestructAfter: timerValue > 0 ? timerValue : undefined,
        expiresAfterView: afterView
      };
    }

    function formatTimeRemaining(expiresAt) {
      const now = Date.now();
      const remaining = expiresAt - now;
      
      if (remaining <= 0) return 'Expired';
      
      if (remaining < 60000) {
        return Math.ceil(remaining / 1000) + 's';
      } else if (remaining < 3600000) {
        return Math.ceil(remaining / 60000) + 'm';
      } else if (remaining < 86400000) {
        return Math.ceil(remaining / 3600000) + 'h';
      } else {
        return Math.ceil(remaining / 86400000) + 'd';
      }
    }

    async function deleteMessage(messageId) {
      if (!confirm('Delete this message for everyone?')) return;
      
      try {
        const response = await fetch(`/api/messages/${messageId}`, {
          method: 'DELETE',
          headers: WalletAuth.getAuthHeaders()
        });
        
        const data = await response.json();
        if (data.success) {
          // Refresh messages
          if (currentConversationId) {
            await loadMessages(currentConversationId);
          } else if (currentGroupId) {
            await loadGroupMessages(currentGroupId);
          }
        } else {
          alert('Failed to delete: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Delete message error:', error);
        alert('Failed to delete message');
      }
    }

    async function markMessageViewed(messageId) {
      try {
        await fetch(`/api/messages/${messageId}/viewed`, {
          method: 'POST',
          headers: WalletAuth.getAuthHeaders()
        });
      } catch (error) {
        console.error('Mark viewed error:', error);
      }
    }

    async function openConversationWithItem(recipientId, itemId) {
      currentRecipientId = recipientId;
      currentRecipientPublicKey = recipientId;
      currentItemId = itemId;
      
      // Generate conversation ID
      const wallet = WalletAuth.getWallet();
      const sorted = [wallet.publicKey, recipientId].sort();
      const response = await fetch(`/api/registry/item/${itemId}`);
      const itemData = await response.json();
      
      document.getElementById('chatItemContext').textContent = 
        `About: ${itemData.item?.metadata?.name || itemId}`;
      
      // Use the item-specific conversation
      const convId = await generateConversationId(wallet.publicKey, recipientId, itemId);
      currentConversationId = convId;
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      document.getElementById('chatParticipantName').textContent = 'Item Owner';
      
      await loadMessages(convId);
      
      // Stop inbox polling, start message polling
      stopInboxPolling();
      startMessagePolling();
    }

    async function generateConversationId(participant1, participant2, itemId = null) {
      const p1 = participant1.toLowerCase();
      const p2 = participant2.toLowerCase();
      const sorted = [p1, p2].sort();
      const base = `${sorted[0]}:${sorted[1]}${itemId ? ':' + itemId : ''}`;
      const encoder = new TextEncoder();
      const digest = await sha256Bytes(encoder.encode(base));
      const hashArray = Array.from(digest);
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 32);
    }

    let encryptionInitPromise = null;

    function getServiceAccountId() {
      const id = String(localStorage.getItem('autho_account_id') || '').trim();
      if (id) return id;
      const wallet = WalletAuth.getWallet();
      return wallet?.publicKey || wallet?.identityAddress || wallet?.paymentAddress || '';
    }

    async function ensureEncryptionInitialized() {
      if (myEncryptionKeyPair) return true;

      if (!encryptionInitPromise) {
        encryptionInitPromise = (async () => {
          // Use messaging keys from sessionStorage (set during login)
          let messagingPrivateKey = sessionStorage.getItem('autho_messaging_privateKey');
          if (!messagingPrivateKey && typeof WalletAuth.ensureMessagingKeys === 'function') {
            try {
              await WalletAuth.ensureMessagingKeys();
            } catch {}
            messagingPrivateKey = sessionStorage.getItem('autho_messaging_privateKey');
          }
          if (!messagingPrivateKey) {
            throw new Error('Messaging key not found - please log in again');
          }
          myPrivateKey = messagingPrivateKey;
          // Use the robust initialization with nacl waiting and retries
          myEncryptionKeyPair = await initializeEncryption(myPrivateKey);
          await publishMyEncryptionPublicKey();
          return myEncryptionKeyPair;
        })();
      }

      try {
        await encryptionInitPromise;
        return !!myEncryptionKeyPair;
      } catch (e) {
        console.error('Encryption init failed:', e);
        encryptionInitPromise = null; // Reset so we can retry
        return false;
      }
    }

    async function loadMessages(conversationId) {
      const container = document.getElementById('chatMessages');
      container.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
      
      try {
        const response = await fetch(`/api/messages/conversation/${conversationId}`, {
          headers: WalletAuth.getAuthHeaders()
        });
        const data = await response.json();

        if (data.success) {
          renderMessages(data.messages);
        }
      } catch (error) {
        console.error('Failed to load messages:', error);
        container.innerHTML = '<div style="text-align:center;color:#888;">Failed to load messages</div>';
      }
    }

    function renderMessages(messages) {
      const container = document.getElementById('chatMessages');
      const wallet = WalletAuth.getWallet();
      
      if (messages.length === 0) {
        container.innerHTML = `
          <div style="text-align:center;color:#888;padding:2rem;">
            Start the conversation by sending a message
          </div>
        `;
        return;
      }

      // Track which messages need to be marked as viewed
      const messagesToMarkViewed = [];
      
      container.innerHTML = messages.map(msg => {
        const isSent = msg.senderId === wallet.publicKey;
        const timeStr = new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const expiresIn = formatTimeUntil(msg.expiresAt);
        
        // Mark received messages with expiresAfterView as viewed
        if (!isSent && msg.expiresAfterView && !msg.viewedAt) {
          messagesToMarkViewed.push(msg.messageId);
        }
        
        // Decrypt message (in production, use actual decryption)
        let decryptedText = '[Encrypted]';
        try {
          // For now, show placeholder - real decryption would happen client-side
          decryptedText = decryptMessage(msg.encryptedContent);
        } catch (e) {
          decryptedText = '[Could not decrypt]';
        }
        
        // Show disappearing indicator for expiresAfterView messages
        const disappearIcon = msg.expiresAfterView ? 'üëÅÔ∏è ' : '';
        
        return `
          <div class="message-bubble ${isSent ? 'sent' : 'received'}">
            <div class="message-text">${escapeHtml(decryptedText)}</div>
            <div class="message-meta">
              ${disappearIcon}${timeStr}
              <span class="message-expires">‚Ä¢ expires ${expiresIn}</span>
            </div>
          </div>
        `;
      }).join('');
      
      // Scroll to bottom
      container.scrollTop = container.scrollHeight;
      
      // Mark viewed messages (fire-and-forget, don't await)
      messagesToMarkViewed.forEach(messageId => {
        markMessageViewed(messageId);
      });
    }

    function decryptMessage(encryptedContent, senderId) {
      // Try to decrypt E2E encrypted message
      try {
        const parsed = JSON.parse(encryptedContent);
        
        // Check for v1 encrypted format
        if (parsed.v === 1 && parsed.n && parsed.c && parsed.s) {
          // This is encrypted - need async decryption
          // Return marker for async handling
          return { encrypted: true, data: encryptedContent, senderId };
        }
        
        // Legacy unencrypted format
        if (parsed.type && parsed.type !== 'text') {
          return JSON.stringify(parsed);
        }
        if (parsed.content) return parsed.content;
      } catch (e) {}
      return encryptedContent;
    }

    // Async decrypt for rendering
    async function decryptMessageAsync(encryptedContent, senderId) {
      try {
        const parsed = JSON.parse(encryptedContent);
        
        // Check for v1 or v2 encrypted format
        if ((parsed.v === 1 || parsed.v === 2) && parsed.n && parsed.c) {
          const ok = await ensureEncryptionInitialized();
          if (!ok || !myEncryptionKeyPair) return '[Could not decrypt]';
          const decrypted = await decryptFromSender(encryptedContent, senderId);
          if (decrypted) {
            return decrypted;
          }
          return '[Could not decrypt]';
        }
        
        // Legacy unencrypted format
        if (parsed.type && parsed.type !== 'text') {
          return JSON.stringify(parsed);
        }
        if (parsed.content) return parsed.content;
      } catch (e) {}
      return encryptedContent;
    }

    async function sendMessage() {
      // Route to group message if in group chat
      if (currentGroupId) {
        return sendGroupMessage();
      }
      
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      if (!text || !currentRecipientId) return;

      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;
      
      try {
        // Create message envelope
        const messageEnvelope = JSON.stringify({
          type: 'text',
          content: text,
          timestamp: Date.now()
        });
        
        if (!await ensureEncryptionInitialized()) {
          WalletAuth.lock();
          alert('Encryption not initialized. Please log in again.');
          WalletAuth.requireAuth();
          console.error('SECURITY: Attempted to send message without encryption keys');
          return;
        }
        
        // E2E encrypt the message for recipient
        const encryptedForRecipient = await encryptForRecipient(messageEnvelope, currentRecipientId);
        // Also encrypt for self (so we can read our own sent messages)
        const wallet = WalletAuth.getWallet();
        const encryptedForSender = await encryptForEncryptionPublicKey(messageEnvelope, myEncryptionKeyPair.publicKey);
        
        // Get disappearing message settings
        const disappearSettings = getDisappearSettings();
        
        const response = await fetch('/api/messages/send', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({
            recipientId: currentRecipientId,
            encryptedContent: encryptedForRecipient,
            encryptedForSender: encryptedForSender,
            itemId: currentItemId || undefined,
            conversationId: currentConversationId || undefined,
            mediaType: 'text',
            selfDestructAfter: disappearSettings.selfDestructAfter,
            expiresAfterView: disappearSettings.expiresAfterView
          })
        });
        
        const data = await response.json();
        if (data.success) {
          input.value = '';
          if (data.conversationId) {
            currentConversationId = data.conversationId;
          }
          // Reload messages to show the new one
          await loadMessages(currentConversationId);
          // Refresh inbox list so you can see the conversation immediately
          loadConversations();
        } else {
          alert(data.error || 'Failed to send message');
        }
      } catch (error) {
        console.error('Send error:', error);
        const errorMsg = error?.message || '';
        if (errorMsg.includes('recipient') || errorMsg.includes('Recipient') || errorMsg.includes('not found')) {
          alert('Cannot send: The recipient has not set up messaging yet. Ask them to log in first.');
        } else if (errorMsg.includes('not initialized')) {
          alert('Encryption error. Please refresh and try again.');
        } else {
          alert('Failed to send message: ' + errorMsg);
        }
      } finally {
        sendBtn.disabled = false;
      }
    }

    function showInbox() {
      document.getElementById('chatView').classList.remove('active');
      document.getElementById('inboxView').style.display = 'block';
      currentConversationId = null;
      currentRecipientId = null;
      currentGroupId = null;
      
      // Stop message polling, start inbox polling
      stopMessagePolling();
      stopGroupMessagePolling();
      startInboxPolling();
      
      loadConversations();
    }

    function startConversation(contactId) {
      openConversation(null, contactId);
    }

    function formatTimeAgo(timestamp) {
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return 'now';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      if (seconds < 86400) return Math.floor(seconds / 3600) + 'h';
      return Math.floor(seconds / 86400) + 'd';
    }

    function formatTimeUntil(timestamp) {
      const seconds = Math.floor((timestamp - Date.now()) / 1000);
      if (seconds < 0) return 'expired';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      if (seconds < 86400) return Math.floor(seconds / 3600) + 'h';
      return Math.floor(seconds / 86400) + 'd';
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ============================================================
    // CONTACT SHARING FUNCTIONS
    // ============================================================

    function showShareModal() {
      const wallet = WalletAuth.getWallet();
      if (!wallet) return;
      
      // Generate shareable link
      const baseUrl = window.location.origin;
      const shareUrl = `${baseUrl}/mobile-messages.html?contact=${wallet.publicKey}`;
      document.getElementById('shareLink').value = shareUrl;
      
      // Generate QR code using qrcodejs library (same as mobile-verify.html)
      const qrContainer = document.getElementById('qrContainer');
      qrContainer.innerHTML = '';
      
      try {
        if (typeof QRCode !== 'function') {
          qrContainer.innerHTML = '<div style="color:#ff6b6b;padding:20px;">QR library not available</div>';
          return;
        }
        new QRCode(qrContainer, {
          text: shareUrl,
          width: 200,
          height: 200,
          correctLevel: QRCode.CorrectLevel.M
        });
      } catch (e) {
        console.error('QR generation error:', e);
        qrContainer.innerHTML = '<div style="color:#ff6b6b;padding:20px;">QR generation failed</div>';
      }
      
      document.getElementById('shareModal').style.display = 'flex';
    }

    function showAddContactModal() {
      document.getElementById('addContactInput').value = '';
      document.getElementById('addContactModal').style.display = 'flex';
    }

    // QR Scanner state
    let qrScannerStream = null;
    let qrScannerActive = false;

    async function toggleQrScanner() {
      if (qrScannerActive) {
        stopQrScanner();
      } else {
        await startQrScanner();
      }
    }

    async function startQrScanner() {
      const container = document.getElementById('qrScannerContainer');
      const video = document.getElementById('qrScannerVideo');
      const status = document.getElementById('qrScannerStatus');
      const btn = document.getElementById('scanQrBtn');
      
      try {
        qrScannerStream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'environment' } 
        });
        video.srcObject = qrScannerStream;
        await video.play();
        
        container.style.display = 'block';
        btn.textContent = '‚úï Stop Scanner';
        btn.style.background = '#c0392b';
        qrScannerActive = true;
        status.textContent = 'Point camera at QR code...';
        
        // Start scanning
        scanQrCode(video, status);
      } catch (e) {
        console.error('Camera error:', e);
        status.textContent = 'Could not access camera';
        alert('Could not access camera. Please grant permission.');
      }
    }

    function stopQrScanner() {
      const container = document.getElementById('qrScannerContainer');
      const video = document.getElementById('qrScannerVideo');
      const btn = document.getElementById('scanQrBtn');
      
      if (qrScannerStream) {
        qrScannerStream.getTracks().forEach(t => t.stop());
        qrScannerStream = null;
      }
      video.srcObject = null;
      container.style.display = 'none';
      btn.textContent = 'üì∑ Scan QR Code';
      btn.style.background = '#333';
      qrScannerActive = false;
    }

    function scanQrCode(video, status) {
      if (!qrScannerActive) return;
      
      // Use canvas to capture frame and analyze
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth || 320;
      canvas.height = video.videoHeight || 240;
      
      const scan = () => {
        if (!qrScannerActive) return;
        
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // Use jsQR library if available, otherwise try BarcodeDetector API
        if (typeof jsQR !== 'undefined') {
          const code = jsQR(imageData.data, canvas.width, canvas.height);
          if (code && code.data) {
            handleQrResult(code.data);
            return;
          }
        } else if ('BarcodeDetector' in window) {
          const detector = new BarcodeDetector({ formats: ['qr_code'] });
          detector.detect(canvas).then(barcodes => {
            if (barcodes.length > 0) {
              handleQrResult(barcodes[0].rawValue);
              return;
            }
          }).catch(() => {});
        }
        
        // Continue scanning
        requestAnimationFrame(scan);
      };
      
      requestAnimationFrame(scan);
    }

    function handleQrResult(data) {
      console.log('QR scanned:', data);
      
      // Stop scanner FIRST and ensure camera is fully released
      stopQrScanner();
      
      // Extract contact ID from scanned data
      let contactId = data;
      if (data.includes('contact=')) {
        const match = data.match(/contact=([^&]+)/);
        if (match) contactId = match[1];
      } else if (data.includes('/m/messages?')) {
        try {
          const url = new URL(data);
          contactId = url.searchParams.get('contact') || data;
        } catch {}
      }
      
      // Close modal and add contact (don't auto-open conversation to avoid camera conflicts)
      closeModals();
      
      if (contactId) {
        // Just add contact to list, don't open conversation immediately
        addContactOnly(contactId);
      }
    }
    
    async function addContactOnly(contactId) {
      const wallet = WalletAuth.getWallet();
      if (!wallet || contactId === wallet.publicKey) {
        alert("You can't add yourself as a contact");
        return;
      }
      
      // Always save to localStorage first (backup)
      addLocalContact(contactId);
      
      try {
        const res = await fetch('/api/messages/contacts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ contactId: contactId })
        });
        
        if (res.ok) {
          alert('Contact added! Tap their name in the list to start chatting.');
          loadContacts(); // Refresh contacts list
        } else {
          const data = await res.json().catch(() => ({}));
          alert('Failed to add contact: ' + (data.error || 'Unknown error'));
        }
      } catch (e) {
        console.error('Add contact error:', e);
        alert('Contact saved locally. Will sync when server is available.');
      }
    }

    function closeModals() {
      stopQrScanner();
      document.getElementById('shareModal').style.display = 'none';
      document.getElementById('addContactModal').style.display = 'none';
      document.getElementById('createGroupModal').style.display = 'none';
      document.getElementById('manageGroupModal').style.display = 'none';
    }

    function copyShareLink() {
      const input = document.getElementById('shareLink');
      input.select();
      navigator.clipboard.writeText(input.value).then(() => {
        const btn = input.nextElementSibling;
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy', 2000);
      });
    }

    function addContactFromInput() {
      const input = document.getElementById('addContactInput').value.trim();
      if (!input) return;
      
      // Extract accountId from input (could be full URL or just the ID)
      let contactId = input;
      
      // Check if it's a URL with contact parameter
      if (input.includes('contact=')) {
        const match = input.match(/contact=([^&]+)/);
        if (match) contactId = match[1];
      } else if (input.includes('/m/messages?')) {
        const url = new URL(input);
        contactId = url.searchParams.get('contact') || input;
      }
      
      if (contactId) {
        addContactAndStartChat(contactId);
        closeModals();
      }
    }

    async function addContactAndStartChat(contactId) {
      const wallet = WalletAuth.getWallet();
      if (!wallet || contactId === wallet.publicKey) {
        alert("You can't add yourself as a contact");
        return;
      }
      
      // Add to contacts via API
      try {
        await fetch('/api/messages/contacts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ contactId })
        });
      } catch (e) {
        console.log('Contact add request:', e);
      }
      
      // Clear URL parameters
      window.history.replaceState({}, '', '/m/messages');
      
      // Start conversation with the contact
      currentRecipientId = contactId;
      currentRecipientPublicKey = contactId;
      currentItemId = null;
      currentConversationId = null;
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      document.getElementById('chatParticipantName').textContent = contactId.substring(0, 12) + '...';
      document.getElementById('chatItemContext').textContent = '';
      
      // Load any existing messages (might be empty for new contact)
      const convId = await generateConversationId(wallet.publicKey, contactId, null);
      currentConversationId = convId;
      await loadMessages(convId);
      
      // Refresh contacts
      loadContacts();
    }

    async function addCurrentRecipientToContacts() {
      if (!currentRecipientId) return;
      
      const btn = document.getElementById('addContactChatBtn');
      btn.disabled = true;
      
      try {
        const response = await fetch('/api/messages/contacts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ contactId: currentRecipientId })
        });
        
        const data = await response.json();
        if (data.success) {
          btn.textContent = '‚úì Added';
          btn.classList.add('added');
          loadContacts();
        } else {
          alert(data.error || 'Failed to add contact');
        }
      } catch (e) {
        console.error('Add contact error:', e);
      } finally {
        btn.disabled = false;
      }
    }

    function updateAddContactButton(isAlreadyContact) {
      const btn = document.getElementById('addContactChatBtn');
      if (isAlreadyContact) {
        btn.textContent = '‚úì Contact';
        btn.classList.add('added');
      } else {
        btn.textContent = '‚ûï Add';
        btn.classList.remove('added');
      }
    }

    // ============================================================
    // MEDIA MESSAGING FUNCTIONS
    // ============================================================
    
    let pendingMedia = null; // { type: 'image'|'video'|'audio', data: base64, name: string, size: number }
    let audioRecorder = null;
    let audioChunks = [];
    let audioTimerInterval = null;
    let audioStartTime = null;
    const MAX_AUDIO_SECONDS = 30;
    const MAX_VIDEO_SECONDS = 15;
    
    // Premium file tiers (size in bytes, cost in sats)
    const FILE_TIERS = {
      free: { maxSize: 1 * 1024 * 1024, cost: 0, label: '1 MB' },           // 1MB free
      basic: { maxSize: 25 * 1024 * 1024, cost: 500, label: '25 MB' },      // 25MB for 500 sats
      premium: { maxSize: 100 * 1024 * 1024, cost: 2000, label: '100 MB' }, // 100MB for 2000 sats
      enterprise: { maxSize: 1024 * 1024 * 1024, cost: 10000, label: '1 GB' }, // 1GB for 10000 sats
    };
    
    let selectedFileTier = 'free';
    const MAX_IMAGE_SIZE = 500 * 1024; // 500KB after compression (free tier)
    const MAX_VIDEO_SIZE = FILE_TIERS.free.maxSize; // Dynamic based on tier

    // Get max file size based on balance
    async function getMaxFileSizeForBalance() {
      await fetchServiceBalance();
      
      if (serviceBalance >= FILE_TIERS.enterprise.cost) {
        return { tier: 'enterprise', ...FILE_TIERS.enterprise };
      } else if (serviceBalance >= FILE_TIERS.premium.cost) {
        return { tier: 'premium', ...FILE_TIERS.premium };
      } else if (serviceBalance >= FILE_TIERS.basic.cost) {
        return { tier: 'basic', ...FILE_TIERS.basic };
      }
      return { tier: 'free', ...FILE_TIERS.free };
    }

    // Check if file needs premium tier and handle payment
    async function checkFileTierAndPay(fileSize, fileName) {
      const tierInfo = await getMaxFileSizeForBalance();
      
      // Determine required tier
      let requiredTier = 'free';
      let requiredCost = 0;
      
      if (fileSize > FILE_TIERS.enterprise.maxSize) {
        alert('File too large. Maximum size is 1 GB.');
        return null;
      } else if (fileSize > FILE_TIERS.premium.maxSize) {
        requiredTier = 'enterprise';
        requiredCost = FILE_TIERS.enterprise.cost;
      } else if (fileSize > FILE_TIERS.basic.maxSize) {
        requiredTier = 'premium';
        requiredCost = FILE_TIERS.premium.cost;
      } else if (fileSize > FILE_TIERS.free.maxSize) {
        requiredTier = 'basic';
        requiredCost = FILE_TIERS.basic.cost;
      }
      
      // If free tier is sufficient, no payment needed
      if (requiredTier === 'free') {
        return { approved: true, cost: 0 };
      }
      
      // Check if user has sufficient balance
      if (serviceBalance < requiredCost) {
        const sizeMB = (fileSize / 1024 / 1024).toFixed(1);
        alert(`File is ${sizeMB} MB. You need ${requiredCost} sats in your service balance to send files this large.\n\nYour balance: ${serviceBalance} sats`);
        showInsufficientBalanceModal(requiredCost);
        return null;
      }
      
      // Confirm payment
      const tierLabel = FILE_TIERS[requiredTier].label;
      if (!confirm(`Sending "${fileName}" (${(fileSize / 1024 / 1024).toFixed(1)} MB) requires the ${tierLabel} tier.\n\nThis will deduct ${requiredCost} sats from your service balance.\n\nContinue?`)) {
        return null;
      }
      
      // Deduct balance
      try {
        const accountId = getServiceAccountId();
        
        const res = await fetch('/api/service/premium/file-transfer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...WalletAuth.getAuthHeaders() },
          body: JSON.stringify({
            accountId,
            tier: requiredTier,
            fileSize,
            fileName,
          }),
        });
        
        const data = await res.json();
        
        if (data.success) {
          serviceBalance = data.newBalance || (serviceBalance - requiredCost);
          // Update the balance display in the header immediately
          const balanceEl = document.getElementById('msgServiceBalance');
          if (balanceEl) balanceEl.textContent = serviceBalance.toLocaleString();
          return { approved: true, cost: requiredCost, tier: requiredTier };
        } else {
          alert(data.error || 'Failed to process file transfer payment');
          return null;
        }
      } catch (e) {
        console.error('File tier payment error:', e);
        alert('Error processing payment: ' + e.message);
        return null;
      }
    }

    let pendingPhotoFile = null;
    let pendingPhotoCompressed = null;
    
    async function handlePhotoSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      try {
        // For photos, we compress so tier check is usually not needed
        const compressed = await compressImage(file, MAX_IMAGE_SIZE);
        
        // If original is large, show quality choice modal
        if (file.size > FILE_TIERS.free.maxSize) {
          pendingPhotoFile = file;
          pendingPhotoCompressed = compressed;
          showPhotoQualityModal(file, compressed);
          event.target.value = '';
          return;
        }
        
        // Small file - just use compressed
        pendingMedia = {
          type: 'image',
          data: compressed.data,
          name: file.name || 'Photo',
          size: compressed.size
        };
        showMediaPreview();
      } catch (e) {
        console.error('Photo processing error:', e);
        alert('Failed to process photo');
      }
      event.target.value = ''; // Reset input
    }
    
    function showPhotoQualityModal(file, compressed) {
      const originalMB = (file.size / 1024 / 1024).toFixed(1);
      const compressedKB = Math.round(compressed.size / 1024);
      
      // Determine cost for original
      let originalCost = 0;
      if (file.size > FILE_TIERS.premium.maxSize) {
        originalCost = FILE_TIERS.enterprise.cost;
      } else if (file.size > FILE_TIERS.basic.maxSize) {
        originalCost = FILE_TIERS.premium.cost;
      } else if (file.size > FILE_TIERS.free.maxSize) {
        originalCost = FILE_TIERS.basic.cost;
      }
      
      const modal = document.createElement('div');
      modal.id = 'photoQualityModal';
      modal.className = 'modal active';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 340px;">
          <h3 style="margin-bottom: 12px;">üì∑ Photo Quality</h3>
          <p style="font-size: 14px; color: #666; margin-bottom: 16px;">
            Original: ${originalMB} MB<br>
            Compressed: ${compressedKB} KB
          </p>
          <button id="sendCompressedBtn" class="btn btn-primary" style="width: 100%; margin-bottom: 10px; padding: 14px;">
            ‚úì Send Compressed (FREE)
          </button>
          <button id="sendOriginalBtn" class="btn btn-secondary" style="width: 100%; margin-bottom: 10px; padding: 14px;">
            Send Original (${originalCost} sats)
          </button>
          <button id="cancelPhotoBtn" class="btn" style="width: 100%; padding: 12px; background: #f5f5f5; color: #666;">
            Cancel
          </button>
        </div>
      `;
      document.body.appendChild(modal);
      
      document.getElementById('sendCompressedBtn').onclick = () => {
        closePhotoQualityModal();
        pendingMedia = {
          type: 'image',
          data: pendingPhotoCompressed.data,
          name: pendingPhotoFile.name || 'Photo',
          size: pendingPhotoCompressed.size
        };
        showMediaPreview();
        pendingPhotoFile = null;
        pendingPhotoCompressed = null;
      };
      
      document.getElementById('sendOriginalBtn').onclick = async () => {
        closePhotoQualityModal();
        const tierResult = await checkFileTierAndPay(pendingPhotoFile.size, pendingPhotoFile.name);
        if (!tierResult) {
          pendingPhotoFile = null;
          pendingPhotoCompressed = null;
          return;
        }
        const data = await fileToBase64(pendingPhotoFile);
        pendingMedia = {
          type: 'image',
          data: data,
          name: pendingPhotoFile.name || 'Photo (Original)',
          size: pendingPhotoFile.size,
          tierCost: tierResult.cost
        };
        showMediaPreview();
        pendingPhotoFile = null;
        pendingPhotoCompressed = null;
      };
      
      document.getElementById('cancelPhotoBtn').onclick = () => {
        closePhotoQualityModal();
        pendingPhotoFile = null;
        pendingPhotoCompressed = null;
      };
    }
    
    function closePhotoQualityModal() {
      const modal = document.getElementById('photoQualityModal');
      if (modal) modal.remove();
    }

    async function handleVideoSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Check file tier and process payment if needed
      const tierResult = await checkFileTierAndPay(file.size, file.name);
      if (!tierResult) {
        event.target.value = '';
        return;
      }
      
      try {
        const data = await fileToBase64(file);
        pendingMedia = {
          type: 'video',
          data: data,
          name: file.name || 'Video',
          size: file.size,
          tierCost: tierResult.cost
        };
        showMediaPreview();
      } catch (e) {
        console.error('Video processing error:', e);
        alert('Failed to process video');
      }
      event.target.value = '';
    }

    async function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;

      const tierResult = await checkFileTierAndPay(file.size, file.name);
      if (!tierResult) {
        event.target.value = '';
        return;
      }

      try {
        const data = await fileToBase64(file);
        pendingMedia = {
          type: 'file',
          data,
          name: file.name || 'File',
          size: file.size,
          mime: file.type || 'application/octet-stream',
          tierCost: tierResult.cost,
        };
        showMediaPreview();
      } catch (e) {
        console.error('File processing error:', e);
        alert('Failed to process file');
      }

      event.target.value = '';
    }

    async function compressImage(file, maxSize) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;
            
            // Scale down if needed
            const maxDim = 1200;
            if (width > maxDim || height > maxDim) {
              if (width > height) {
                height = Math.round(height * maxDim / width);
                width = maxDim;
              } else {
                width = Math.round(width * maxDim / height);
                height = maxDim;
              }
            }
            
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            // Try different quality levels
            let quality = 0.8;
            let data = canvas.toDataURL('image/jpeg', quality);
            
            while (data.length > maxSize * 1.37 && quality > 0.1) { // base64 is ~37% larger
              quality -= 0.1;
              data = canvas.toDataURL('image/jpeg', quality);
            }
            
            resolve({
              data: data,
              size: Math.round(data.length * 0.73) // Approximate actual size
            });
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    // Detect iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    
    // Convert base64 data URL to Blob URL for better mobile video compatibility
    function base64ToBlobUrl(base64DataUrl) {
      try {
        const parts = base64DataUrl.split(',');
        const mimeMatch = parts[0].match(/:(.*?);/);
        const mime = mimeMatch ? mimeMatch[1] : 'video/mp4';
        const bstr = atob(parts[1]);
        let n = bstr.length;
        const u8arr = new Uint8Array(n);
        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }
        const blob = new Blob([u8arr], { type: mime });
        return { url: URL.createObjectURL(blob), mime: mime };
      } catch (e) {
        console.error('Failed to convert base64 to blob:', e);
        return { url: base64DataUrl, mime: 'video/mp4' };
      }
    }
    
    // Track blob URLs and base64 for cleanup/fallback
    const videoBlobUrls = new Map();
    const videoBase64Data = new Map();

    function showMediaPreview() {
      if (!pendingMedia) return;
      
      const preview = document.getElementById('mediaPreview');
      const thumb = document.getElementById('mediaPreviewThumb');
      const name = document.getElementById('mediaPreviewName');
      const size = document.getElementById('mediaPreviewSize');
      
      name.textContent = pendingMedia.type === 'file'
        ? (pendingMedia.name || 'File')
        : pendingMedia.type.charAt(0).toUpperCase() + pendingMedia.type.slice(1);
      size.textContent = formatFileSize(pendingMedia.size);
      
      if (pendingMedia.type === 'image') {
        thumb.innerHTML = `<img src="${pendingMedia.data}" alt="Preview">`;
      } else if (pendingMedia.type === 'video') {
        thumb.innerHTML = `<video src="${pendingMedia.data}" muted></video>`;
      } else if (pendingMedia.type === 'audio') {
        thumb.innerHTML = `<div style="font-size:2rem">üéµ</div>`;
      } else if (pendingMedia.type === 'file') {
        thumb.innerHTML = `<div style="font-size:2rem">üìé</div>`;
      }
      
      preview.classList.add('active');
    }

    function clearMediaPreview() {
      pendingMedia = null;
      document.getElementById('mediaPreview').classList.remove('active');
      document.getElementById('mediaPreviewThumb').innerHTML = '';
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
      return (bytes / 1024 / 1024).toFixed(1) + ' MB';
    }

    // Audio Recording - detect best supported format for iOS/Android compatibility
    function getSupportedAudioMimeType() {
      const types = [
        'audio/mp4',           // iOS Safari preferred
        'audio/aac',           // iOS fallback
        'audio/webm;codecs=opus', // Chrome/Firefox preferred
        'audio/webm',          // Generic WebM
        'audio/ogg;codecs=opus',
        ''                     // Let browser choose default
      ];
      for (const type of types) {
        if (type === '' || MediaRecorder.isTypeSupported(type)) {
          return type;
        }
      }
      return '';
    }

    let audioMimeType = '';

    async function toggleAudioRecording() {
      if (audioRecorder && audioRecorder.state === 'recording') {
        // Already recording - stop will be handled by sendAudioRecording
        return;
      }
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Use iOS-compatible format if available
        audioMimeType = getSupportedAudioMimeType();
        const options = audioMimeType ? { mimeType: audioMimeType } : {};
        
        audioRecorder = new MediaRecorder(stream, options);
        audioChunks = [];
        
        console.log('Recording with MIME type:', audioRecorder.mimeType);
        
        audioRecorder.ondataavailable = (e) => {
          audioChunks.push(e.data);
        };
        
        audioRecorder.onstop = () => {
          stream.getTracks().forEach(t => t.stop());
        };
        
        audioRecorder.start();
        audioStartTime = Date.now();
        
        // Show recorder UI
        document.getElementById('audioRecorder').classList.add('active');
        document.getElementById('audioBtn').classList.add('recording');
        
        // Start timer
        audioTimerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - audioStartTime) / 1000);
          document.getElementById('audioTimer').textContent = 
            `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
          
          // Auto-stop at max duration
          if (elapsed >= MAX_AUDIO_SECONDS) {
            sendAudioRecording();
          }
        }, 100);
        
      } catch (e) {
        console.error('Audio recording error:', e);
        alert('Could not access microphone. Please grant permission.');
      }
    }

    function cancelAudioRecording() {
      if (audioRecorder && audioRecorder.state === 'recording') {
        audioRecorder.stop();
      }
      clearAudioRecorder();
    }

    function clearAudioRecorder() {
      if (audioTimerInterval) {
        clearInterval(audioTimerInterval);
        audioTimerInterval = null;
      }
      audioRecorder = null;
      audioChunks = [];
      audioStartTime = null;
      document.getElementById('audioRecorder').classList.remove('active');
      document.getElementById('audioBtn').classList.remove('recording');
      document.getElementById('audioTimer').textContent = '0:00';
    }

    async function sendAudioRecording() {
      if (!audioRecorder || audioRecorder.state !== 'recording') return;
      
      audioRecorder.stop();
      
      // Wait for data to be available
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Use the actual MIME type from the recorder (handles iOS MP4 vs Chrome WebM)
      const actualMimeType = audioRecorder?.mimeType || audioMimeType || 'audio/webm';
      const blob = new Blob(audioChunks, { type: actualMimeType });
      console.log('Audio blob created with type:', actualMimeType);
      const data = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
      
      pendingMedia = {
        type: 'audio',
        data: data,
        name: 'Voice message',
        size: blob.size
      };
      
      clearAudioRecorder();
      
      // Send immediately
      await sendMediaMessage();
    }

    async function sendMediaMessage() {
      if (!pendingMedia || !currentRecipientId) return;
      
      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;
      
      try {
        // Create media envelope
        const mediaEnvelope = JSON.stringify({
          type: pendingMedia.type,
          content: pendingMedia.data,
          name: pendingMedia.name,
          size: pendingMedia.size,
          mime: pendingMedia.mime,
          timestamp: Date.now()
        });
        
        if (!await ensureEncryptionInitialized()) {
          alert('Encryption not initialized. Please refresh the page and try again.');
          console.error('SECURITY: Attempted to send media without encryption keys');
          return;
        }
        
        // E2E encrypt the media for recipient
        const encryptedForRecipient = await encryptForRecipient(mediaEnvelope, currentRecipientId);
        // Also encrypt for self
        const wallet = WalletAuth.getWallet();
        const encryptedForSender = await encryptForEncryptionPublicKey(mediaEnvelope, myEncryptionKeyPair.publicKey);
        
        // Get disappearing message settings
        const disappearSettings = getDisappearSettings();
        
        const response = await fetch('/api/messages/send', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({
            recipientId: currentRecipientId,
            encryptedContent: encryptedForRecipient,
            encryptedForSender: encryptedForSender,
            itemId: currentItemId || undefined,
            conversationId: currentConversationId || undefined,
            // Include media type and disappearing settings
            mediaType: pendingMedia.type,
            selfDestructAfter: disappearSettings.selfDestructAfter,
            expiresAfterView: disappearSettings.expiresAfterView
          })
        });
        
        const data = await response.json();
        if (data.success) {
          clearMediaPreview();
          if (data.conversationId) {
            currentConversationId = data.conversationId;
          }
          await loadMessages(currentConversationId);
          loadConversations();
        } else {
          alert(data.error || 'Failed to send media');
        }
      } catch (error) {
        console.error('Send media error:', error);
        alert('Failed to send media');
      } finally {
        sendBtn.disabled = false;
      }
    }

    // Override sendMessage to handle pending media
    const originalSendMessage = sendMessage;
    sendMessage = async function() {
      if (pendingMedia) {
        await sendMediaMessage();
      } else {
        await originalSendMessage();
      }
    };

    // ============================================================
    // PUSH-TO-TALK (WALKIE-TALKIE) FUNCTIONS
    // ============================================================
    
    let pttRecorder = null;
    let pttChunks = [];
    let pttStream = null;
    let pttActive = false;
    
    function initPushToTalk() {
      const pttBtn = document.getElementById('pttBtn');
      if (!pttBtn) return;
      
      // Mouse events (desktop)
      pttBtn.addEventListener('mousedown', startPTT);
      pttBtn.addEventListener('mouseup', stopPTT);
      pttBtn.addEventListener('mouseleave', stopPTT);
      
      // Touch events (mobile)
      pttBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        startPTT();
      });
      pttBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        stopPTT();
      });
      pttBtn.addEventListener('touchcancel', stopPTT);
    }
    
    async function startPTT() {
      if (pttActive || !currentRecipientId) return;
      
      try {
        pttStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        const mimeType = getSupportedAudioMimeType();
        const options = mimeType ? { mimeType } : {};
        
        pttRecorder = new MediaRecorder(pttStream, options);
        pttChunks = [];
        
        pttRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) pttChunks.push(e.data);
        };
        
        pttRecorder.onstop = async () => {
          // Clean up stream
          if (pttStream) {
            pttStream.getTracks().forEach(t => t.stop());
            pttStream = null;
          }
          
          // Only send if we have audio data
          if (pttChunks.length > 0) {
            await sendPTTAudio();
          }
        };
        
        pttRecorder.start();
        pttActive = true;
        
        // Show recording UI
        document.getElementById('pttBtn').classList.add('recording');
        document.getElementById('pttRecording').classList.add('active');
        
      } catch (e) {
        console.error('PTT start error:', e);
        alert('Could not access microphone');
      }
    }
    
    function stopPTT() {
      if (!pttActive || !pttRecorder) return;
      
      pttActive = false;
      document.getElementById('pttBtn').classList.remove('recording');
      document.getElementById('pttRecording').classList.remove('active');
      
      if (pttRecorder.state === 'recording') {
        pttRecorder.stop();
      }
    }
    
    async function sendPTTAudio() {
      if (pttChunks.length === 0) return;
      
      const actualMimeType = pttRecorder?.mimeType || 'audio/webm';
      const blob = new Blob(pttChunks, { type: actualMimeType });
      
      // Convert to base64
      const data = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
      
      // Set as pending media and send
      pendingMedia = {
        type: 'audio',
        data: data,
        name: 'Voice message',
        size: blob.size,
        isPTT: true // Mark as push-to-talk for auto-play
      };
      
      pttChunks = [];
      pttRecorder = null;
      
      await sendMediaMessage();
    }
    
    // Initialize PTT when DOM is ready
    document.addEventListener('DOMContentLoaded', initPushToTalk);

    // Fullscreen media viewer
    function openFullscreen(srcOrId, type) {
      const container = document.getElementById('fullscreenContent');
      if (type === 'image') {
        container.innerHTML = `<img src="${srcOrId}" alt="Fullscreen">`;
      } else if (type === 'video') {
        // srcOrId might be a video element ID - get the blob URL from our map
        const blobUrl = videoBlobUrls.get(srcOrId) || srcOrId;
        container.innerHTML = `<video src="${blobUrl}" controls autoplay playsinline webkit-playsinline></video>`;
      }
      document.getElementById('mediaFullscreen').classList.add('active');
    }

    function closeFullscreen() {
      document.getElementById('mediaFullscreen').classList.remove('active');
      document.getElementById('fullscreenContent').innerHTML = '';
    }

    // Update renderMessages to show media with async E2E decryption
    const originalRenderMessages = renderMessages;
    renderMessages = async function(messages) {
      const container = document.getElementById('chatMessages');
      const wallet = WalletAuth.getWallet();
      
      if (messages.length === 0) {
        container.innerHTML = `
          <div style="text-align:center;color:#888;padding:2rem;">
            Start the conversation by sending a message
          </div>
        `;
        return;
      }

      // Process messages with async decryption
      const processedMessages = await Promise.all(messages.map(async (msg) => {
        const isSent = msg.senderId === wallet.publicKey;
        const timeStr = new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const expiresIn = formatTimeUntil(msg.expiresAt);
        
        // Backend already returns correct encryptedContent for current user
        const contentToDecrypt = msg.encryptedContent;
        
        let content = '';
        try {
          // Async decrypt the message
          const decrypted = await decryptMessageAsync(contentToDecrypt || msg.encryptedContent, msg.senderId);
          const parsed = JSON.parse(decrypted);
          
          if (parsed.type === 'image') {
            content = `
              <div class="message-media">
                <img src="${parsed.content}" alt="Photo" onclick="openFullscreen(this.src, 'image')">
              </div>
            `;
          } else if (parsed.type === 'video') {
            // Convert base64 to Blob URL for mobile compatibility
            const videoId = 'vid_' + msg.timestamp + '_' + Math.random().toString(36).substr(2, 9);
            const blobData = base64ToBlobUrl(parsed.content);
            videoBlobUrls.set(videoId, blobData.url);
            videoBase64Data.set(videoId, parsed.content); // Keep base64 as fallback for iOS
            
            // iOS needs special handling - use source element without fragment
            if (isIOS) {
              content = `
                <div class="message-media">
                  <video id="${videoId}" controls playsinline webkit-playsinline preload="auto"
                         onclick="openFullscreen('${videoId}', 'video')">
                    <source src="${blobData.url}" type="${blobData.mime}">
                    Your browser does not support video.
                  </video>
                </div>
              `;
            } else {
              content = `
                <div class="message-media">
                  <video id="${videoId}" src="${blobData.url}#t=0.1" controls playsinline webkit-playsinline preload="metadata"
                         onclick="openFullscreen('${videoId}', 'video')"></video>
                </div>
              `;
            }
          } else if (parsed.type === 'audio') {
            content = `
              <div class="message-media">
                <audio src="${parsed.content}" controls></audio>
              </div>
            `;
          } else if (parsed.type === 'file') {
            const fileName = escapeHtml(parsed.name || 'File');
            const fileSize = parsed.size ? formatFileSize(parsed.size) : '';
            content = `
              <div class="message-media" style="padding: 0.5rem;">
                <div style="display:flex;align-items:center;gap:0.5rem;">
                  <div style="font-size:1.3rem;">üìé</div>
                  <div style="flex:1;min-width:0;">
                    <div style="font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${fileName}</div>
                    <div style="font-size:0.75rem;color:#888;">${escapeHtml(fileSize)}</div>
                  </div>
                </div>
                <div style="margin-top:0.4rem;">
                  <a href="${parsed.content}" download="${fileName}" style="color:#8b5cf6;text-decoration:underline;">Download</a>
                </div>
              </div>
            `;
          } else {
            content = `<div class="message-text">${escapeHtml(parsed.content || decrypted)}</div>`;
          }
        } catch (e) {
          // Fallback for legacy or failed decryption
          try {
            const fallback = await decryptMessageAsync(msg.encryptedContent, msg.senderId);
            content = `<div class="message-text">${escapeHtml(fallback)}</div>`;
          } catch (e2) {
            content = `<div class="message-text" style="color:#ff6b6b;">[Could not decrypt]</div>`;
          }
        }
        
        return `
          <div class="message-bubble ${isSent ? 'sent' : 'received'}" data-message-id="${msg.id || msg.messageId || ''}">
            ${content}
            <div class="message-meta">
              ${timeStr}
              <span class="message-expires">‚Ä¢ expires ${expiresIn}</span>
            </div>
          </div>
        `;
      }));

      container.innerHTML = processedMessages.join('');
      container.scrollTop = container.scrollHeight;
    };

    // ============================================================
    // ENCRYPTION INFO & PREMIUM ACTIONS
    // ============================================================

    let serviceBalance = 0;
    let selectedMessageId = null;
    let selectedMessageText = '';

    // Pricing constants (sats)
    const PRICING = {
      message_delete: 50,
      message_edit: 25,
      profile_update: 100,
      group_create: 200,
    };

    // Fetch service balance
    async function fetchServiceBalance() {
      try {
        const accountId = getServiceAccountId();
        if (!accountId) return 0;

        const res = await fetch(`/api/accounts/${accountId}/service-balance`, {
          headers: WalletAuth.getAuthHeaders(),
        });
        if (res.ok) {
          const data = await res.json();
          if (data.success) {
            serviceBalance = data.serviceBalanceSats || 0;
            // Update the service balance indicator in header
            const balanceEl = document.getElementById('msgServiceBalance');
            if (balanceEl) balanceEl.textContent = serviceBalance.toLocaleString();
            return serviceBalance;
          }
        }
      } catch (e) {
        console.error('Failed to fetch service balance:', e);
      }
      return 0;
    }
    
    // Fetch balance on page load
    fetchServiceBalance();

    // Show encryption info modal
    function showEncryptionInfo() {
      document.getElementById('encryptionModal').classList.add('active');
    }

    function closeEncryptionModal() {
      document.getElementById('encryptionModal').classList.remove('active');
    }

    // Insufficient balance modal
    function showInsufficientBalanceModal(required) {
      document.getElementById('currentBalanceDisplay').textContent = serviceBalance.toLocaleString();
      document.getElementById('requiredAmountDisplay').textContent = required.toLocaleString();
      document.getElementById('insufficientBalanceModal').classList.add('active');
    }

    function closeInsufficientBalanceModal() {
      document.getElementById('insufficientBalanceModal').classList.remove('active');
    }

    // Message context menu
    function showMessageContextMenu(event, messageId, messageText, isSent) {
      event.preventDefault();
      event.stopPropagation();
      
      if (!isSent) return; // Only sender can edit/delete
      
      selectedMessageId = messageId;
      selectedMessageText = messageText;
      
      const menu = document.getElementById('messageContextMenu');
      const x = Math.min(event.clientX, window.innerWidth - 180);
      const y = Math.min(event.clientY, window.innerHeight - 150);
      
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      menu.classList.add('active');
    }

    function hideMessageContextMenu() {
      document.getElementById('messageContextMenu').classList.remove('active');
      selectedMessageId = null;
      selectedMessageText = '';
    }

    // Close context menu when clicking elsewhere
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.message-context-menu')) {
        hideMessageContextMenu();
      }
    });

    // Copy message text
    function copyMessageText() {
      if (selectedMessageText) {
        navigator.clipboard.writeText(selectedMessageText).then(() => {
          hideMessageContextMenu();
        });
      }
    }

    // Delete message with auto-deduct
    async function deleteMessageWithPayment() {
      console.log('Delete requested for messageId:', selectedMessageId);
      
      if (!selectedMessageId) {
        alert('No message selected. Please tap on a message first.');
        return;
      }
      
      const required = PRICING.message_delete;
      await fetchServiceBalance();
      
      if (serviceBalance < required) {
        hideMessageContextMenu();
        showInsufficientBalanceModal(required);
        return;
      }
      
      // Confirm deletion
      if (!confirm(`Delete this message? This will deduct ${required} sats from your service balance.`)) {
        hideMessageContextMenu();
        return;
      }
      
      try {
        const accountId = getServiceAccountId();
        console.log('Deleting message:', { messageId: selectedMessageId, accountId });
        
        const res = await fetch('/api/service/premium/message-delete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...WalletAuth.getAuthHeaders() },
          body: JSON.stringify({
            accountId,
            messageId: selectedMessageId,
          }),
        });
        
        const data = await res.json();
        console.log('Delete response:', data);
        
        if (data.success) {
          // Remove message from UI
          const msgElements = document.querySelectorAll(`[data-message-id="${selectedMessageId}"]`);
          msgElements.forEach(el => el.remove());
          
          serviceBalance = data.newBalance || (serviceBalance - required);
          const balEl = document.getElementById('msgServiceBalance');
          if (balEl) balEl.textContent = serviceBalance.toLocaleString();
          hideMessageContextMenu();
        } else {
          alert(data.error || 'Failed to delete message');
        }
      } catch (e) {
        console.error('Delete message error:', e);
        alert('Error deleting message: ' + e.message);
      }
      
      hideMessageContextMenu();
    }

    // Edit message with auto-deduct
    async function editMessage() {
      if (!selectedMessageId) return;
      
      const required = PRICING.message_edit;
      await fetchServiceBalance();
      
      if (serviceBalance < required) {
        hideMessageContextMenu();
        showInsufficientBalanceModal(required);
        return;
      }
      
      const newText = prompt('Edit message:', selectedMessageText);
      if (!newText || newText === selectedMessageText) {
        hideMessageContextMenu();
        return;
      }
      
      try {
        const accountId = getServiceAccountId();
        
        const res = await fetch('/api/service/premium/message-edit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...WalletAuth.getAuthHeaders() },
          body: JSON.stringify({
            accountId,
            messageId: selectedMessageId,
            newContent: newText,
          }),
        });
        
        const data = await res.json();
        
        if (data.success) {
          // Update message in UI
          const msgElements = document.querySelectorAll(`[data-message-id="${selectedMessageId}"] .message-text`);
          msgElements.forEach(el => {
            el.textContent = newText;
            el.innerHTML += ' <span style="font-size:0.7em;color:#888;">(edited)</span>';
          });
          
          serviceBalance = data.newBalance || (serviceBalance - required);
          const balEl2 = document.getElementById('msgServiceBalance');
          if (balEl2) balEl2.textContent = serviceBalance.toLocaleString();
        } else {
          alert(data.error || 'Failed to edit message');
        }
      } catch (e) {
        console.error('Edit message error:', e);
        alert('Error editing message: ' + e.message);
      }
      
      hideMessageContextMenu();
    }

    // Add context menu to message bubbles
    function addContextMenuToMessages() {
      document.querySelectorAll('.message-bubble.sent').forEach(bubble => {
        if (bubble.dataset.contextMenuAdded) return;
        bubble.dataset.contextMenuAdded = 'true';

        function eventLikeFromTouch(t) {
          return {
            clientX: t.clientX,
            clientY: t.clientY,
            preventDefault() {},
            stopPropagation() {},
          };
        }
        
        bubble.addEventListener('contextmenu', (e) => {
          const messageId = bubble.dataset.messageId || bubble.closest('[data-message-id]')?.dataset.messageId;
          const textEl = bubble.querySelector('.message-text');
          const text = textEl ? textEl.textContent : '';
          showMessageContextMenu(e, messageId, text, true);
        });

        bubble.addEventListener('click', (e) => {
          if (e.target.closest('.message-media')) return;
          const messageId = bubble.dataset.messageId || bubble.closest('[data-message-id]')?.dataset.messageId;
          const textEl = bubble.querySelector('.message-text');
          const text = textEl ? textEl.textContent : '';
          showMessageContextMenu(e, messageId, text, true);
        });
        
        // Long-press for mobile
        let pressTimer;
        bubble.addEventListener('touchstart', (e) => {
          pressTimer = setTimeout(() => {
            const messageId = bubble.dataset.messageId || bubble.closest('[data-message-id]')?.dataset.messageId;
            const textEl = bubble.querySelector('.message-text');
            const text = textEl ? textEl.textContent : '';
            const touch = e.touches && e.touches[0];
            if (touch) showMessageContextMenu(eventLikeFromTouch(touch), messageId, text, true);
          }, 500);
        });
        
        bubble.addEventListener('touchend', () => clearTimeout(pressTimer));
        bubble.addEventListener('touchmove', () => clearTimeout(pressTimer));
      });
    }

    // Re-add context menus after messages render
    const originalRenderMessagesWithContext = renderMessages;
    renderMessages = async function(messages) {
      await originalRenderMessagesWithContext(messages);
      setTimeout(addContextMenuToMessages, 100);
    };

    // Initial balance fetch
    fetchServiceBalance();
  </script>
</body>
</html>
