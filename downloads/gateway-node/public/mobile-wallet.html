<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>My Wallet - Bitcoin Ownership Protocol</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <!-- Bitcoin libraries loaded via backend API to avoid CDN blocking -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      color: #ffffff;
      min-height: 100vh;
    }

    .header {
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      padding: 15px 20px;
      border-bottom: 2px solid #d4af37;
      position: sticky;
      top: 0;
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .back-btn {
      background: none;
      border: none;
      color: #d4af37;
      font-size: 24px;
      cursor: pointer;
      padding: 5px;
    }

    .header h1 {
      font-family: 'Playfair Display', serif;
      font-size: 20px;
      font-weight: 700;
      color: #d4af37;
      flex: 1;
    }

    .container {
      padding: 20px;
      max-width: 600px;
      margin: 0 auto;
    }

    .screen {
      display: none;
    }

    .screen.active {
      display: block;
    }

    .wallet-card {
      background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%);
      border-radius: 20px;
      padding: 25px;
      margin-bottom: 20px;
      color: #1a1a1a;
      box-shadow: 0 8px 25px rgba(212, 175, 55, 0.3);
    }

    .wallet-card-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
      opacity: 0.7;
    }

    .wallet-card-value {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      word-break: break-all;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.1);
      border-radius: 8px;
    }

    .btn {
      background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%);
      color: #1a1a1a;
      border: none;
      border-radius: 12px;
      padding: 15px 25px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-bottom: 10px;
      transition: all 0.3s ease;
      font-family: 'Inter', sans-serif;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn.secondary {
      background: rgba(212, 175, 55, 0.5);
      color: #1a1a1a;
      border: 2px solid rgba(212, 175, 55, 0.85);
    }

    .btn.danger {
      background: rgba(255, 87, 87, 0.2);
      color: #ff5757;
      border: 2px solid #ff5757;
    }

    .input-group {
      margin-bottom: 20px;
    }

    .input-label {
      display: block;
      font-size: 12px;
      color: #999;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .input {
      width: 100%;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(212, 175, 55, 0.3);
      border-radius: 10px;
      padding: 15px;
      color: #ffffff;
      font-size: 16px;
      font-family: 'Inter', sans-serif;
    }

    .input:focus {
      outline: none;
      border-color: #d4af37;
    }

    .textarea {
      min-height: 120px;
      font-family: 'Courier New', monospace;
      resize: vertical;
    }

    .warning-box {
      background: rgba(255, 87, 87, 0.1);
      border: 2px solid #ff5757;
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .warning-box-title {
      font-weight: 600;
      color: #ff5757;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .warning-box-text {
      font-size: 13px;
      color: #ccc;
      line-height: 1.6;
    }

    .success-box {
      background: rgba(76, 217, 100, 0.1);
      border: 2px solid #4cd964;
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .success-box-title {
      font-weight: 600;
      color: #4cd964;
      margin-bottom: 8px;
    }

    .seed-words {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin: 20px 0;
    }

    .seed-word {
      background: rgba(212, 175, 55, 0.1);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      padding: 10px;
      text-align: center;
      font-family: 'Courier New', monospace;
    }

    .seed-word-num {
      font-size: 10px;
      color: #666;
      display: block;
      margin-bottom: 3px;
    }

    .seed-word-text {
      font-size: 14px;
      color: #d4af37;
      font-weight: 600;
    }

    .info-card {
      background: rgba(212, 175, 55, 0.1);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .info-card-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid rgba(212, 175, 55, 0.2);
    }

    .info-card-row:last-child {
      border-bottom: none;
    }

    .info-card-label {
      font-size: 13px;
      color: #999;
    }

    .info-card-value {
      font-size: 14px;
      color: #d4af37;
      font-weight: 600;
    }

    .loading {
      text-align: center;
      padding: 40px 20px;
    }

    .spinner {
      border: 3px solid rgba(212, 175, 55, 0.2);
      border-top: 3px solid #d4af37;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .checkbox-group {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      margin: 15px 0;
    }

    .checkbox {
      margin-top: 3px;
    }

    .checkbox-label {
      font-size: 13px;
      color: #ccc;
      line-height: 1.5;
    }

    .copy-seed-btn {
      background: rgba(212, 175, 55, 0.1);
      border: 1px solid rgba(212, 175, 55, 0.3);
      color: #d4af37;
      padding: 12px 20px;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin: 15px 0;
      width: 100%;
    }

    .copy-seed-btn:hover {
      background: rgba(212, 175, 55, 0.2);
      border-color: #d4af37;
    }

    .copy-seed-btn:active {
      transform: scale(0.98);
    }

    .copy-seed-btn.copied {
      background: rgba(76, 217, 100, 0.2);
      border-color: #4cd964;
      color: #4cd964;
    }

    .copy-warning {
      background: rgba(255, 149, 0, 0.1);
      border: 1px solid rgba(255, 149, 0, 0.3);
      border-radius: 8px;
      padding: 10px;
      margin: 10px 0;
      font-size: 12px;
      color: #ff9500;
      text-align: center;
      line-height: 1.4;
    }

    .seed-text {
      font-family: 'Courier New', monospace;
      font-size: 16px;
      line-height: 1.8;
      word-spacing: 8px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      margin: 15px 0;
      text-align: center;
      line-height: 1.4;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .overlay.active {
      display: flex;
    }

    .overlay-card {
      width: 100%;
      max-width: 520px;
      background: rgba(26, 26, 26, 0.98);
      border: 2px solid rgba(212, 175, 55, 0.7);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.5);
    }

    .overlay-title {
      font-family: 'Playfair Display', serif;
      color: #d4af37;
      font-weight: 700;
      font-size: 18px;
      margin-bottom: 10px;
    }

    .overlay-subtitle {
      color: rgba(255,255,255,0.8);
      font-size: 13px;
      margin-bottom: 12px;
      line-height: 1.4;
    }

    .qr-video {
      width: 100%;
      border-radius: 12px;
      background: #000;
      aspect-ratio: 1 / 1;
      object-fit: cover;
      border: 1px solid rgba(255,255,255,0.15);
    }

    .overlay-actions {
      display: flex;
      gap: 10px;
      margin-top: 12px;
    }

    .overlay-actions .btn {
      margin-bottom: 0;
    }
  </style>
</head>
<body>
  <div class="header">
    <button class="back-btn" onclick="goBack()">‚Üê</button>
    <div style="flex:1; min-width:0;">
      <h1>My Wallet</h1>
      <div id="loggedInAs" style="margin-top:2px; font-size:11px; color:#999; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">Logged in as: ‚Äî</div>
    </div>
  </div>

  <div class="container">
    <!-- No Wallet Screen -->
    <div id="noWalletScreen" class="screen active">
      <div class="info-card">
        <h2 style="color: #d4af37; margin-bottom: 10px;">Self-Custody Bitcoin Wallet</h2>
        <p style="color: #ccc; font-size: 14px; line-height: 1.6;">
          Create or import a Bitcoin wallet to verify items, make offers, and complete purchases. 
          Your private keys stay on your device - we never see them.
        </p>
      </div>

      <button class="btn" onclick="showCreateWallet()">Create New Wallet</button>
      <button class="btn secondary" onclick="showImportWallet()">Import Existing Wallet</button>
    </div>

    <!-- Create Wallet Screen -->
    <div id="createWalletScreen" class="screen">
      <div class="warning-box">
        <div class="warning-box-title">‚ö†Ô∏è Backup Required</div>
        <p class="warning-box-text">
          Write down your 24-word seed phrase and store it safely. This is the ONLY way to recover your wallet.
        </p>
      </div>

      <div class="input-group">
        <label class="input-label">Create Passcode (6+ characters)</label>
        <input type="password" id="createPasscode" class="input" placeholder="Enter passcode" minlength="6">
      </div>

      <div class="input-group">
        <label class="input-label">Confirm Passcode</label>
        <input type="password" id="confirmPasscode" class="input" placeholder="Confirm passcode" minlength="6">
      </div>

      <button class="btn" onclick="createWallet()">Create Wallet</button>
      <button class="btn secondary" onclick="showNoWallet()">Cancel</button>
    </div>

    <!-- Show Seed Screen -->
    <div id="showSeedScreen" class="screen">
      <div class="warning-box">
        <div class="warning-box-title">üîê Your Recovery Phrase</div>
        <div class="warning-box-text">
          Write down these 24 words in order. Keep them safe and private. 
          Anyone with these words can access your Bitcoin.
        </div>
      </div>

      <div id="seedWords" class="seed-words"></div>

      <button class="copy-seed-btn" onclick="copySeedPhrase()" id="copySeedBtn">
        <span id="copyIcon">üìã</span>
        <span id="copyText">Copy to Clipboard</span>
      </button>

      <div class="copy-warning">
        ‚ö†Ô∏è Only copy if you're in a secure location. Clear your clipboard after saving.
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="seedBackedUp" class="checkbox">
        <label for="seedBackedUp" class="checkbox-label">
          I have written down my seed phrase and stored it in a safe place
        </label>
      </div>

      <button class="btn" onclick="completeSeedBackup()" id="continueBtn" disabled>Continue to Account Setup</button>
    </div>

    <!-- Account Registration Screen -->
    <div id="accountSetupScreen" class="screen">
      <div class="warning-box">
        <div class="warning-box-title">üìù Create Your Account</div>
        <div class="warning-box-text">
          Register your wallet with the Bitcoin Ownership Protocol to start using authenticated items.
        </div>
      </div>

      <div class="input-group">
        <label class="input-label">Username</label>
        <input id="accountUsername" type="text" class="input" placeholder="Choose a username" />
      </div>

      <div class="input-group">
        <label class="input-label">Email</label>
        <input id="accountEmail" type="email" class="input" placeholder="your@email.com" />
      </div>

      <div class="input-group">
        <label class="input-label">Password (8+ characters)</label>
        <input id="accountPassword" type="password" class="input" placeholder="Create a strong password" />
      </div>

      <div class="input-group">
        <label class="input-label">Confirm Password</label>
        <input id="accountPasswordConfirm" type="password" class="input" placeholder="Re-enter password" />
      </div>

      <div id="accountError" style="color: #ff4444; margin: 10px 0; display: none;"></div>
      <div id="accountSuccess" style="color: #44ff44; margin: 10px 0; display: none;"></div>

      <button class="btn" onclick="registerAccount()">Create Account</button>
      <button class="btn secondary" onclick="skipAccountSetup()">Skip for Now</button>
    </div>

    <!-- Import Wallet Screen -->
    <div id="importWalletScreen" class="screen">
      <div class="info-card">
        <p style="color: #ccc; font-size: 14px; line-height: 1.6;">
          Enter your 24-word seed phrase to restore your wallet.
        </p>
      </div>

      <div class="input-group">
        <label class="input-label">Seed Phrase (24 words)</label>
        <textarea id="importSeed" class="input textarea" placeholder="word1 word2 word3 ..."></textarea>
      </div>

      <div class="input-group">
        <label class="input-label">Create Passcode (6+ characters)</label>
        <input type="password" id="importPasscode" class="input" placeholder="Enter passcode" minlength="6">
      </div>

      <button class="btn" onclick="importWallet()">Import Wallet</button>
      <button class="btn secondary" onclick="showNoWallet()">Cancel</button>
    </div>

    <!-- Wallet Info Screen -->
    <div id="walletInfoScreen" class="screen">
      <div class="wallet-card">
        <div class="wallet-card-title">Identity Address</div>
        <div class="wallet-card-value" id="identityAddress">Loading...</div>
        
        <div class="wallet-card-title">Payment Address</div>
        <div class="wallet-card-value" id="paymentAddress">Loading...</div>
      </div>

      <div class="info-card">
        <div class="info-card-row">
          <span class="info-card-label">Wallet Type</span>
          <span class="info-card-value">Self-Custody</span>
        </div>
        <div class="info-card-row">
          <span class="info-card-label">Network</span>
          <span class="info-card-value">Bitcoin Mainnet</span>
        </div>
        <div class="info-card-row">
          <span class="info-card-label">Created</span>
          <span class="info-card-value" id="walletCreated">-</span>
        </div>
      </div>

      <div class="wallet-card">
        <div class="wallet-card-title">BTC Balance</div>
        <div class="wallet-card-value" id="btcBalance">-</div>
      </div>

      <div class="info-card">
        <div class="info-card-row">
          <span class="info-card-label">Confirmed</span>
          <span class="info-card-value" id="btcConfirmed">-</span>
        </div>
        <div class="info-card-row">
          <span class="info-card-label">Unconfirmed</span>
          <span class="info-card-value" id="btcUnconfirmed">-</span>
        </div>
        <div class="info-card-row">
          <span class="info-card-label">Provider</span>
          <span class="info-card-value" id="chainProvider">-</span>
        </div>
      </div>

      <button class="btn secondary" onclick="refreshBalance()">Refresh Balance</button>

      <!-- Service Balance Section -->
      <div class="wallet-card" style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);">
        <div class="wallet-card-title" style="color: rgba(255,255,255,0.8);">‚ö° Prepaid Service Balance</div>
        <div style="display: flex; align-items: baseline; gap: 8px; margin-bottom: 10px;">
          <span id="serviceBalanceSats" style="font-size: 28px; font-weight: 700; color: #fff;">0</span>
          <span style="font-size: 14px; color: rgba(255,255,255,0.8);">sats</span>
        </div>
        <div style="font-size: 12px; color: rgba(255,255,255,0.7);">
          Use for premium features: message editing, deletion, and more
        </div>
      </div>

      <div class="info-card">
        <div class="info-card-row">
          <span class="info-card-label">Total Funded</span>
          <span class="info-card-value" id="serviceTotalFunded">0 sats</span>
        </div>
        <div class="info-card-row">
          <span class="info-card-label">Total Used</span>
          <span class="info-card-value" id="serviceTotalUsed">0 sats</span>
        </div>
        <div class="info-card-row">
          <span class="info-card-label">Last Funded</span>
          <span class="info-card-value" id="serviceLastFunded">Never</span>
        </div>
      </div>

      <button class="btn secondary" onclick="refreshServiceBalance()">Refresh Service Balance</button>
      <button class="btn" onclick="showFundServiceBalance()" style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);">Fund Service Balance</button>

      <!-- Premium Actions Pricing -->
      <div class="info-card" id="premiumPricingCard">
        <div style="font-weight:600; color:#d4af37; margin-bottom: 12px;">üíé Premium Action Pricing</div>
        <div class="info-card-row">
          <span class="info-card-label">Delete Message</span>
          <span class="info-card-value" id="priceDeleteMessage">50 sats</span>
        </div>
        <div class="info-card-row">
          <span class="info-card-label">Edit Message</span>
          <span class="info-card-value" id="priceEditMessage">25 sats</span>
        </div>
        <div class="info-card-row">
          <span class="info-card-label">Profile Update</span>
          <span class="info-card-value" id="priceProfileUpdate">100 sats</span>
        </div>
        <div class="info-card-row">
          <span class="info-card-label">Create Group</span>
          <span class="info-card-value" id="priceCreateGroup">200 sats</span>
        </div>
      </div>

      <div class="info-card" id="recentTxsCard" style="display:none;">
        <div style="font-weight:600; color:#d4af37; margin-bottom: 10px;">Recent Transactions</div>
        <div id="recentTxsList" style="color:#999; font-size: 13px;">Loading...</div>
      </div>

      <div class="wallet-card">
        <div class="wallet-card-title">Receive BTC</div>
        <div class="wallet-card-value" id="receiveAddress">-</div>
      </div>

      <div style="display:flex; justify-content:center; margin: 10px 0;">
        <img id="receiveQr" alt="Receive BTC QR" style="width:250px; height:250px; border-radius: 12px; background: #fff;" />
      </div>

      <button class="btn secondary" onclick="copyReceiveAddress()">Copy Receive Address</button>

      <div class="info-card">
        <div style="font-weight:600; color:#d4af37; margin-bottom: 10px;">Public Pay Handle (Optional)</div>
        <div style="color:#999; font-size: 13px; line-height: 1.6; margin-bottom: 10px;">Create a public handle like <span style="font-family:'Courier New', monospace;">name@autho</span> so others can pay you without scanning a QR code.</div>
        <input id="payHandleInput" type="text" class="input" placeholder="name@autho" />
        <button class="btn secondary" onclick="savePayHandle()" style="margin-top: 10px;">Save Pay Handle</button>
        <div id="payHandleStatus" style="margin-top:10px; font-size: 13px; color:#999;"></div>
      </div>

      <div class="info-card">
        <div style="font-weight:600; color:#d4af37; margin-bottom: 10px;">Request Payment Link</div>
        <div style="color:#999; font-size: 13px; line-height: 1.6; margin-bottom: 10px;">Generate a shareable link that pre-fills an amount and memo in the wallet.</div>
        <input id="invoiceAmountUsd" type="number" inputmode="decimal" class="input" placeholder="Amount (USD) e.g. 105.87 (optional)" />
        <input id="invoiceAmountSats" type="number" inputmode="numeric" class="input" placeholder="Amount (sats) e.g. 25000 (optional)" style="margin-top: 10px;" />
        <input id="invoiceMemo" type="text" class="input" placeholder="Memo (optional) e.g. You owe me" style="margin-top: 10px;" />
        <button class="btn secondary" onclick="generatePaymentLink()" style="margin-top: 10px;">Create Payment Link</button>
        <div class="wallet-card-value" id="paymentLinkOut" style="margin-top:10px; display:none;"></div>
        <button class="btn secondary" onclick="copyPaymentLink()" id="copyPaymentLinkBtn" style="margin-top: 10px; display:none;">Copy Payment Link</button>
      </div>

      <div class="wallet-card">
        <div class="wallet-card-title">Send BTC</div>
        <div style="margin-top:10px;">
          <input id="sendToAddress" type="text" placeholder="Recipient address or name@autho" style="width:100%; padding:12px; border-radius:12px; border: 1px solid rgba(255,255,255,0.15); background: rgba(0,0,0,0.2); color: #fff;" />
        </div>
        <div style="margin-top:10px;">
          <button class="btn secondary" onclick="openQrScanner()">Scan QR Code</button>
        </div>
        <div style="margin-top:10px;">
          <input id="sendMemo" type="text" placeholder="Memo (optional)" style="width:100%; padding:12px; border-radius:12px; border: 1px solid rgba(255,255,255,0.15); background: rgba(0,0,0,0.2); color: #fff;" />
        </div>
        <div style="margin-top:10px;">
          <input id="sendAmountUsd" type="number" inputmode="decimal" placeholder="Amount (USD)" style="width:100%; padding:12px; border-radius:12px; border: 1px solid rgba(255,255,255,0.15); background: rgba(0,0,0,0.2); color: #fff;" />
        </div>
        <div id="sendUsdRate" style="margin-top:8px; font-size: 12px; opacity: 0.85;"></div>
        <div style="margin-top:10px;">
          <input id="sendAmountSats" type="number" inputmode="numeric" placeholder="Amount (sats)" style="width:100%; padding:12px; border-radius:12px; border: 1px solid rgba(255,255,255,0.15); background: rgba(0,0,0,0.2); color: #fff;" />
        </div>
        <div style="margin-top:10px;">
          <select id="sendFeePriority" onchange="updateSendFeePriority()" style="width:100%; padding:12px; border-radius:12px; border: 1px solid rgba(255,255,255,0.15); background: rgba(0,0,0,0.2); color: #fff;">
            <option value="nopriority">No Priority</option>
            <option value="low" selected>Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
            <option value="custom">Custom</option>
          </select>
          <input id="sendFeeRateCustom" type="number" step="0.1" placeholder="0.9" style="display:none; width:100%; margin-top:10px; padding:12px; border-radius:12px; border: 1px solid rgba(255,255,255,0.15); background: rgba(0,0,0,0.2); color: #fff;" />
        </div>
        <div style="margin-top:10px; display:flex; gap:10px;">
          <button class="btn secondary" onclick="fillSendMax()" style="flex:1;">Send Max</button>
        </div>
        <div id="sendFeeInfo" style="margin-top:10px; font-size: 12px; opacity: 0.85;"></div>
        <div id="sendStatus" style="margin-top:10px; font-size: 14px; opacity: 0.9;"></div>
      </div>

      <button class="btn" onclick="sendBtc()">Send BTC</button>

      <button class="btn secondary" onclick="showExportSeed()">Export Seed Phrase</button>
      <button class="btn danger" onclick="confirmDeleteWallet()">Delete Wallet</button>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen" class="screen">
      <div class="loading">
        <div class="spinner"></div>
        <div id="loadingText">Processing...</div>
      </div>
    </div>
  </div>

  <div id="qrScannerOverlay" class="overlay" role="dialog" aria-modal="true" aria-label="Scan QR">
    <div class="overlay-card">
      <div class="overlay-title">Scan QR Code</div>
      <div class="overlay-subtitle">Point your camera at a Bitcoin address QR. Supports both plain addresses and <span style="font-family: 'Courier New', monospace;">bitcoin:</span> payment URIs.</div>
      <video id="qrVideo" class="qr-video" autoplay playsinline muted></video>
      <div id="qrReader" style="display:none;"></div>
      <div class="overlay-actions">
        <button class="btn secondary" onclick="closeQrScanner()">Close</button>
      </div>
    </div>
  </div>

  <!-- Fund Service Balance Overlay -->
  <div id="fundServiceOverlay" class="overlay" role="dialog" aria-modal="true" aria-label="Fund Service Balance">
    <div class="overlay-card">
      <div class="overlay-title">‚ö° Fund Service Balance</div>
      <div class="overlay-subtitle">Enter the amount of sats to prepay as service credits. We'll send it automatically from your wallet. Minimum: 1,000 sats.</div>
      
      <div class="info-card">
        <div class="info-card-row">
          <span class="info-card-label">Amount (sats)</span>
        </div>
        <input id="fundServiceAmountSats" type="number" inputmode="numeric" class="input" placeholder="1000" />
        <button class="btn" onclick="fundServiceBalance()" style="margin-top: 10px; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);">Fund Service Balance</button>
        <div id="fundServiceStatus" style="margin-top: 10px; font-size: 13px;"></div>
      </div>
      
      <div class="info-card">
        <div class="info-card-row">
          <span class="info-card-label">Payment Address</span>
        </div>
        <div id="fundingAddress" style="font-family: 'Courier New', monospace; font-size: 12px; word-break: break-all; color: #d4af37; padding: 10px 0;"></div>
      </div>
      
      <div style="display:flex; justify-content:center; margin: 15px 0;">
        <img id="fundingQr" alt="Funding Address QR" style="width:200px; height:200px; border-radius: 12px; background: #fff;" />
      </div>
      
      <button class="btn secondary" onclick="copyFundingAddress()">Copy Address</button>
      
      <div class="info-card" style="margin-top: 15px;">
        <div style="font-weight:600; color:#d4af37; margin-bottom: 10px;">Advanced: Verify TXID Manually</div>
        <div style="color:#999; font-size: 13px; line-height: 1.6; margin-bottom: 10px;">If you funded from another wallet, enter the transaction ID to verify and credit your balance.</div>
        <input id="verifyTxid" type="text" class="input" placeholder="Transaction ID (txid)" />
        <button class="btn" onclick="verifyFundingPayment()" style="margin-top: 10px; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);">Verify Payment</button>
        <div id="verifyStatus" style="margin-top: 10px; font-size: 13px;"></div>
      </div>
      
      <div class="overlay-actions" style="margin-top: 15px;">
        <button class="btn secondary" onclick="closeFundServiceOverlay()">Close</button>
      </div>
    </div>
  </div>

  <script src="/js/qr.bundle.js"></script>
  <script src="/js/btc.bundle.js"></script>
  <script type="module">
    // Import wallet module (will need to be bundled for production)
    // For now, using inline implementation

    let currentScreen = 'noWalletScreen';
    let transientMnemonic = '';

    function b64FromBytes(bytes) {
      let binary = '';
      const chunkSize = 0x8000;
      for (let i = 0; i < bytes.length; i += chunkSize) {
        binary += String.fromCharCode(...bytes.slice(i, i + chunkSize));
      }
      return btoa(binary);
    }

    function bytesFromB64(b64) {
      return Uint8Array.from(atob(b64), c => c.charCodeAt(0));
    }

    async function sha256Hex(input) {
      const data = new TextEncoder().encode(String(input));
      const digest = await crypto.subtle.digest('SHA-256', data);
      return Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function deriveVaultKey(password, saltBytes, iterations) {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        'raw',
        enc.encode(String(password)),
        { name: 'PBKDF2' },
        false,
        ['deriveKey']
      );
      return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt: saltBytes, iterations, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
      );
    }

    async function encryptWalletVault(walletPayload, password) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const iterations = 210000;
      const key = await deriveVaultKey(password, salt, iterations);
      const pt = new TextEncoder().encode(JSON.stringify(walletPayload));
      const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, pt);
      return {
        v: 'AUTHO_WALLET_VAULT_V1',
        kdf: { saltB64: b64FromBytes(salt), iterations, hash: 'SHA-256' },
        enc: { ivB64: b64FromBytes(iv), ctB64: b64FromBytes(new Uint8Array(ct)) }
      };
    }

    async function decryptWalletVault(walletVault, password) {
      if (!walletVault || walletVault.v !== 'AUTHO_WALLET_VAULT_V1') {
        throw new Error('Unsupported wallet vault format');
      }
      const salt = bytesFromB64(walletVault.kdf?.saltB64 || '');
      const iterations = Number(walletVault.kdf?.iterations || 0);
      const iv = bytesFromB64(walletVault.enc?.ivB64 || '');
      const ct = bytesFromB64(walletVault.enc?.ctB64 || '');
      const key = await deriveVaultKey(password, salt, iterations);
      const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
      const json = new TextDecoder().decode(pt);
      return JSON.parse(json);
    }

    function isValidPassword(password) {
      const pw = String(password || '');
      if (pw.length < 8) return false;
      if (pw.length > 256) return false;
      if (pw.includes(' ')) {
        return pw.length >= 14;
      }
      const hasUpper = /[A-Z]/.test(pw);
      const hasLower = /[a-z]/.test(pw);
      const hasDigit = /\d/.test(pw);
      const hasSpecial = /[^A-Za-z0-9]/.test(pw);
      return pw.length >= 12 && hasUpper && hasLower && hasDigit && hasSpecial;
    }

    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
      currentScreen = screenId;
    }

    window.showNoWallet = () => showScreen('noWalletScreen');
    window.showCreateWallet = () => showScreen('createWalletScreen');
    window.showImportWallet = () => showScreen('importWalletScreen');
    window.showWalletInfo = () => showScreen('walletInfoScreen');

    window.goBack = () => {
      window.location.href = '/m';
    };

    // Check if wallet exists on load
    window.addEventListener('load', () => {
      try { updateLoggedInAs().catch(() => {}); } catch {}
      const hasWallet = localStorage.getItem('autho_wallet_encrypted');
      if (hasWallet) {
        loadWalletInfo();
        initWalletExtras();
        showScreen('walletInfoScreen');
        try { applyIncomingPaymentRequest(); } catch {}
        try { loadMyPayHandle(); } catch {}
      }
    });

    function isBtcAddress(s) {
      const v = String(s || '').trim();
      return /^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,62}$/.test(v);
    }

    async function resolvePayHandle(handle) {
      const h = String(handle || '').trim();
      if (!h) throw new Error('Missing handle');
      const r = await fetch(`/api/pay/resolve?handle=${encodeURIComponent(h)}`, { cache: 'no-store' });
      const data = await r.json().catch(() => ({}));
      if (!r.ok || !data || data.success !== true) {
        throw new Error(data?.error || 'Failed to resolve handle');
      }
      const addr = String(data.walletAddress || '').trim();
      if (!addr) throw new Error('No wallet address found for handle');
      return addr;
    }

    async function loadMe() {
      const sid = getSessionId();
      if (!sid) return null;
      const r = await fetch('/api/auth/me', { method: 'GET', headers: { 'Authorization': `Bearer ${sid}` }, cache: 'no-store' });
      const data = await r.json().catch(() => ({}));
      if (!r.ok || !data || data.success !== true) return null;
      return data;
    }

    async function loadMyPayHandle() {
      const statusEl = document.getElementById('payHandleStatus');
      const inputEl = document.getElementById('payHandleInput');
      if (!inputEl) return;
      const me = await loadMe();
      if (!me || !me.account) {
        if (statusEl) statusEl.textContent = 'Sign in to set a pay handle.';
        return;
      }
      const handle = String(me.account.payHandle || '').trim();
      if (handle) {
        inputEl.value = handle;
        if (statusEl) statusEl.textContent = `Current: ${handle}`;
      } else {
        if (statusEl) statusEl.textContent = 'Not set.';
      }
    }

    window.savePayHandle = async () => {
      const statusEl = document.getElementById('payHandleStatus');
      const inputEl = document.getElementById('payHandleInput');
      if (!inputEl) return;

      try {
        const me = await loadMe();
        if (!me || !me.account) {
          if (statusEl) statusEl.textContent = 'You must be signed in.';
          return;
        }
        const sid = getSessionId();
        const accountId = String(me.account.accountId || '').trim();
        if (!accountId || !sid) {
          if (statusEl) statusEl.textContent = 'Missing session.';
          return;
        }
        const payHandle = String(inputEl.value || '').trim();
        if (statusEl) statusEl.textContent = 'Saving...';
        const r = await fetch(`/api/accounts/${encodeURIComponent(accountId)}/pay-handle/set`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${sid}` },
          body: JSON.stringify({ payHandle })
        });
        if (r.status === 401) {
          clearSession();
          const returnUrl = '/m/wallet';
          window.location.href = `/customer/login?return=${encodeURIComponent(returnUrl)}`;
          return;
        }
        const data = await r.json().catch(() => ({}));
        if (!r.ok || !data || data.success !== true) {
          throw new Error(data?.error || 'Failed to save handle');
        }
        const saved = String(data.payHandle || '').trim();
        if (statusEl) statusEl.textContent = saved ? `Saved: ${saved}` : 'Cleared.';
      } catch (e) {
        if (statusEl) statusEl.textContent = `Error: ${e?.message || String(e)}`;
      }
    };

    function buildPaymentLink(params) {
      const base = `${location.origin}/m/wallet`;
      const qp = new URLSearchParams();
      if (params.payHandle) qp.set('payHandle', String(params.payHandle));
      if (params.payTo) qp.set('payTo', String(params.payTo));
      if (params.amountUsd) qp.set('amountUsd', String(params.amountUsd));
      if (params.amountSats) qp.set('amountSats', String(params.amountSats));
      if (params.memo) qp.set('memo', String(params.memo));
      return `${base}?${qp.toString()}`;
    }

    window.generatePaymentLink = async () => {
      const outEl = document.getElementById('paymentLinkOut');
      const btnEl = document.getElementById('copyPaymentLinkBtn');
      const usdEl = document.getElementById('invoiceAmountUsd');
      const satsEl = document.getElementById('invoiceAmountSats');
      const memoEl = document.getElementById('invoiceMemo');

      let amountUsd = String(usdEl?.value || '').trim();
      let amountSats = String(satsEl?.value || '').trim();
      const memo = String(memoEl?.value || '').trim();

      if (amountUsd && !Number.isFinite(Number(amountUsd))) amountUsd = '';
      if (amountSats && !Number.isFinite(Number(amountSats))) amountSats = '';

      const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
      const receiveAddress = String(wallet.paymentAddress || wallet.address || '').trim();
      if (!receiveAddress) {
        alert('No wallet address');
        return;
      }

      let payHandle = '';
      try {
        const me = await loadMe();
        payHandle = String(me?.account?.payHandle || '').trim();
      } catch {}

      const link = buildPaymentLink({
        payHandle: payHandle || undefined,
        payTo: payHandle ? undefined : receiveAddress,
        amountUsd: amountUsd || undefined,
        amountSats: amountSats || undefined,
        memo: memo || undefined,
      });

      try { localStorage.setItem('autho_last_payment_link', link); } catch {}
      if (outEl) {
        outEl.style.display = 'block';
        outEl.textContent = link;
      }
      if (btnEl) btnEl.style.display = 'block';
    };

    window.copyPaymentLink = async () => {
      const outEl = document.getElementById('paymentLinkOut');
      const link = String(outEl?.textContent || '').trim() || String(localStorage.getItem('autho_last_payment_link') || '').trim();
      if (!link) return;
      try {
        await navigator.clipboard.writeText(link);
        alert('Payment link copied');
      } catch {
        alert('Copy failed');
      }
    };

    async function applyIncomingPaymentRequest() {
      const params = new URLSearchParams(location.search || '');
      const payHandle = String(params.get('payHandle') || '').trim();
      const payTo = String(params.get('payTo') || '').trim();
      const amountUsd = String(params.get('amountUsd') || '').trim();
      const amountSats = String(params.get('amountSats') || '').trim();
      const memo = String(params.get('memo') || '').trim();

      if (!payHandle && !payTo) return;

      const toEl = document.getElementById('sendToAddress');
      const usdEl = document.getElementById('sendAmountUsd');
      const satsEl = document.getElementById('sendAmountSats');
      const memoEl = document.getElementById('sendMemo');

      if (toEl) toEl.value = payHandle || payTo;
      if (memoEl && memo) memoEl.value = memo;
      if (usdEl && amountUsd) {
        usdEl.value = amountUsd;
        try { await window.updateSatsFromUsd(); } catch {}
      } else if (satsEl && amountSats) {
        satsEl.value = amountSats;
        try { await window.updateUsdFromSats(); } catch {}
      }
    }

    function loadWalletInfo() {
      const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
      if (wallet.address) {
        document.getElementById('identityAddress').textContent = wallet.address;
        document.getElementById('paymentAddress').textContent = wallet.paymentAddress || wallet.address;
        
        const encrypted = localStorage.getItem('autho_wallet_encrypted');
        if (encrypted) {
          try {
            const data = JSON.parse(atob(encrypted));
            if (data.createdAt) {
              document.getElementById('walletCreated').textContent = new Date(data.createdAt).toLocaleDateString();
            }
          } catch (e) {
            console.log('Could not parse wallet metadata', e);
            document.getElementById('walletCreated').textContent = 'Just now';
          }
        }
      } else {
        document.getElementById('identityAddress').textContent = 'No wallet found';
        document.getElementById('paymentAddress').textContent = 'No wallet found';
      }
    }

    function satsToBtcString(sats) {
      const n = Number(sats || 0);
      if (!Number.isFinite(n)) return '0';
      return (n / 100000000).toFixed(8);
    }

    function uniq(arr) {
      return Array.from(new Set(arr.filter(Boolean)));
    }

    function getWalletNetworkName() {
      const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
      const net = String(wallet.network || 'mainnet').toLowerCase();
      return net.includes('test') ? 'testnet' : 'mainnet';
    }

    async function getChainApiProviders() {
      const providers = [];
      providers.push(`${location.origin}/api/chain`);
      try {
        const res = await fetch('/seed-manifest.json', { cache: 'no-store' });
        if (res.ok) {
          const manifest = await res.json();
          const seeds = Array.isArray(manifest?.seeds) ? manifest.seeds : [];
          for (const s of seeds) {
            const chainApi = s?.services?.chainApi;
            if (typeof chainApi === 'string' && chainApi.startsWith('http')) {
              providers.push(chainApi.replace(/\/$/, ''));
            }
          }
        }
      } catch {}

      const network = getWalletNetworkName();
      if (network === 'testnet') {
        providers.push('https://blockstream.info/testnet/api');
      } else {
        providers.push('https://blockstream.info/api');
      }

      return uniq(providers);
    }

    async function withChainProvider(fn) {
      const providers = await getChainApiProviders();
      let lastErr;
      for (const base of providers) {
        try {
          const out = await fn(base);
          try {
            const el = document.getElementById('chainProvider');
            if (el) el.textContent = base;
          } catch {}
          return out;
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error('No chain providers available');
    }

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) {
        const t = await res.text();
        throw new Error(t || `HTTP ${res.status}`);
      }
      return await res.json();
    }

    function getSessionId() {
      try {
        return String(localStorage.getItem('autho_session_id') || '').trim();
      } catch {
        return '';
      }
    }

    function clearSession() {
      try { localStorage.removeItem('autho_session_id'); } catch {}
      try { localStorage.removeItem('autho_account_id'); } catch {}
    }

    async function updateLoggedInAs() {
      const el = document.getElementById('loggedInAs');
      if (!el) return;
      const sid = getSessionId();
      if (!sid) {
        el.textContent = 'Logged in as: (not signed in)';
        return;
      }
      try {
        const r = await fetch('/api/auth/me', { method: 'GET', headers: { 'Authorization': `Bearer ${sid}` } });
        const data = await r.json().catch(() => ({}));
        if (!r.ok || !data || data.success !== true) {
          clearSession();
          el.textContent = 'Logged in as: (not signed in)';
          return;
        }
        const a = data.account || {};
        const email = String(a.email || '').trim();
        const username = String(a.username || '').trim();
        const accountId = String(a.accountId || '').trim();
        const ident = email || username || (accountId ? `${accountId.substring(0, 12)}...` : '‚Äî');
        const shortId = accountId ? `${accountId.substring(0, 10)}...` : '';
        el.textContent = `Logged in as: ${shortId && ident !== shortId ? `${ident} (${shortId})` : ident}`;
      } catch {
        el.textContent = 'Logged in as: (unknown)';
      }
    }

    async function fetchText(url, opts) {
      const res = await fetch(url, opts);
      const text = await res.text();
      if (!res.ok) throw new Error(text || `Request failed: ${res.status}`);
      return { text, res };
    }

    function shortTxid(t) {
      const txid = String(t || '').trim();
      if (!txid) return '';
      return txid.length > 18 ? `${txid.substring(0, 10)}...${txid.substring(txid.length - 8)}` : txid;
    }

    function getTxExplorerUrl(txid) {
      const t = String(txid || '').trim();
      if (!t) return '';
      const net = getWalletNetworkName();
      return net === 'testnet'
        ? `https://mempool.space/testnet/tx/${encodeURIComponent(t)}`
        : `https://mempool.space/tx/${encodeURIComponent(t)}`;
    }

    window.copyTxid = async (txid) => {
      const t = String(txid || '').trim();
      if (!t) return;
      try {
        await navigator.clipboard.writeText(t);
      } catch {
        alert('Copy failed');
      }
    };

    async function loadRecentTransactions() {
      const card = document.getElementById('recentTxsCard');
      const list = document.getElementById('recentTxsList');
      if (!card || !list) return;

      const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
      const address = wallet.paymentAddress || wallet.address;
      if (!address) {
        card.style.display = 'none';
        list.textContent = '';
        return;
      }

      card.style.display = 'block';
      list.textContent = 'Loading...';

      try {
        const [confirmed, mempool] = await Promise.all([
          withChainProvider((base) => fetchJson(`${base}/address/${address}/txs`)),
          withChainProvider((base) => fetchJson(`${base}/address/${address}/txs/mempool`)),
        ]);

        const all = []
          .concat(Array.isArray(mempool) ? mempool : [])
          .concat(Array.isArray(confirmed) ? confirmed : []);

        const seen = new Set();
        const txs = all
          .filter((t) => t && t.txid)
          .filter((t) => {
            const id = String(t.txid || '');
            if (!id || seen.has(id)) return false;
            seen.add(id);
            return true;
          })
          .slice(0, 12);

        if (!txs.length) {
          list.innerHTML = '<div style="color:#999; font-size: 13px;">No transactions found.</div>';
          return;
        }

        list.innerHTML = txs.map((tx) => {
          const txid = String(tx?.txid || '').trim();
          const isConfirmed = Boolean(tx?.status?.confirmed);
          const label = isConfirmed ? 'Confirmed' : 'Unconfirmed';
          const href = getTxExplorerUrl(txid);
          const safeTxid = txid.replace(/[^0-9a-f]/gi, '');
          return `
            <div style="padding: 10px 0; border-top: 1px solid rgba(212,175,55,0.2);">
              <div style="display:flex; justify-content: space-between; gap: 10px; align-items: center;">
                <div style="color:#d4af37; font-weight:600; font-size: 13px;">${label}</div>
                <div style="font-family:'Courier New', monospace; font-size: 12px; color:#fff;">${shortTxid(txid)}</div>
              </div>
              <div style="display:flex; gap: 10px; margin-top: 8px;">
                <button class="btn secondary" style="flex:1; margin-bottom: 0; padding: 10px 12px; font-size: 14px;" onclick="copyTxid('${safeTxid}')">Copy TXID</button>
                ${href ? `<a class="btn secondary" style="flex:1; margin-bottom: 0; padding: 10px 12px; font-size: 14px; text-align:center; text-decoration:none; display:block;" href="${href}" target="_blank" rel="noreferrer">Open</a>` : '<div style="flex:1;"></div>'}
              </div>
            </div>
          `;
        }).join('');
      } catch (e) {
        list.innerHTML = `<div style="color:#ff5757; font-size: 13px;">Failed to load transactions.</div>`;
      }
    }

    let qrScanStream = null;
    let qrScanStop = null;
    let qrHtml5 = null;

    let btcUsdCache = { rate: 0, ts: 0 };
    let walletConfirmedSats = 0;
    let walletConfirmedUtxos = [];
    let walletLastFeeRate = 1;
    let walletFeePriority = 'low';

    async function getBtcUsdRate() {
      const now = Date.now();
      if (btcUsdCache.rate > 0 && (now - btcUsdCache.ts) < 60_000) {
        return btcUsdCache.rate;
      }

      const sources = [
        async () => {
          const j = await fetchJson('https://api.coinbase.com/v2/exchange-rates?currency=BTC');
          const r = Number(j?.data?.rates?.USD);
          return Number.isFinite(r) && r > 0 ? r : 0;
        },
        async () => {
          const j = await fetchJson('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
          const r = Number(j?.bitcoin?.usd);
          return Number.isFinite(r) && r > 0 ? r : 0;
        },
        async () => {
          const j = await fetchJson('https://blockchain.info/ticker');
          const r = Number(j?.USD?.last);
          return Number.isFinite(r) && r > 0 ? r : 0;
        },
      ];

      for (const fn of sources) {
        try {
          const r = await fn();
          if (r > 0) {
            btcUsdCache = { rate: r, ts: now };
            return r;
          }
        } catch {}
      }

      return 0;
    }

    function formatUsd(n) {
      try {
        return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(n);
      } catch {
        return `$${Number(n).toFixed(2)}`;
      }
    }

    window.updateSatsFromUsd = async () => {
      const usdEl = document.getElementById('sendAmountUsd');
      const satsEl = document.getElementById('sendAmountSats');
      if (!usdEl || !satsEl) return;

      const usd = Number(usdEl.value || 0);
      if (!Number.isFinite(usd) || usd <= 0) {
        return;
      }

      const rate = await getBtcUsdRate();
      const rateEl = document.getElementById('sendUsdRate');
      if (rateEl) rateEl.textContent = rate > 0 ? `1 BTC ‚âà ${formatUsd(rate)}` : '';
      if (rate <= 0) return;

      const sats = Math.round((usd / rate) * 1e8);
      if (sats > 0) satsEl.value = String(sats);
    };

    window.updateUsdFromSats = async () => {
      const usdEl = document.getElementById('sendAmountUsd');
      const satsEl = document.getElementById('sendAmountSats');
      if (!usdEl || !satsEl) return;

      const sats = Number(satsEl.value || 0);
      if (!Number.isFinite(sats) || sats <= 0) {
        return;
      }

      const rate = await getBtcUsdRate();
      const rateEl = document.getElementById('sendUsdRate');
      if (rateEl) rateEl.textContent = rate > 0 ? `1 BTC ‚âà ${formatUsd(rate)}` : '';
      if (rate <= 0) return;

      const usd = (sats / 1e8) * rate;
      if (usd > 0) usdEl.value = String(Math.round(usd * 100) / 100);
    };

    function pickFeeRateSatPerVb(feeEst, speed) {
      const s = String(speed || 'normal');
      const targets = s === 'fast' ? [1, 2] : (s === 'economy' ? [6, 10] : [2, 3, 6]);
      for (const t of targets) {
        const r = Number(feeEst?.[String(t)]);
        if (Number.isFinite(r) && r > 0) return r;
      }
      try {
        const keys = Object.keys(feeEst || {}).map(k => Number(k)).filter(n => Number.isFinite(n)).sort((a, b) => a - b);
        for (const k of keys) {
          const r = Number(feeEst?.[String(k)]);
          if (Number.isFinite(r) && r > 0) return r;
        }
      } catch {}
      return 2;
    }

    function parseBitcoinQrPayload(raw) {
      const text = String(raw || '').trim();
      if (!text) return { address: '', amountSats: null };

      const lower = text.toLowerCase();
      if (lower.startsWith('bitcoin:')) {
        const withoutScheme = text.slice(text.indexOf(':') + 1);
        const [addrPart, queryPart] = withoutScheme.split('?');
        const address = String(addrPart || '').trim();
        let amountSats = null;
        try {
          const qs = new URLSearchParams(queryPart || '');
          const amountBtcStr = qs.get('amount');
          if (amountBtcStr) {
            const amountBtc = Number(amountBtcStr);
            if (Number.isFinite(amountBtc) && amountBtc > 0) {
              amountSats = Math.round(amountBtc * 1e8);
            }
          }
        } catch {}
        return { address, amountSats };
      }

      return { address: text, amountSats: null };
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = String(text ?? '');
      return div.innerHTML;
    }

    function formatSatPerVb(rate) {
      const r = Number(rate);
      if (!Number.isFinite(r) || r <= 0) return '1';
      if (r < 1) return r.toFixed(1);
      if (r < 10) return r.toFixed(1);
      return r.toFixed(0);
    }

    function parseSatsFromInput(rawValue) {
      const raw = String(rawValue ?? '').trim();
      if (!raw) return 0;

      // If someone pastes BTC-style decimals (e.g. 0.0005), convert to sats.
      if (raw.includes('.') || raw.toLowerCase().includes('e')) {
        const f = Number(raw);
        if (!Number.isFinite(f) || f <= 0) return 0;
        if (f < 1) return Math.floor(f * 1e8);
        throw new Error('Amount must be sats (integer) or USD');
      }

      const n = Number(raw);
      if (!Number.isFinite(n) || n <= 0) return 0;
      return Math.floor(n);
    }

    function estimateFeeInfoForSpend(utxos, amountSats, feeRateSatPerVb) {
      const rate = Math.max(0.6, Number(feeRateSatPerVb || 1));
      const sorted = (Array.isArray(utxos) ? utxos : []).slice().sort((a, b) => Number(b.value || 0) - Number(a.value || 0));

      let needed = Math.max(0, Math.floor(Number(amountSats || 0)));
      let inCount = 0;
      let selectedTotal = 0;
      let vbytes = 10 + (68 * 1) + (31 * 2);
      let fee = Math.max(0, Math.ceil(vbytes * rate));

      for (let i = 0; i < sorted.length; i++) {
        inCount++;
        selectedTotal += Number(sorted[i].value || 0);
        vbytes = 10 + (68 * inCount) + (31 * 2);
        fee = Math.max(0, Math.ceil(vbytes * rate));
        if (selectedTotal >= needed + fee) {
          return { feeSats: fee, inputCount: inCount, vbytes };
        }
      }
      return { feeSats: fee, inputCount: Math.max(1, inCount), vbytes };
    }

    function getFeeSpeedFromPriority(priority) {
      const p = String(priority || 'low');
      if (p === 'high') return 'fast';
      if (p === 'medium') return 'normal';
      // Use the most economical fees by default.
      return 'economy';
    }

    async function getRecommendedFeeRate(feePriority, withChainProviderFn) {
      const priority = String(feePriority || 'low');
      const speed = getFeeSpeedFromPriority(priority);
      let feeRate = 1;

      if (priority === 'custom') {
        const raw = String(document.getElementById('sendFeeRateCustom')?.value || '').trim();
        const parsed = Number(raw);
        if (Number.isFinite(parsed) && parsed > 0) {
          return Math.max(0.6, Math.min(500, parsed));
        }
        return Math.max(0.6, Math.min(500, Number(walletLastFeeRate || 1)));
      }

      try {
        const network = getWalletNetworkName();
        const mempoolBase = network === 'testnet' ? 'https://mempool.space/testnet/api' : 'https://mempool.space/api';
        const rec = await fetch(`${mempoolBase}/v1/fees/recommended`, { cache: 'no-store' }).then(r => r.json());
        let picked = 0;
        if (priority === 'nopriority') {
          picked = Number(rec?.minimumFee ?? rec?.economyFee ?? rec?.hourFee);
        } else if (speed === 'fast') {
          picked = Number(rec?.fastestFee ?? rec?.halfHourFee ?? rec?.hourFee);
        } else if (speed === 'normal') {
          picked = Number(rec?.hourFee ?? rec?.halfHourFee ?? rec?.economyFee);
        } else {
          picked = Number(rec?.economyFee ?? rec?.minimumFee ?? rec?.hourFee);
        }
        if (Number.isFinite(picked) && picked > 0) {
          feeRate = Math.max(0.6, Math.min(500, picked));
          return feeRate;
        }
      } catch {}

      try {
        const feeEst = await withChainProviderFn((base) => fetchJson(`${base}/fee-estimates`));
        const picked = pickFeeRateSatPerVb(feeEst, speed);
        const bumped = (Number.isFinite(picked) && picked > 0 ? picked : 1) * 1.05;
        feeRate = Math.max(0.6, Math.min(500, bumped));
      } catch {
        feeRate = 1;
      }
      return feeRate;
    }

    async function updateSendFeeEstimate() {
      try {
        const feeEl = document.getElementById('sendFeeInfo');
        if (!feeEl) return;

        const satsEl = document.getElementById('sendAmountSats');
        const amountSats = parseSatsFromInput(satsEl?.value || '') || Math.min(10000, walletConfirmedSats);
        const info = estimateFeeInfoForSpend(walletConfirmedUtxos, amountSats, walletLastFeeRate);
        const safetyBuffer = Math.max(0, Math.min(100, Math.floor(Number(walletConfirmedSats || 0) * 0.001)));
        feeEl.textContent = `Fee: ${String(walletFeePriority)} (~${formatSatPerVb(walletLastFeeRate)} sat/vB | ~${Number(info.feeSats).toLocaleString()} sats | buffer: ${Number(safetyBuffer).toLocaleString()} sats | ~${Math.round(info.vbytes)} vB | inputs: ${info.inputCount} | assumes change)`;
      } catch {}
    }

    window.updateSendFeePriority = async () => {
      const sel = document.getElementById('sendFeePriority');
      const custom = document.getElementById('sendFeeRateCustom');
      const priority = String(sel?.value || 'low');
      walletFeePriority = priority;

      try {
        if (custom) custom.style.display = priority === 'custom' ? 'block' : 'none';
      } catch {}

      try {
        walletLastFeeRate = await getRecommendedFeeRate(walletFeePriority, withChainProvider);
      } catch {}
      try {
        await updateSendFeeEstimate();
      } catch {}
    };

    window.fillSendMax = async () => {
      const satsEl = document.getElementById('sendAmountSats');
      if (!satsEl) return;

      try {
        if (!walletConfirmedUtxos || walletConfirmedUtxos.length === 0) {
          await refreshBalance();
        }
      } catch {}

      // Ensure we have fee rate and UTXOs
      try {
        walletLastFeeRate = await getRecommendedFeeRate(walletFeePriority, withChainProvider);
      } catch {}

      const info = estimateFeeInfoForSpend(walletConfirmedUtxos, walletConfirmedSats, walletLastFeeRate);
      const safetyBuffer = Math.max(0, Math.min(100, Math.floor(Number(walletConfirmedSats || 0) * 0.001)));
      const max = Math.max(0, Math.floor(Number(walletConfirmedSats || 0) - Number(info.feeSats || 0) - safetyBuffer));
      satsEl.value = String(max);

      try {
        await updateUsdFromSats();
      } catch {}
      try {
        await updateSendFeeEstimate();
      } catch {}
    };

    function setSendRecipientFromQr(raw) {
      const { address, amountSats } = parseBitcoinQrPayload(raw);
      if (!address) return false;

      const toEl = document.getElementById('sendToAddress');
      if (toEl) toEl.value = address;

      const amtEl = document.getElementById('sendAmountSats');
      if (amtEl && amountSats && !String(amtEl.value || '').trim()) {
        amtEl.value = String(amountSats);
      }
      return true;
    }

    window.openQrScanner = async () => {
      try {
        if (!navigator.mediaDevices || typeof navigator.mediaDevices.getUserMedia !== 'function') {
          alert('Camera not available on this device/browser. Please paste the address.');
          return;
        }

        const overlay = document.getElementById('qrScannerOverlay');
        const video = document.getElementById('qrVideo');
        const reader = document.getElementById('qrReader');
        if (!overlay || !video) return;

        overlay.classList.add('active');

        if (video) video.style.display = '';
        if (reader) reader.style.display = 'none';

        if (typeof window.BarcodeDetector !== 'function') {
          const Html5QrcodeCtor = window.Html5Qrcode;
          if (typeof Html5QrcodeCtor !== 'function') {
            alert('QR scanning is not supported on this browser. Please paste the address (or use a different browser/device).');
            window.closeQrScanner();
            return;
          }

          if (video) video.style.display = 'none';
          if (reader) reader.style.display = '';
          if (reader) reader.innerHTML = '';

          const html5 = new Html5QrcodeCtor('qrReader');
          qrHtml5 = html5;

          await html5.start(
            { facingMode: 'environment' },
            { fps: 10, qrbox: { width: 250, height: 250 } },
            async (decodedText) => {
              try {
                if (setSendRecipientFromQr(decodedText)) {
                  try {
                    await html5.stop();
                    html5.clear();
                  } catch {}
                  qrHtml5 = null;
                  window.closeQrScanner();
                }
              } catch {}
            },
            () => {}
          );

          return;
        }

        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment' },
          audio: false
        });
        qrScanStream = stream;
        video.srcObject = stream;
        await video.play();

        const detector = new window.BarcodeDetector({ formats: ['qr_code'] });
        let stopped = false;
        qrScanStop = async () => {
          stopped = true;
          try {
            if (video) {
              video.pause();
              video.srcObject = null;
            }
          } catch {}
          try {
            if (qrScanStream) {
              qrScanStream.getTracks().forEach(t => t.stop());
            }
          } catch {}
          qrScanStream = null;
          qrScanStop = null;
        };

        const loop = async () => {
          if (stopped) return;
          try {
            const results = await detector.detect(video);
            if (Array.isArray(results) && results.length > 0) {
              const raw = results[0]?.rawValue;
              if (setSendRecipientFromQr(raw)) {
                await qrScanStop();
                window.closeQrScanner();
                return;
              }
            }
          } catch {}
          requestAnimationFrame(loop);
        };

        requestAnimationFrame(loop);
      } catch (e) {
        alert('Failed to open camera: ' + (e?.message || String(e)));
        try {
          if (qrScanStop) await qrScanStop();
        } catch {}
        try {
          window.closeQrScanner();
        } catch {}
      }
    };

    window.closeQrScanner = async () => {
      try {
        if (qrHtml5) {
          try {
            await qrHtml5.stop();
            qrHtml5.clear();
          } catch {}
          qrHtml5 = null;
        }
        if (qrScanStop) await qrScanStop();
      } catch {}
      const overlay = document.getElementById('qrScannerOverlay');
      if (overlay) overlay.classList.remove('active');

      try {
        const video = document.getElementById('qrVideo');
        const reader = document.getElementById('qrReader');
        if (video) video.style.display = '';
        if (reader) {
          reader.style.display = 'none';
          reader.innerHTML = '';
        }
      } catch {}
    };

    async function broadcastTx(base, txHex) {
      const { text, res } = await fetchText(`${base}/tx`, {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain' },
        body: String(txHex || '').trim(),
      });
      const ct = String(res.headers.get('content-type') || '');
      if (ct.includes('application/json')) {
        const json = JSON.parse(text);
        return String(json?.txid || '').trim();
      }
      return String(text || '').trim();
    }

    window.initWalletExtras = async () => {
      try {
        const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
        const address = wallet.paymentAddress || wallet.address;
        if (address) {
          document.getElementById('receiveAddress').textContent = address;
          const uri = `bitcoin:${address}`;
          document.getElementById('receiveQr').src = `/api/qr.png?text=${encodeURIComponent(uri)}`;
        }
      } catch {}

      try {
        const usdEl = document.getElementById('sendAmountUsd');
        const satsEl = document.getElementById('sendAmountSats');
        const feeSel = document.getElementById('sendFeePriority');
        const feeCustom = document.getElementById('sendFeeRateCustom');
        if (usdEl) usdEl.addEventListener('input', () => window.updateSatsFromUsd());
        if (satsEl) satsEl.addEventListener('input', async () => {
          try { await window.updateUsdFromSats(); } catch {}
          try { await updateSendFeeEstimate(); } catch {}
        });
        if (feeSel) feeSel.addEventListener('change', async () => {
          try { await window.updateSendFeePriority(); } catch {}
        });
        if (feeCustom) feeCustom.addEventListener('input', async () => {
          try { await window.updateSendFeePriority(); } catch {}
        });

        const rate = await getBtcUsdRate();
        const rateEl = document.getElementById('sendUsdRate');
        if (rateEl) rateEl.textContent = rate > 0 ? `1 BTC ‚âà ${formatUsd(rate)}` : '';
      } catch {}

      try {
        await refreshBalance();
      } catch {}
    };

    window.copyReceiveAddress = async () => {
      try {
        const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
        const address = wallet.paymentAddress || wallet.address;
        if (!address) {
          alert('No address');
          return;
        }
        await navigator.clipboard.writeText(address);
      } catch {
        alert('Copy failed');
      }
    };

    window.refreshBalance = async () => {
      const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
      const address = wallet.paymentAddress || wallet.address;
      if (!address) return;

      document.getElementById('btcBalance').textContent = 'Loading...';
      document.getElementById('btcConfirmed').textContent = '-';
      document.getElementById('btcUnconfirmed').textContent = '-';

      const info = await withChainProvider((base) => fetchJson(`${base}/address/${address}`));
      const chain = info?.chain_stats || {};
      const mempool = info?.mempool_stats || {};

      const confirmed = (Number(chain.funded_txo_sum || 0) - Number(chain.spent_txo_sum || 0));
      const unconfirmed = (Number(mempool.funded_txo_sum || 0) - Number(mempool.spent_txo_sum || 0));
      const total = confirmed + unconfirmed;

      walletConfirmedSats = Number(confirmed || 0);

      // Cache confirmed UTXOs for fee estimation + Send Max.
      try {
        const utxosRaw = await withChainProvider((base) => fetchJson(`${base}/address/${address}/utxo`));
        const utxos = Array.isArray(utxosRaw) ? utxosRaw : [];
        walletConfirmedUtxos = utxos
          .filter((u) => u && u.txid && (u.status?.confirmed === true))
          .map((u) => ({ txid: String(u.txid), vout: Number(u.vout), value: Number(u.value) }));
      } catch {
        walletConfirmedUtxos = [];
      }

      let rate = 0;
      try {
        rate = await getBtcUsdRate();
      } catch {
        rate = 0;
      }

      const usdForSats = (sats) => {
        if (!rate || rate <= 0) return '';
        const usd = (Number(sats || 0) / 1e8) * rate;
        return formatUsd(usd);
      };

      const fmt = (sats) => {
        const usd = usdForSats(sats);
        return usd ? `${sats} sats (${satsToBtcString(sats)} BTC | ${usd})` : `${sats} sats (${satsToBtcString(sats)} BTC)`;
      };

      document.getElementById('btcConfirmed').textContent = fmt(confirmed);
      document.getElementById('btcUnconfirmed').textContent = fmt(unconfirmed);
      document.getElementById('btcBalance').textContent = fmt(total);

      try {
        await loadRecentTransactions();
      } catch {}

      try {
        walletLastFeeRate = await getRecommendedFeeRate(walletFeePriority, withChainProvider);
      } catch {}
      try {
        await updateSendFeeEstimate();
      } catch {}
    };

    window.sendBtc = async () => {
      const statusEl = document.getElementById('sendStatus');
      const setStatus = (t) => {
        if (statusEl) statusEl.textContent = t;
      };

      try {
        const toAddressRaw = String(document.getElementById('sendToAddress').value || '').trim();
        if (!toAddressRaw) {
          alert('Enter recipient address');
          return;
        }

        let toAddress = toAddressRaw;
        if (toAddressRaw.includes('@') && !isBtcAddress(toAddressRaw)) {
          setStatus('Resolving pay handle...');
          toAddress = await resolvePayHandle(toAddressRaw);
          try {
            document.getElementById('sendToAddress').value = toAddress;
          } catch {}
        }

        let amountSatsInput = 0;
        try {
          amountSatsInput = parseSatsFromInput(document.getElementById('sendAmountSats').value || '');
          // normalize back to sats if user pasted BTC-style decimal
          document.getElementById('sendAmountSats').value = String(amountSatsInput || '');
        } catch {}
        const amountUsdInput = Number(document.getElementById('sendAmountUsd')?.value || 0);
        const feeSpeed = walletFeePriority;

        let amountSats = 0;
        if (Number.isFinite(amountSatsInput) && amountSatsInput > 0) {
          amountSats = Math.floor(amountSatsInput);
        } else if (Number.isFinite(amountUsdInput) && amountUsdInput > 0) {
          setStatus('Converting USD to sats...');
          const rate = await getBtcUsdRate();
          if (rate <= 0) {
            alert('Could not fetch BTC/USD rate. Enter the amount in sats instead.');
            setStatus('');
            return;
          }
          amountSats = Math.floor((amountUsdInput / rate) * 1e8);
          if (amountSats > 0) {
            try {
              const satsEl = document.getElementById('sendAmountSats');
              if (satsEl) satsEl.value = String(amountSats);
            } catch {}
          }
        }

        if (!Number.isFinite(amountSats) || amountSats <= 0) {
          alert('Enter a valid amount (USD or sats)');
          setStatus('');
          return;
        }

        const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
        const fromAddress = wallet.paymentAddress || wallet.address;
        if (!fromAddress) {
          alert('No wallet address');
          return;
        }

        if (!window.AuthoBTC || typeof window.AuthoBTC.buildAndSignP2WPKH !== 'function') {
          alert('Signing library not loaded');
          return;
        }

        const vaultStr = localStorage.getItem('autho_wallet_vault');
        if (!vaultStr) {
          alert('No encrypted wallet vault found on this device. Please sign in again to restore it.');
          return;
        }

        let vault;
        try {
          vault = JSON.parse(vaultStr);
        } catch {
          alert('Wallet vault is corrupted. Please sign in again.');
          return;
        }

        const getSecret = (attempt) => {
          const label = attempt > 1
            ? 'Unlock failed. Enter your wallet passcode again (the 6+ character passcode you set when creating/importing your wallet):'
            : 'Enter your wallet passcode to unlock and send BTC:';
          return prompt(label);
        };

        const secret1 = getSecret(1);
        if (!secret1) return;

        setStatus('Fetching UTXOs...');
        const utxosRaw = await withChainProvider((base) => fetchJson(`${base}/address/${fromAddress}/utxo`));
        const utxos = Array.isArray(utxosRaw) ? utxosRaw : [];
        const spendable = utxos
          .filter((u) => u && u.txid && (u.status?.confirmed === true))
          .map((u) => ({ txid: String(u.txid), vout: Number(u.vout), value: Number(u.value) }));

        if (spendable.length === 0) {
          alert('No confirmed funds available to spend yet.');
          setStatus('');
          return;
        }

        setStatus('Getting fee estimates...');

        const feeRate = await getRecommendedFeeRate(feeSpeed, withChainProvider);
        walletLastFeeRate = feeRate;
        try {
          const feeEl = document.getElementById('sendFeeInfo');
          if (feeEl) {
            const info = estimateFeeInfoForSpend(spendable, amountSats, feeRate);
            const safetyBuffer = Math.max(0, Math.min(100, Math.floor(Number(walletConfirmedSats || 0) * 0.001)));
            feeEl.textContent = `Fee: ${String(walletFeePriority)} (~${formatSatPerVb(feeRate)} sat/vB | ~${Number(info.feeSats).toLocaleString()} sats | buffer: ${Number(safetyBuffer).toLocaleString()} sats | ~${Math.round(info.vbytes)} vB | inputs: ${info.inputCount} | assumes change)`;
          }
        } catch {}

        setStatus('Unlocking vault...');
        let payload;
        try {
          payload = await decryptWalletVault(vault, secret1);
        } catch {
          const secret2 = getSecret(2);
          if (!secret2) {
            setStatus('');
            return;
          }
          try {
            payload = await decryptWalletVault(vault, secret2);
          } catch {
            alert('Failed to decrypt wallet vault. Incorrect passcode.');
            setStatus('');
            return;
          }
        }

        const mnemonic = String(payload?.mnemonic || '');
        if (!mnemonic) {
          alert('Mnemonic missing in vault');
          setStatus('');
          return;
        }

        setStatus('Signing transaction locally...');
        const network = getWalletNetworkName();
        const signed = window.AuthoBTC.buildAndSignP2WPKH({
          mnemonic,
          toAddress,
          amountSats,
          utxos: spendable,
          feeRateSatPerVb: feeRate,
          network,
        });

        setStatus('Broadcasting...');
        const txid = await withChainProvider((base) => broadcastTx(base, signed.txHex));
        setStatus(`Sent. TXID: ${txid}`);

        try {
          await refreshBalance();
        } catch {}
      } catch (e) {
        alert('Send failed: ' + (e?.message || String(e)));
        try {
          const statusEl = document.getElementById('sendStatus');
          if (statusEl) statusEl.textContent = '';
        } catch {}
      }
    };

    window.createWallet = async () => {
      const passcode = document.getElementById('createPasscode').value;
      const confirm = document.getElementById('confirmPasscode').value;

      if (passcode.length < 6) {
        alert('Passcode must be at least 6 characters');
        return;
      }

      if (passcode !== confirm) {
        alert('Passcodes do not match');
        return;
      }

      showScreen('loadingScreen');
      document.getElementById('loadingText').textContent = 'Creating wallet...';

      try {
        if (!window.AuthoBTC || typeof window.AuthoBTC.generateMnemonic24 !== 'function') {
          throw new Error('Wallet library not loaded');
        }

        const network = getWalletNetworkName();
        const mnemonic = window.AuthoBTC.generateMnemonic24();
        const address = window.AuthoBTC.getAddressFromMnemonic(mnemonic, network, 0, 0);
        const publicKey = window.AuthoBTC.getPublicKeyFromMnemonic(mnemonic, network, 0, 0);
        transientMnemonic = String(mnemonic || '');

        const wallet = {
          publicKey,
          address,
          paymentAddress: address,
          network,
          derivationPath: "m/84'/0'/0'/0/0"
        };

        localStorage.setItem('autho_wallet', JSON.stringify(wallet));
        localStorage.setItem('autho_wallet_encrypted', btoa(JSON.stringify({ createdAt: Date.now() })));
        
        // Set PIN
        const pinHash = btoa(passcode);
        localStorage.setItem('autho_wallet_pin', pinHash);

        // Create encrypted vault with the passcode so sending BTC works
        try {
          const vaultPayload = {
            mnemonic,
            publicKey,
            address,
            paymentAddress: address,
            network,
            derivationPath: wallet.derivationPath || "m/84'/0'/0'/0/0",
            createdAt: Date.now()
          };
          const walletVault = await encryptWalletVault(vaultPayload, passcode);
          localStorage.setItem('autho_wallet_vault', JSON.stringify(walletVault));
        } catch (e) {
          console.error('Failed to create wallet vault:', e);
        }
        
        // Display seed
        const seedContainer = document.getElementById('seedWords');
        seedContainer.innerHTML = '';
        const words = walletData.mnemonic.split(' ');
        words.forEach((word, i) => {
          seedContainer.innerHTML += `
            <div class="seed-word">
              <span class="seed-word-num">${i + 1}</span>
              <span class="seed-word-text">${word}</span>
            </div>
          `;
        });

        showScreen('showSeedScreen');
      } catch (error) {
        alert('Error creating wallet: ' + error.message);
        showScreen('createWalletScreen');
      }
    };

    window.copySeedPhrase = async () => {
      try {
        const decodedSeed = transientMnemonic;
        if (!decodedSeed) {
          alert('Seed phrase is not available on this screen.');
          return;
        }
        
        // Copy to clipboard
        await navigator.clipboard.writeText(decodedSeed);
        
        // Visual feedback
        const btn = document.getElementById('copySeedBtn');
        const icon = document.getElementById('copyIcon');
        const text = document.getElementById('copyText');
        
        btn.classList.add('copied');
        icon.textContent = '‚úÖ';
        text.textContent = 'Copied!';
        
        // Reset after 3 seconds
        setTimeout(() => {
          btn.classList.remove('copied');
          icon.textContent = 'üìã';
          text.textContent = 'Copy to Clipboard';
        }, 3000);
        
      } catch (error) {
        console.error('Failed to copy:', error);
        alert('Failed to copy to clipboard. Please write down the words manually.');
      }
    };

    window.completeSeedBackup = () => {
      // Show account setup screen instead of going directly to wallet
      try {
        const seedContainer = document.getElementById('seedWords');
        if (seedContainer) seedContainer.innerHTML = '';
      } catch {}
      showScreen('accountSetupScreen');
    };

    window.skipAccountSetup = () => {
      try {
        const seedContainer = document.getElementById('seedWords');
        if (seedContainer) seedContainer.innerHTML = '';
      } catch {}
      transientMnemonic = '';
      loadWalletInfo();
      showScreen('walletInfoScreen');
    };

    window.registerAccount = async () => {
      const username = document.getElementById('accountUsername').value.trim();
      const email = document.getElementById('accountEmail').value.trim();
      const password = document.getElementById('accountPassword').value;
      const passwordConfirm = document.getElementById('accountPasswordConfirm').value;
      
      const errorEl = document.getElementById('accountError');
      const successEl = document.getElementById('accountSuccess');
      errorEl.style.display = 'none';
      successEl.style.display = 'none';

      // Validation
      if (!username || !email || !password) {
        errorEl.textContent = 'Please fill in all fields';
        errorEl.style.display = 'block';
        return;
      }

      if (!isValidPassword(password)) {
        errorEl.textContent = 'Password must be either a 14+ character passphrase (with spaces) or a 12+ character password with upper/lower/digit/special.';
        errorEl.style.display = 'block';
        return;
      }

      if (password !== passwordConfirm) {
        errorEl.textContent = 'Passwords do not match';
        errorEl.style.display = 'block';
        return;
      }

      // Get wallet data
      const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
      if (!wallet.address || !wallet.publicKey) {
        errorEl.textContent = 'Wallet data not found. Please create wallet first.';
        errorEl.style.display = 'block';
        return;
      }

      if (!transientMnemonic) {
        errorEl.textContent = 'Seed phrase is not available in this session. Please create a new wallet so you can back up your seed phrase before registering.';
        errorEl.style.display = 'block';
        return;
      }

      const emailHash = await sha256Hex(email.trim().toLowerCase());
      const walletPayload = {
        mnemonic: transientMnemonic,
        publicKey: wallet.publicKey,
        address: wallet.address,
        paymentAddress: wallet.paymentAddress || wallet.address,
        network: wallet.network || 'mainnet',
        derivationPath: wallet.derivationPath || "m/84'/0'/0'/0/0",
        createdAt: Date.now()
      };
      const walletVault = await encryptWalletVault(walletPayload, password);

      localStorage.setItem('autho_wallet_vault', JSON.stringify(walletVault));

      try {
        showScreen('loadingScreen');
        document.getElementById('loadingText').textContent = 'Creating account...';

        const response = await fetch('/api/users/register', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            username,
            email,
            bitcoinAddress: wallet.address,
            publicKey: wallet.publicKey,
            password,
            role: 'customer',
            emailHash,
            walletVault,
            passwordKdf: walletVault.kdf
          })
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Registration failed');
        }

        // Store account info
        localStorage.setItem('autho_account_id', data.accountId);
        localStorage.setItem('autho_username', username);
        localStorage.setItem('autho_email', email);

        // Wipe seed from memory after vault is created
        transientMnemonic = '';

        successEl.textContent = '‚úÖ Account created successfully!';
        successEl.style.display = 'block';

        setTimeout(() => {
          loadWalletInfo();
          showScreen('walletInfoScreen');
        }, 2000);

      } catch (error) {
        showScreen('accountSetupScreen');
        errorEl.textContent = 'Error: ' + error.message;
        errorEl.style.display = 'block';
      }
    };

    document.getElementById('seedBackedUp')?.addEventListener('change', (e) => {
      document.getElementById('continueBtn').disabled = !e.target.checked;
    });

    window.importWallet = async () => {
      const seed = document.getElementById('importSeed').value.trim();
      const passcode = document.getElementById('importPasscode').value;

      const words = seed.toLowerCase().split(/\s+/);
      if (!seed || words.length !== 24) {
        alert('Please enter a valid 24-word seed phrase');
        return;
      }

      if (passcode.length < 6) {
        alert('Passcode must be at least 6 characters');
        return;
      }

      showScreen('loadingScreen');
      document.getElementById('loadingText').textContent = 'Importing wallet...';

      try {
        if (!window.AuthoBTC || typeof window.AuthoBTC.getAddressFromMnemonic !== 'function') {
          throw new Error('Wallet library not loaded');
        }

        const network = getWalletNetworkName();
        const address = window.AuthoBTC.getAddressFromMnemonic(seed, network, 0, 0);
        const publicKey = window.AuthoBTC.getPublicKeyFromMnemonic(seed, network, 0, 0);
        transientMnemonic = seed;

        const wallet = {
          publicKey,
          address,
          paymentAddress: address,
          network,
          derivationPath: "m/84'/0'/0'/0/0"
        };

        localStorage.setItem('autho_wallet', JSON.stringify(wallet));
        localStorage.setItem('autho_wallet_encrypted', btoa(JSON.stringify({ createdAt: Date.now() })));
        
        // Set PIN
        const pinHash = btoa(passcode);
        localStorage.setItem('autho_wallet_pin', pinHash);

        // Create encrypted vault with the passcode so sending BTC works
        try {
          const vaultPayload = {
            mnemonic: seed,
            publicKey,
            address,
            paymentAddress: address,
            network,
            derivationPath: wallet.derivationPath || "m/84'/0'/0'/0/0",
            createdAt: Date.now()
          };
          const walletVault = await encryptWalletVault(vaultPayload, passcode);
          localStorage.setItem('autho_wallet_vault', JSON.stringify(walletVault));
        } catch (e) {
          console.error('Failed to create wallet vault:', e);
        }

        showScreen('showSeedScreen');

        // Display seed
        try {
          const seedContainer = document.getElementById('seedWords');
          seedContainer.innerHTML = '';
          const words = seed.split(' ');
          words.forEach((word, i) => {
            seedContainer.innerHTML += `
              <div class="seed-word">
                <span class="seed-word-num">${i + 1}</span>
                <span class="seed-word-text">${word}</span>
              </div>
            `;
          });
        } catch {}
      } catch (error) {
        alert('Error importing wallet: ' + error.message);
        showScreen('importWalletScreen');
      }
    };

    window.showExportSeed = async () => {
      const confirmed = confirm('‚ö†Ô∏è WARNING: Your seed phrase gives full access to your Bitcoin. Only export it in a secure, private location. Continue?');
      if (confirmed) {
        const password = prompt('Enter your account password to export your seed phrase:');
        if (!password) return;

        const vaultStr = localStorage.getItem('autho_wallet_vault');
        if (!vaultStr) {
          alert('No encrypted wallet vault found on this device. Please sign in again to restore it.');
          return;
        }

        let vault;
        try {
          vault = JSON.parse(vaultStr);
        } catch {
          alert('Wallet vault is corrupted. Please sign in again.');
          return;
        }

        let payload;
        try {
          payload = await decryptWalletVault(vault, password);
        } catch (e) {
          alert('Failed to decrypt wallet vault. Incorrect password.');
          return;
        }

        const seed = String(payload?.mnemonic || '');
        if (!seed) {
          alert('Seed phrase missing in vault.');
          return;
        }

        const content = `Autho Seed Phrase Backup\n\nDate: ${new Date().toISOString()}\n\nSeed Phrase:\n${seed}\n`;
        try {
          const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          const dateStamp = new Date().toISOString().slice(0, 10);
          a.href = url;
          a.download = `autho-seed-phrase-${dateStamp}.txt`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 2000);
        } catch (e) {
          alert('Your seed phrase:\n\n' + seed + '\n\nWrite this down and keep it safe!');
        }
      }
    };

    window.confirmDeleteWallet = () => {
      const confirmed = confirm('‚ö†Ô∏è WARNING: This will permanently delete your wallet from this device. Make sure you have your seed phrase backed up. Continue?');
      if (confirmed) {
        const doubleConfirm = confirm('Are you absolutely sure? This cannot be undone without your seed phrase.');
        if (doubleConfirm) {
          localStorage.removeItem('autho_wallet');
          localStorage.removeItem('autho_wallet_encrypted');
          showScreen('noWalletScreen');
        }
      }
    };

    // ============================================================
    // SERVICE BALANCE FUNCTIONS
    // ============================================================

    let serviceBalanceData = {
      balance: 0,
      totalFunded: 0,
      totalUsed: 0,
      lastFunded: null,
      paymentAddress: null,
    };

    window.refreshServiceBalance = async () => {
      try {
        const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
        const accountId = wallet.identityAddress || wallet.paymentAddress;
        if (!accountId) {
          console.log('No wallet found for service balance');
          return;
        }

        const res = await fetch(`/api/accounts/${accountId}/service-balance`);
        if (res.ok) {
          const data = await res.json();
          if (data.success) {
            serviceBalanceData.balance = data.serviceBalanceSats || 0;
            serviceBalanceData.totalFunded = data.serviceBalanceTotalFundedSats || 0;
            serviceBalanceData.totalUsed = data.serviceBalanceTotalUsedSats || 0;
            serviceBalanceData.lastFunded = data.serviceBalanceLastFundedAt;
            updateServiceBalanceUI();
          }
        }
      } catch (e) {
        console.error('Failed to fetch service balance:', e);
      }

      // Also fetch pricing
      try {
        const pricingRes = await fetch('/api/service/pricing');
        if (pricingRes.ok) {
          const pricingData = await pricingRes.json();
          if (pricingData.success && pricingData.pricing) {
            const p = pricingData.pricing;
            document.getElementById('priceDeleteMessage').textContent = (p.message_delete?.sats || 50) + ' sats';
            document.getElementById('priceEditMessage').textContent = (p.message_edit?.sats || 25) + ' sats';
            document.getElementById('priceProfileUpdate').textContent = (p.profile_update?.sats || 100) + ' sats';
            document.getElementById('priceCreateGroup').textContent = (p.group_create?.sats || 200) + ' sats';
          }
        }
      } catch (e) {
        console.error('Failed to fetch pricing:', e);
      }
    };

    function updateServiceBalanceUI() {
      document.getElementById('serviceBalanceSats').textContent = serviceBalanceData.balance.toLocaleString();
      document.getElementById('serviceTotalFunded').textContent = serviceBalanceData.totalFunded.toLocaleString() + ' sats';
      document.getElementById('serviceTotalUsed').textContent = serviceBalanceData.totalUsed.toLocaleString() + ' sats';
      
      if (serviceBalanceData.lastFunded) {
        const date = new Date(serviceBalanceData.lastFunded);
        document.getElementById('serviceLastFunded').textContent = date.toLocaleDateString();
      } else {
        document.getElementById('serviceLastFunded').textContent = 'Never';
      }
    }

    window.showFundServiceBalance = async () => {
      try {
        const res = await fetch('/api/service/payment-address');
        if (res.ok) {
          const data = await res.json();
          if (data.success && data.paymentAddress) {
            serviceBalanceData.paymentAddress = data.paymentAddress;
            document.getElementById('fundingAddress').textContent = data.paymentAddress;
            try {
              const amtEl = document.getElementById('fundServiceAmountSats');
              if (amtEl && !String(amtEl.value || '').trim()) {
                amtEl.value = '1000';
              }
            } catch {}
            
            // Generate QR code
            if (window.QRCode) {
              const qrCanvas = document.createElement('canvas');
              QRCode.toCanvas(qrCanvas, `bitcoin:${data.paymentAddress}`, { width: 200 }, (err) => {
                if (!err) {
                  document.getElementById('fundingQr').src = qrCanvas.toDataURL();
                }
              });
            } else {
              // Fallback: use API to generate QR
              document.getElementById('fundingQr').src = `/api/qr?data=${encodeURIComponent('bitcoin:' + data.paymentAddress)}&size=200`;
            }
          }
        }
      } catch (e) {
        console.error('Failed to get payment address:', e);
        document.getElementById('fundingAddress').textContent = 'Error loading address';
      }
      
      document.getElementById('fundServiceOverlay').classList.add('active');
    };

    window.closeFundServiceOverlay = () => {
      document.getElementById('fundServiceOverlay').classList.remove('active');
      document.getElementById('verifyTxid').value = '';
      document.getElementById('verifyStatus').textContent = '';
      try {
        const s = document.getElementById('fundServiceStatus');
        if (s) s.textContent = '';
      } catch {}
    };

    window.fundServiceBalance = async () => {
      const statusEl = document.getElementById('fundServiceStatus');
      const setStatus = (html) => {
        if (statusEl) statusEl.innerHTML = html;
      };

      try {
        setStatus('<span style="color: #d4af37;">Preparing payment...</span>');

        // Ensure we have the service payment address
        if (!serviceBalanceData.paymentAddress) {
          await window.showFundServiceBalance();
        }
        const toAddress = String(serviceBalanceData.paymentAddress || '').trim();
        if (!toAddress) {
          setStatus('<span style="color: #ff5757;">Could not load service payment address</span>');
          return;
        }

        // Read amount
        const amtRaw = String(document.getElementById('fundServiceAmountSats')?.value || '').trim();
        const amountSats = parseSatsFromInput(amtRaw);
        if (!Number.isFinite(amountSats) || amountSats <= 0) {
          setStatus('<span style="color: #ff5757;">Enter a valid sats amount</span>');
          return;
        }
        if (amountSats < 1000) {
          setStatus('<span style="color: #ff5757;">Minimum is 1,000 sats</span>');
          return;
        }

        const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
        const fromAddress = wallet.paymentAddress || wallet.address;
        if (!fromAddress) {
          setStatus('<span style="color: #ff5757;">No wallet address found</span>');
          return;
        }

        if (!window.AuthoBTC || typeof window.AuthoBTC.buildAndSignP2WPKH !== 'function') {
          setStatus('<span style="color: #ff5757;">Signing library not loaded</span>');
          return;
        }

        const vaultStr = localStorage.getItem('autho_wallet_vault');
        if (!vaultStr) {
          setStatus('<span style="color: #ff5757;">Wallet vault missing. Please sign in again.</span>');
          return;
        }

        let vault;
        try {
          vault = JSON.parse(vaultStr);
        } catch {
          setStatus('<span style="color: #ff5757;">Wallet vault is corrupted. Please sign in again.</span>');
          return;
        }

        const getSecret = (attempt) => {
          const label = attempt > 1
            ? 'Unlock failed. Enter your wallet passcode again:'
            : 'Enter your wallet passcode to fund service credits:';
          return prompt(label);
        };

        const secret1 = getSecret(1);
        if (!secret1) {
          setStatus('');
          return;
        }

        setStatus('<span style="color: #d4af37;">Fetching UTXOs...</span>');
        const utxosRaw = await withChainProvider((base) => fetchJson(`${base}/address/${fromAddress}/utxo`));
        const utxos = Array.isArray(utxosRaw) ? utxosRaw : [];
        const spendable = utxos
          .filter((u) => u && u.txid && (u.status?.confirmed === true))
          .map((u) => ({ txid: String(u.txid), vout: Number(u.vout), value: Number(u.value) }));

        if (spendable.length === 0) {
          setStatus('<span style="color: #ff5757;">No confirmed funds available yet.</span>');
          return;
        }

        setStatus('<span style="color: #d4af37;">Getting fee estimates...</span>');
        const feeRate = await getRecommendedFeeRate(walletFeePriority, withChainProvider);

        setStatus('<span style="color: #d4af37;">Unlocking vault...</span>');
        let payload;
        try {
          payload = await decryptWalletVault(vault, secret1);
        } catch {
          const secret2 = getSecret(2);
          if (!secret2) {
            setStatus('');
            return;
          }
          try {
            payload = await decryptWalletVault(vault, secret2);
          } catch {
            setStatus('<span style="color: #ff5757;">Incorrect passcode</span>');
            return;
          }
        }

        const mnemonic = String(payload?.mnemonic || '');
        if (!mnemonic) {
          setStatus('<span style="color: #ff5757;">Mnemonic missing in vault</span>');
          return;
        }

        setStatus('<span style="color: #d4af37;">Signing transaction locally...</span>');
        const network = getWalletNetworkName();
        const signed = window.AuthoBTC.buildAndSignP2WPKH({
          mnemonic,
          toAddress,
          amountSats,
          utxos: spendable,
          feeRateSatPerVb: feeRate,
          network,
        });

        setStatus('<span style="color: #d4af37;">Broadcasting...</span>');
        const txid = await withChainProvider((base) => broadcastTx(base, signed.txHex));
        if (!txid || !/^[a-fA-F0-9]{64}$/.test(txid)) {
          setStatus('<span style="color: #ff5757;">Broadcast returned an invalid txid</span>');
          return;
        }

        // Auto-verify and credit
        setStatus(`<span style="color: #d4af37;">Sent. Verifying payment...</span><div style="margin-top:6px; font-family:'Courier New', monospace; font-size: 11px; color:#999;">TXID: ${txid}</div>`);
        try {
          const accountId = wallet.identityAddress || wallet.paymentAddress;
          if (!accountId) {
            try { document.getElementById('verifyTxid').value = txid; } catch {}
            setStatus('<span style="color: #ff5757;">Sent, but could not find your account ID for auto-credit. Use manual verify below.</span>');
            return;
          }
          const res = await fetch(`/api/accounts/${accountId}/service-balance/verify-payment`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ txid }),
          });
          const data = await res.json();
          if (data.success) {
            setStatus(`<span style="color: #4cd964;">‚úì Funded! Credited ${data.amountCredited?.toLocaleString() || amountSats.toLocaleString()} sats</span>`);
            await refreshServiceBalance();
            setTimeout(() => {
              closeFundServiceOverlay();
            }, 1500);
          } else {
            // Fallback: prefill manual verify field
            try { document.getElementById('verifyTxid').value = txid; } catch {}
            setStatus(`<span style="color: #ff5757;">Sent, but auto-verify failed: ${escapeHtml(data.error || 'Unknown error')}</span>`);
          }
        } catch (e) {
          try { document.getElementById('verifyTxid').value = txid; } catch {}
          setStatus(`<span style="color: #ff5757;">Sent, but verify error: ${escapeHtml(e.message)}</span>`);
        }

        try {
          await refreshBalance();
        } catch {}
      } catch (e) {
        setStatus(`<span style="color: #ff5757;">Funding failed: ${escapeHtml(e?.message || String(e))}</span>`);
      }
    };

    window.copyFundingAddress = async () => {
      const address = serviceBalanceData.paymentAddress;
      if (!address) return;
      
      try {
        await navigator.clipboard.writeText(address);
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = 'Copied!';
        btn.style.background = 'rgba(76, 217, 100, 0.2)';
        btn.style.borderColor = '#4cd964';
        btn.style.color = '#4cd964';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.background = '';
          btn.style.borderColor = '';
          btn.style.color = '';
        }, 2000);
      } catch (e) {
        alert('Failed to copy: ' + address);
      }
    };

    window.verifyFundingPayment = async () => {
      const txid = document.getElementById('verifyTxid').value.trim();
      const statusEl = document.getElementById('verifyStatus');
      
      if (!txid) {
        statusEl.innerHTML = '<span style="color: #ff5757;">Please enter a transaction ID</span>';
        return;
      }
      
      if (!/^[a-fA-F0-9]{64}$/.test(txid)) {
        statusEl.innerHTML = '<span style="color: #ff5757;">Invalid transaction ID format</span>';
        return;
      }
      
      statusEl.innerHTML = '<span style="color: #d4af37;">Verifying payment...</span>';
      
      try {
        const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
        const accountId = wallet.identityAddress || wallet.paymentAddress;
        
        const res = await fetch(`/api/accounts/${accountId}/service-balance/verify-payment`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ txid }),
        });
        
        const data = await res.json();
        
        if (data.success) {
          statusEl.innerHTML = `<span style="color: #4cd964;">‚úì Payment verified! Credited ${data.amountCredited?.toLocaleString() || 0} sats</span>`;
          await refreshServiceBalance();
          setTimeout(() => {
            closeFundServiceOverlay();
          }, 2000);
        } else {
          statusEl.innerHTML = `<span style="color: #ff5757;">‚úó ${data.error || 'Payment verification failed'}</span>`;
        }
      } catch (e) {
        statusEl.innerHTML = `<span style="color: #ff5757;">‚úó Error: ${e.message}</span>`;
      }
    };

    // Auto-refresh service balance when wallet screen loads
    const originalShowWallet = window.showWalletInfo;
    window.showWalletInfo = async () => {
      if (originalShowWallet) await originalShowWallet();
      refreshServiceBalance();
    };

    // Initial load if wallet exists
    if (localStorage.getItem('autho_wallet')) {
      setTimeout(refreshServiceBalance, 500);
    }
  </script>
</body>
</html>
