<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Messages - Autho</title>
  <link rel="stylesheet" href="/css/mobile-common.css">
  <style>
    .messages-container {
      max-width: 600px;
      margin: 0 auto;
      padding: 1rem;
    }

    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(212, 175, 55, 0.2);
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .back-to-dashboard {
      color: #d4af37;
      text-decoration: none;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.4rem 0.75rem;
      border: 1px solid rgba(212, 175, 55, 0.4);
      border-radius: 6px;
      background: rgba(212, 175, 55, 0.1);
      transition: all 0.2s;
    }

    .back-to-dashboard:hover {
      background: rgba(212, 175, 55, 0.2);
      border-color: #d4af37;
    }

    .page-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #d4af37;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .inbox-stats {
      font-size: 0.875rem;
      color: #888;
    }

    .conversation-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .conversation-card {
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.2);
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .conversation-card:hover {
      border-color: #d4af37;
      transform: translateY(-2px);
    }

    .conversation-card.unread {
      border-left: 3px solid #d4af37;
    }

    .conversation-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.5rem;
    }

    .conversation-participant {
      font-weight: 600;
      color: #fff;
    }

    .conversation-time {
      font-size: 0.75rem;
      color: #888;
    }

    .conversation-preview {
      font-size: 0.875rem;
      color: #aaa;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .conversation-item-badge {
      display: inline-block;
      background: rgba(212, 175, 55, 0.2);
      color: #d4af37;
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      margin-top: 0.5rem;
    }

    .unread-badge {
      background: #d4af37;
      color: #000;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 0.2rem 0.5rem;
      border-radius: 10px;
      min-width: 1.2rem;
      text-align: center;
    }

    .empty-inbox {
      text-align: center;
      padding: 3rem 1rem;
      color: #888;
    }

    .empty-inbox-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .empty-inbox-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #aaa;
      margin-bottom: 0.5rem;
    }

    /* Chat View */
    .chat-view {
      display: none;
      flex-direction: column;
      height: calc(100vh - 120px);
    }

    .chat-view.active {
      display: flex;
    }

    .chat-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: rgba(30, 30, 30, 0.9);
      border-bottom: 1px solid rgba(212, 175, 55, 0.2);
    }

    .chat-back-btn {
      background: none;
      border: none;
      color: #d4af37;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem;
    }

    .chat-participant-name {
      font-weight: 600;
      color: #fff;
    }

    .chat-item-context {
      font-size: 0.75rem;
      color: #888;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .message-bubble {
      max-width: 80%;
      padding: 0.75rem 1rem;
      border-radius: 16px;
      position: relative;
    }

    .message-bubble.sent {
      align-self: flex-end;
      background: #d4af37;
      color: #000;
      border-bottom-right-radius: 4px;
    }

    .message-bubble.received {
      align-self: flex-start;
      background: rgba(60, 60, 60, 0.9);
      color: #fff;
      border-bottom-left-radius: 4px;
    }

    .message-text {
      word-wrap: break-word;
    }

    .message-meta {
      font-size: 0.65rem;
      opacity: 0.7;
      margin-top: 0.25rem;
      text-align: right;
    }

    .message-expires {
      font-size: 0.6rem;
      color: #888;
    }

    .chat-input-area {
      display: flex;
      gap: 0.5rem;
      padding: 0.75rem;
      background: rgba(30, 30, 30, 0.9);
      border-top: 1px solid rgba(212, 175, 55, 0.2);
      align-items: center;
      flex-wrap: nowrap;
    }

    .chat-input {
      flex: 1;
      background: rgba(50, 50, 50, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 20px;
      padding: 0.75rem 1rem;
      color: #fff;
      font-size: 1rem;
    }

    .chat-input:focus {
      outline: none;
      border-color: #d4af37;
    }

    .chat-send-btn {
      background: #d4af37;
      border: none;
      border-radius: 50%;
      width: 44px;
      min-width: 44px;
      height: 44px;
      color: #000;
      font-size: 1.25rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .chat-send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Push-to-Talk Button */
    .ptt-btn {
      background: linear-gradient(145deg, #2a5d2a, #1a3d1a);
      border: 2px solid #4CAF50;
      border-radius: 50%;
      width: 44px;
      min-width: 44px;
      height: 44px;
      color: #fff;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.2s;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }

    .ptt-btn:active, .ptt-btn.recording {
      background: linear-gradient(145deg, #4CAF50, #2E7D32);
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
    }

    .ptt-icon {
      font-size: 1.1rem;
      line-height: 1;
    }

    .ptt-text {
      font-size: 0.5rem;
      font-weight: bold;
      text-transform: uppercase;
    }

    .ptt-recording {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #4CAF50;
      border-radius: 20px;
      padding: 2rem 3rem;
      z-index: 1000;
      text-align: center;
    }

    .ptt-recording.active {
      display: block;
    }

    .ptt-pulse {
      width: 60px;
      height: 60px;
      background: #4CAF50;
      border-radius: 50%;
      margin: 0 auto 1rem;
      animation: ptt-pulse 1s ease-in-out infinite;
    }

    @keyframes ptt-pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
    }

    .ptt-status {
      color: #fff;
      font-size: 1rem;
      font-weight: 500;
    }

    /* Auto-play indicator for voice messages */
    .voice-message {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid rgba(76, 175, 80, 0.4);
      border-radius: 12px;
      padding: 0.5rem;
    }

    .voice-message.new {
      animation: voice-new 0.5s ease-out;
    }

    @keyframes voice-new {
      0% { transform: scale(0.9); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    .encryption-notice {
      text-align: center;
      font-size: 0.7rem;
      color: #666;
      padding: 0.5rem;
    }

    .encryption-notice span {
      color: #4CAF50;
    }

    .loading-spinner {
      display: flex;
      justify-content: center;
      padding: 2rem;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(212, 175, 55, 0.2);
      border-top-color: #d4af37;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .nav-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .nav-tab {
      flex: 1;
      padding: 0.75rem;
      background: rgba(80, 80, 80, 0.6);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      color: #ccc;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    .nav-tab.active {
      background: rgba(212, 175, 55, 0.2);
      border-color: #d4af37;
      color: #d4af37;
    }

    .contacts-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .contact-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(30, 30, 30, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.2);
      border-radius: 8px;
      padding: 0.75rem 1rem;
    }

    .contact-info {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .contact-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(212, 175, 55, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #d4af37;
      font-weight: 600;
    }

    .contact-name {
      font-weight: 500;
      color: #fff;
    }

    .contact-role {
      font-size: 0.75rem;
      color: #888;
    }

    .contact-actions button {
      background: none;
      border: 1px solid rgba(212, 175, 55, 0.3);
      color: #d4af37;
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .share-btn {
      background: rgba(212, 175, 55, 0.2);
      border: 1px solid #d4af37;
      color: #d4af37;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .add-contact-btn {
      background: #d4af37;
      border: none;
      color: #000;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .contact-buttons {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 1rem;
    }

    .modal-content {
      background: #1a1a1a;
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 16px;
      padding: 1.5rem;
      max-width: 400px;
      width: 100%;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #d4af37;
    }

    .modal-close {
      background: none;
      border: none;
      color: #888;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .qr-container {
      background: #fff;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 1rem;
    }

    .qr-container canvas, .qr-container img {
      max-width: 200px;
    }

    .share-link-container {
      background: rgba(50, 50, 50, 0.5);
      border: 1px solid rgba(212, 175, 55, 0.2);
      border-radius: 8px;
      padding: 0.75rem;
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .share-link-input {
      flex: 1;
      background: none;
      border: none;
      color: #fff;
      font-size: 0.8rem;
      outline: none;
    }

    .copy-btn {
      background: #d4af37;
      border: none;
      color: #000;
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .modal-input {
      width: 100%;
      background: rgba(50, 50, 50, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 8px;
      padding: 0.75rem;
      color: #fff;
      font-size: 1rem;
      margin-bottom: 1rem;
    }

    .modal-input:focus {
      outline: none;
      border-color: #d4af37;
    }

    .modal-btn {
      width: 100%;
      background: #d4af37;
      border: none;
      color: #000;
      padding: 0.75rem;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
    }

    .modal-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .share-instructions {
      text-align: center;
      color: #888;
      font-size: 0.875rem;
      margin-bottom: 1rem;
    }

    .add-contact-chat-btn {
      background: rgba(212, 175, 55, 0.2);
      border: 1px solid #d4af37;
      color: #d4af37;
      padding: 0.4rem 0.75rem;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      white-space: nowrap;
    }

    .add-contact-chat-btn.added {
      background: rgba(76, 175, 80, 0.2);
      border-color: #4CAF50;
      color: #4CAF50;
    }

    /* Media Messaging Styles */
    .media-buttons {
      display: flex;
      gap: 0.25rem;
      padding-right: 0.5rem;
    }

    .media-btn {
      background: transparent;
      border: none;
      color: #888;
      font-size: 1.25rem;
      padding: 0.5rem;
      cursor: pointer;
      border-radius: 50%;
      transition: all 0.2s;
    }

    .media-btn:hover {
      color: #d4af37;
      background: rgba(212, 175, 55, 0.1);
    }

    .media-btn.recording {
      color: #ff4444;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .media-preview {
      background: rgba(30, 30, 30, 0.95);
      padding: 0.75rem;
      border-top: 1px solid rgba(212, 175, 55, 0.2);
      display: none;
    }

    .media-preview.active {
      display: block;
    }

    .media-preview-content {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .media-preview img,
    .media-preview video {
      max-width: 120px;
      max-height: 80px;
      border-radius: 8px;
      object-fit: cover;
    }

    .media-preview-info {
      flex: 1;
      color: #888;
      font-size: 0.75rem;
    }

    .media-preview-name {
      color: #fff;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .media-preview-remove {
      background: rgba(255, 68, 68, 0.2);
      border: none;
      color: #ff4444;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
    }

    .audio-recorder {
      display: none;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: rgba(30, 30, 30, 0.95);
      border-top: 1px solid rgba(212, 175, 55, 0.2);
    }

    .audio-recorder.active {
      display: flex;
    }

    .audio-timer {
      color: #ff4444;
      font-family: monospace;
      font-size: 1rem;
      min-width: 50px;
    }

    .audio-waveform {
      flex: 1;
      height: 30px;
      background: rgba(255, 68, 68, 0.1);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
    }

    .audio-bar {
      width: 3px;
      background: #ff4444;
      border-radius: 2px;
      animation: audioWave 0.5s ease-in-out infinite;
    }

    @keyframes audioWave {
      0%, 100% { height: 5px; }
      50% { height: 20px; }
    }

    .audio-cancel-btn {
      background: rgba(255, 68, 68, 0.2);
      border: none;
      color: #ff4444;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
    }

    .audio-send-btn {
      background: #d4af37;
      border: none;
      color: #000;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
    }

    .message-media {
      margin-top: 0.5rem;
      max-width: 250px;
    }

    .message-media img {
      width: 100%;
      border-radius: 8px;
      cursor: pointer;
    }

    .message-media video {
      width: 100%;
      border-radius: 8px;
    }

    .message-media audio {
      width: 100%;
      height: 36px;
    }

    .media-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .media-fullscreen.active {
      display: flex;
    }

    .media-fullscreen img,
    .media-fullscreen video {
      max-width: 95%;
      max-height: 95%;
      object-fit: contain;
    }

    .media-fullscreen-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .hidden-input {
      display: none;
    }
  </style>
</head>
<body>
  <div class="messages-container">
    <!-- Inbox View -->
    <div id="inboxView">
      <div class="page-header">
        <a href="/m/wallet" class="back-to-dashboard">‚Üê Dashboard</a>
        <div class="page-title">
          <span>üí¨</span> Messages
        </div>
        <div class="inbox-stats" id="inboxStats">Loading...</div>
      </div>

      <div class="nav-tabs">
        <div class="nav-tab active" data-tab="conversations" onclick="switchTab('conversations')">
          Conversations
        </div>
        <div class="nav-tab" data-tab="contacts" onclick="switchTab('contacts')">
          Contacts
        </div>
      </div>

      <div id="conversationsTab">
        <div id="conversationList" class="conversation-list">
          <div class="loading-spinner">
            <div class="spinner"></div>
          </div>
        </div>
      </div>

      <div id="contactsTab" style="display: none;">
        <div class="contact-buttons">
          <button class="share-btn" onclick="showShareModal()">
            <span>üì§</span> Share My Contact
          </button>
          <button class="add-contact-btn" onclick="showAddContactModal()">
            <span>‚ûï</span> Add Contact
          </button>
        </div>
        <div id="contactsList" class="contacts-list"></div>
      </div>

      <div class="encryption-notice">
        <span>üîí</span> End-to-end encrypted ‚Ä¢ Messages auto-delete after 10 days
      </div>
    </div>

    <!-- Chat View -->
    <div id="chatView" class="chat-view">
      <div class="chat-header">
        <button class="chat-back-btn" onclick="showInbox()">‚Üê</button>
        <div style="flex:1">
          <div class="chat-participant-name" id="chatParticipantName">Loading...</div>
          <div class="chat-item-context" id="chatItemContext"></div>
        </div>
        <button class="add-contact-chat-btn" id="addContactChatBtn" onclick="addCurrentRecipientToContacts()">
          ‚ûï Add
        </button>
      </div>

      <div class="chat-messages" id="chatMessages"></div>

      <div class="encryption-notice">
        <span>üîí</span> End-to-end encrypted
      </div>

      <!-- Media Preview -->
      <div class="media-preview" id="mediaPreview">
        <div class="media-preview-content">
          <div id="mediaPreviewThumb"></div>
          <div class="media-preview-info">
            <div class="media-preview-name" id="mediaPreviewName">Photo</div>
            <div id="mediaPreviewSize">0 KB</div>
          </div>
          <button class="media-preview-remove" onclick="clearMediaPreview()">√ó</button>
        </div>
      </div>

      <!-- Audio Recorder -->
      <div class="audio-recorder" id="audioRecorder">
        <div class="audio-timer" id="audioTimer">0:00</div>
        <div class="audio-waveform">
          <div class="audio-bar" style="animation-delay: 0s"></div>
          <div class="audio-bar" style="animation-delay: 0.1s"></div>
          <div class="audio-bar" style="animation-delay: 0.2s"></div>
          <div class="audio-bar" style="animation-delay: 0.3s"></div>
          <div class="audio-bar" style="animation-delay: 0.4s"></div>
        </div>
        <button class="audio-cancel-btn" onclick="cancelAudioRecording()">Cancel</button>
        <button class="audio-send-btn" onclick="sendAudioRecording()">Send</button>
      </div>

      <div class="chat-input-area">
        <div class="media-buttons">
          <button class="media-btn" onclick="document.getElementById('photoInput').click()" title="Send photo">üì∑</button>
          <button class="media-btn" onclick="document.getElementById('videoInput').click()" title="Send video">üé•</button>
          <button class="media-btn" id="audioBtn" onclick="toggleAudioRecording()" title="Record audio">üé§</button>
        </div>
        <input type="text" class="chat-input" id="messageInput" placeholder="Type a message..." 
               onkeypress="if(event.key==='Enter')sendMessage()">
        <button class="ptt-btn" id="pttBtn" title="Hold to talk">
          <span class="ptt-icon">üéôÔ∏è</span>
          <span class="ptt-text">Hold</span>
        </button>
        <button class="chat-send-btn" onclick="sendMessage()" id="sendBtn">‚û§</button>
      </div>
      
      <!-- Push-to-Talk Recording Indicator -->
      <div class="ptt-recording" id="pttRecording">
        <div class="ptt-pulse"></div>
        <div class="ptt-status">üéôÔ∏è Recording... Release to send</div>
      </div>

      <!-- Hidden file inputs -->
      <input type="file" id="photoInput" class="hidden-input" accept="image/*" capture="environment" onchange="handlePhotoSelect(event)">
      <input type="file" id="videoInput" class="hidden-input" accept="video/*" capture="environment" onchange="handleVideoSelect(event)">
    </div>
  </div>

  <!-- Fullscreen Media Viewer -->
  <div class="media-fullscreen" id="mediaFullscreen" onclick="closeFullscreen()">
    <button class="media-fullscreen-close">√ó</button>
    <div id="fullscreenContent"></div>
  </div>

  <!-- Share Contact Modal -->
  <div id="shareModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeModals()">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">üì§ Share My Contact</div>
        <button class="modal-close" onclick="closeModals()">√ó</button>
      </div>
      <div class="share-instructions">
        Others can scan this QR code or use the link to message you
      </div>
      <div class="qr-container" id="qrContainer"></div>
      <div class="share-link-container">
        <input type="text" class="share-link-input" id="shareLink" readonly>
        <button class="copy-btn" onclick="copyShareLink()">Copy</button>
      </div>
    </div>
  </div>

  <!-- Add Contact Modal -->
  <div id="addContactModal" class="modal-overlay" style="display: none;" onclick="if(event.target===this)closeModals()">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">‚ûï Add Contact</div>
        <button class="modal-close" onclick="closeModals()">√ó</button>
      </div>
      <div class="share-instructions">
        Scan a contact QR code or paste their link/ID
      </div>
      <div id="qrScannerContainer" style="display: none; margin-bottom: 15px;">
        <video id="qrScannerVideo" style="width: 100%; max-height: 250px; border-radius: 12px; background: #000;"></video>
        <div id="qrScannerStatus" style="text-align: center; color: #999; font-size: 13px; margin-top: 8px;">Point camera at QR code...</div>
      </div>
      <button class="modal-btn" id="scanQrBtn" onclick="toggleQrScanner()" style="margin-bottom: 15px; background: #333;">
        üì∑ Scan QR Code
      </button>
      <input type="text" class="modal-input" id="addContactInput" placeholder="Or paste link / account ID...">
      <button class="modal-btn" onclick="addContactFromInput()">Add & Start Chat</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>
  <script src="/wallet-auth.js"></script>
  <script>
    let currentConversationId = null;
    let currentRecipientId = null;
    let currentRecipientPublicKey = null;
    let currentItemId = null;
    let myPrivateKey = null;
    let myEncryptionKeyPair = null; // Derived X25519 keypair for E2E encryption
    let conversations = [];
    let messagePollingInterval = null;
    let inboxPollingInterval = null;
    const POLL_INTERVAL_MS = 5000; // Check for new messages every 5 seconds

    // Helper: Check response for auth errors and redirect to login
    function checkAuthAndRedirect(response) {
      if (response.status === 401 || response.status === 403) {
        WalletAuth.clearWallet();
        alert('Session expired. Please log in again.');
        window.location.href = '/m/login?redirect=/m/messages';
        return true;
      }
      return false;
    }

    // ============================================================
    // E2E ENCRYPTION (Signal-grade: Curve25519 + XSalsa20-Poly1305)
    // ============================================================

    // Convert hex string to Uint8Array
    function hexToBytes(hex) {
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
      }
      return bytes;
    }

    // Convert Uint8Array to hex string
    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // Derive X25519 keypair from wallet private key using SHA-256
    async function deriveEncryptionKeyPair(privateKeyHex) {
      // Hash the private key to get 32 bytes for X25519 seed
      const privateKeyBytes = hexToBytes(privateKeyHex);
      const hashBuffer = await crypto.subtle.digest('SHA-256', privateKeyBytes);
      const seed = new Uint8Array(hashBuffer);
      
      // Generate X25519 keypair from seed
      const keyPair = nacl.box.keyPair.fromSecretKey(seed);
      return keyPair;
    }

    // Derive public encryption key from account's public key (for recipient)
    async function deriveEncryptionPublicKey(publicKeyHex) {
      // Hash the public key to get consistent derivation
      const publicKeyBytes = hexToBytes(publicKeyHex);
      const hashBuffer = await crypto.subtle.digest('SHA-256', publicKeyBytes);
      const seed = new Uint8Array(hashBuffer);
      
      // Generate keypair from seed and return only public key
      const keyPair = nacl.box.keyPair.fromSecretKey(seed);
      return keyPair.publicKey;
    }

    // Encrypt message for recipient (and self)
    async function encryptForRecipient(plaintext, recipientPublicKeyHex) {
      if (!myEncryptionKeyPair) {
        throw new Error('Encryption keys not initialized');
      }
      
      // Get recipient's encryption public key
      const recipientEncPubKey = await deriveEncryptionPublicKey(recipientPublicKeyHex);
      
      // Generate random nonce (24 bytes for XSalsa20)
      const nonce = nacl.randomBytes(24);
      
      // Encrypt using NaCl box (Curve25519 + XSalsa20-Poly1305)
      const messageBytes = nacl.util.decodeUTF8(plaintext);
      const encrypted = nacl.box(messageBytes, nonce, recipientEncPubKey, myEncryptionKeyPair.secretKey);
      
      // Return as base64 encoded JSON
      return JSON.stringify({
        v: 1, // Version for future compatibility
        n: nacl.util.encodeBase64(nonce),
        c: nacl.util.encodeBase64(encrypted),
        s: bytesToHex(myEncryptionKeyPair.publicKey) // Sender's encryption public key
      });
    }

    // Decrypt message from sender
    async function decryptFromSender(encryptedJson, senderPublicKeyHex) {
      if (!myEncryptionKeyPair) {
        throw new Error('Encryption keys not initialized');
      }
      
      try {
        const envelope = JSON.parse(encryptedJson);
        
        // Check if this is actually encrypted (v1 format)
        if (envelope.v !== 1 || !envelope.n || !envelope.c) {
          // Not encrypted, return as-is (legacy message)
          return null;
        }
        
        const nonce = nacl.util.decodeBase64(envelope.n);
        const ciphertext = nacl.util.decodeBase64(envelope.c);
        const senderEncPubKey = hexToBytes(envelope.s);
        
        // Decrypt using NaCl box.open
        const decrypted = nacl.box.open(ciphertext, nonce, senderEncPubKey, myEncryptionKeyPair.secretKey);
        
        if (!decrypted) {
          return null; // Decryption failed
        }
        
        return nacl.util.encodeUTF8(decrypted);
      } catch (e) {
        console.error('Decryption error:', e);
        return null;
      }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      const wallet = WalletAuth.getWallet();
      if (!wallet) {
        window.location.href = '/m/login?redirect=/m/messages';
        return;
      }
      
      myPrivateKey = wallet.privateKey;
      
      // Derive encryption keypair for E2E encryption
      if (myPrivateKey) {
        try {
          myEncryptionKeyPair = await deriveEncryptionKeyPair(myPrivateKey);
          console.log('E2E encryption initialized');
        } catch (e) {
          console.error('Failed to initialize encryption:', e);
        }
      }
      
      await loadConversations();
      await loadContacts();
      
      // Start inbox polling for new conversations
      startInboxPolling();

      // Check for URL parameters
      const params = new URLSearchParams(window.location.search);
      const itemId = params.get('itemId');
      const recipientId = params.get('to');
      const contactId = params.get('contact');
      
      if (contactId) {
        // Coming from a shared contact link - add and start chat
        await addContactAndStartChat(contactId);
      } else if (itemId && recipientId) {
        openConversationWithItem(recipientId, itemId);
      }
    });

    function switchTab(tab) {
      document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
      
      document.getElementById('conversationsTab').style.display = tab === 'conversations' ? 'block' : 'none';
      document.getElementById('contactsTab').style.display = tab === 'contacts' ? 'block' : 'none';
    }

    async function loadConversations() {
      try {
        const response = await fetch('/api/messages/conversations', {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (checkAuthAndRedirect(response)) return;
        
        if (!response.ok) {
          throw new Error('Failed to load conversations');
        }
        
        const data = await response.json();

        if (data.success) {
          conversations = data.conversations;
          renderConversations();
          document.getElementById('inboxStats').textContent = 
            `${conversations.length} conversation${conversations.length !== 1 ? 's' : ''}`;
        } else if (data.error && data.error.includes('auth')) {
          WalletAuth.clearWallet();
          window.location.href = '/m/login?redirect=/m/messages';
        }
      } catch (error) {
        console.error('Failed to load conversations:', error);
        document.getElementById('conversationList').innerHTML = 
          '<div class="empty-inbox"><div class="empty-inbox-title">Failed to load</div></div>';
      }
    }

    function renderConversations() {
      const container = document.getElementById('conversationList');
      
      if (conversations.length === 0) {
        container.innerHTML = `
          <div class="empty-inbox">
            <div class="empty-inbox-icon">üí¨</div>
            <div class="empty-inbox-title">No messages yet</div>
            <div>Find an item and message its owner to start a conversation</div>
          </div>
        `;
        return;
      }

      const wallet = WalletAuth.getWallet();
      container.innerHTML = conversations.map(conv => {
        const otherParticipant = conv.participantInfo.find(p => p.accountId !== wallet.publicKey);
        const lastMsg = conv.lastMessage;
        const timeAgo = lastMsg ? formatTimeAgo(lastMsg.timestamp) : '';
        
        return `
          <div class="conversation-card ${conv.unreadCount > 0 ? 'unread' : ''}" 
               onclick="openConversation('${conv.conversationId}', '${otherParticipant?.accountId}')">
            <div class="conversation-header">
              <div class="conversation-participant">${escapeHtml(otherParticipant?.displayName || 'Unknown')}</div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                ${conv.unreadCount > 0 ? `<span class="unread-badge">${conv.unreadCount}</span>` : ''}
                <div class="conversation-time">${timeAgo}</div>
              </div>
            </div>
            <div class="conversation-preview">[Encrypted message]</div>
            ${lastMsg?.payload?.itemId ? `<div class="conversation-item-badge">About an item</div>` : ''}
          </div>
        `;
      }).join('');
    }

    async function loadContacts() {
      try {
        const response = await fetch('/api/messages/contacts', {
          headers: WalletAuth.getAuthHeaders()
        });
        
        if (checkAuthAndRedirect(response)) return;
        
        const data = await response.json();

        if (data.success) {
          renderContacts(data.contacts);
        }
      } catch (error) {
        console.error('Failed to load contacts:', error);
      }
    }

    function renderContacts(contacts) {
      const container = document.getElementById('contactsList');
      
      if (contacts.length === 0) {
        container.innerHTML = `
          <div class="empty-inbox">
            <div class="empty-inbox-title">No contacts yet</div>
            <div>Message someone to add them to your contacts</div>
          </div>
        `;
        return;
      }

      container.innerHTML = contacts.map(contact => `
        <div class="contact-card">
          <div class="contact-info">
            <div class="contact-avatar">${contact.displayName[0].toUpperCase()}</div>
            <div>
              <div class="contact-name">${escapeHtml(contact.displayName)}</div>
              <div class="contact-role">
                ${contact.isManufacturer ? 'Manufacturer' : contact.isAuthenticator ? 'Authenticator' : 'User'}
              </div>
            </div>
          </div>
          <div class="contact-actions">
            <button onclick="startConversation('${contact.accountId}')">Message</button>
          </div>
        </div>
      `).join('');
    }

    async function openConversation(conversationId, recipientId) {
      currentConversationId = conversationId;
      currentRecipientId = recipientId;
      currentItemId = null;
      document.getElementById('chatItemContext').textContent = '';
      
      // Get recipient's public key for encryption
      currentRecipientPublicKey = recipientId; // In our system, accountId IS the public key
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      
      // Set participant name
      const conv = conversations.find(c => c.conversationId === conversationId);
      const participant = conv?.participantInfo.find(p => p.accountId === recipientId);
      document.getElementById('chatParticipantName').textContent = participant?.displayName || recipientId.substring(0, 12) + '...';
      
      await loadMessages(conversationId);
      
      // Reset message count for new conversation
      lastMessageCount = 0;
      
      // Stop inbox polling, start message polling
      stopInboxPolling();
      startMessagePolling();
    }
    
    let lastMessageCount = 0;
    
    function startMessagePolling() {
      stopMessagePolling(); // Clear any existing interval
      messagePollingInterval = setInterval(async () => {
        if (currentConversationId) {
          await pollForNewMessages(currentConversationId);
        }
      }, POLL_INTERVAL_MS);
    }
    
    async function pollForNewMessages(conversationId) {
      try {
        const response = await fetch(`/api/messages/conversation/${conversationId}`, {
          headers: WalletAuth.getAuthHeaders()
        });
        const data = await response.json();
        
        if (data.success && data.messages) {
          // Only update if message count changed (new messages arrived)
          if (data.messages.length !== lastMessageCount) {
            const container = document.getElementById('chatMessages');
            const wasAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;
            
            lastMessageCount = data.messages.length;
            await renderMessages(data.messages);
            
            // Auto-scroll to bottom only if user was already at bottom
            if (wasAtBottom) {
              container.scrollTop = container.scrollHeight;
            }
          }
        }
      } catch (error) {
        console.error('Poll error:', error);
      }
    }
    
    function stopMessagePolling() {
      if (messagePollingInterval) {
        clearInterval(messagePollingInterval);
        messagePollingInterval = null;
      }
    }
    
    function startInboxPolling() {
      stopInboxPolling();
      inboxPollingInterval = setInterval(async () => {
        await loadConversations();
      }, POLL_INTERVAL_MS);
    }
    
    function stopInboxPolling() {
      if (inboxPollingInterval) {
        clearInterval(inboxPollingInterval);
        inboxPollingInterval = null;
      }
    }

    async function openConversationWithItem(recipientId, itemId) {
      currentRecipientId = recipientId;
      currentRecipientPublicKey = recipientId;
      currentItemId = itemId;
      
      // Generate conversation ID
      const wallet = WalletAuth.getWallet();
      const sorted = [wallet.publicKey, recipientId].sort();
      const response = await fetch(`/api/registry/item/${itemId}`);
      const itemData = await response.json();
      
      document.getElementById('chatItemContext').textContent = 
        `About: ${itemData.item?.metadata?.name || itemId}`;
      
      // Use the item-specific conversation
      const convId = await generateConversationId(wallet.publicKey, recipientId, itemId);
      currentConversationId = convId;
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      document.getElementById('chatParticipantName').textContent = 'Item Owner';
      
      await loadMessages(convId);
      
      // Stop inbox polling, start message polling
      stopInboxPolling();
      startMessagePolling();
    }

    async function generateConversationId(p1, p2, itemId) {
      const sorted = [p1, p2].sort();
      const base = `${sorted[0]}:${sorted[1]}${itemId ? ':' + itemId : ''}`;
      const encoder = new TextEncoder();
      const hash = await crypto.subtle.digest('SHA-256', encoder.encode(base));
      const hashArray = Array.from(new Uint8Array(hash));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 32);
    }

    async function loadMessages(conversationId) {
      const container = document.getElementById('chatMessages');
      container.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
      
      try {
        const response = await fetch(`/api/messages/conversation/${conversationId}`, {
          headers: WalletAuth.getAuthHeaders()
        });
        const data = await response.json();

        if (data.success) {
          renderMessages(data.messages);
        }
      } catch (error) {
        console.error('Failed to load messages:', error);
        container.innerHTML = '<div style="text-align:center;color:#888;">Failed to load messages</div>';
      }
    }

    function renderMessages(messages) {
      const container = document.getElementById('chatMessages');
      const wallet = WalletAuth.getWallet();
      
      if (messages.length === 0) {
        container.innerHTML = `
          <div style="text-align:center;color:#888;padding:2rem;">
            Start the conversation by sending a message
          </div>
        `;
        return;
      }

      container.innerHTML = messages.map(msg => {
        const isSent = msg.senderId === wallet.publicKey;
        const timeStr = new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const expiresIn = formatTimeUntil(msg.expiresAt);
        
        // Decrypt message (in production, use actual decryption)
        let decryptedText = '[Encrypted]';
        try {
          // For now, show placeholder - real decryption would happen client-side
          decryptedText = decryptMessage(msg.encryptedContent);
        } catch (e) {
          decryptedText = '[Could not decrypt]';
        }
        
        return `
          <div class="message-bubble ${isSent ? 'sent' : 'received'}">
            <div class="message-text">${escapeHtml(decryptedText)}</div>
            <div class="message-meta">
              ${timeStr}
              <span class="message-expires">‚Ä¢ expires ${expiresIn}</span>
            </div>
          </div>
        `;
      }).join('');
      
      // Scroll to bottom
      container.scrollTop = container.scrollHeight;
    }

    function decryptMessage(encryptedContent, senderId) {
      // Try to decrypt E2E encrypted message
      try {
        const parsed = JSON.parse(encryptedContent);
        
        // Check for v1 encrypted format
        if (parsed.v === 1 && parsed.n && parsed.c && parsed.s) {
          // This is encrypted - need async decryption
          // Return marker for async handling
          return { encrypted: true, data: encryptedContent, senderId };
        }
        
        // Legacy unencrypted format
        if (parsed.type && parsed.type !== 'text') {
          return JSON.stringify(parsed);
        }
        if (parsed.content) return parsed.content;
      } catch (e) {}
      return encryptedContent;
    }

    // Async decrypt for rendering
    async function decryptMessageAsync(encryptedContent, senderId) {
      try {
        const parsed = JSON.parse(encryptedContent);
        
        // Check for v1 encrypted format
        if (parsed.v === 1 && parsed.n && parsed.c && parsed.s) {
          const decrypted = await decryptFromSender(encryptedContent, senderId);
          if (decrypted) {
            return decrypted;
          }
          return '[Could not decrypt]';
        }
        
        // Legacy unencrypted format
        if (parsed.type && parsed.type !== 'text') {
          return JSON.stringify(parsed);
        }
        if (parsed.content) return parsed.content;
      } catch (e) {}
      return encryptedContent;
    }

    async function sendMessage() {
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      if (!text || !currentRecipientId) return;

      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;
      
      try {
        // Create message envelope
        const messageEnvelope = JSON.stringify({
          type: 'text',
          content: text,
          timestamp: Date.now()
        });
        
        // Encrypt for recipient
        let encryptedForRecipient = messageEnvelope;
        let encryptedForSender = messageEnvelope;
        
        if (myEncryptionKeyPair) {
          // E2E encrypt the message
          encryptedForRecipient = await encryptForRecipient(messageEnvelope, currentRecipientId);
          // Also encrypt for self (so we can read our own sent messages)
          const wallet = WalletAuth.getWallet();
          encryptedForSender = await encryptForRecipient(messageEnvelope, wallet.publicKey);
        }
        
        const response = await fetch('/api/messages/send', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({
            recipientId: currentRecipientId,
            encryptedContent: encryptedForRecipient,
            encryptedForSender: encryptedForSender,
            itemId: currentItemId || undefined,
            conversationId: currentConversationId || undefined
          })
        });
        
        const data = await response.json();
        if (data.success) {
          input.value = '';
          if (data.conversationId) {
            currentConversationId = data.conversationId;
          }
          // Reload messages to show the new one
          await loadMessages(currentConversationId);
          // Refresh inbox list so you can see the conversation immediately
          loadConversations();
        } else {
          alert(data.error || 'Failed to send message');
        }
      } catch (error) {
        console.error('Send error:', error);
        alert('Failed to send message');
      } finally {
        sendBtn.disabled = false;
      }
    }

    function showInbox() {
      document.getElementById('chatView').classList.remove('active');
      document.getElementById('inboxView').style.display = 'block';
      currentConversationId = null;
      currentRecipientId = null;
      
      // Stop message polling, start inbox polling
      stopMessagePolling();
      startInboxPolling();
      
      loadConversations();
    }

    function startConversation(contactId) {
      openConversation(null, contactId);
    }

    function formatTimeAgo(timestamp) {
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return 'now';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      if (seconds < 86400) return Math.floor(seconds / 3600) + 'h';
      return Math.floor(seconds / 86400) + 'd';
    }

    function formatTimeUntil(timestamp) {
      const seconds = Math.floor((timestamp - Date.now()) / 1000);
      if (seconds < 0) return 'expired';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
      if (seconds < 86400) return Math.floor(seconds / 3600) + 'h';
      return Math.floor(seconds / 86400) + 'd';
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ============================================================
    // CONTACT SHARING FUNCTIONS
    // ============================================================

    function showShareModal() {
      const wallet = WalletAuth.getWallet();
      if (!wallet) return;
      
      // Generate shareable link
      const baseUrl = window.location.origin;
      const shareUrl = `${baseUrl}/m/messages?contact=${wallet.publicKey}`;
      document.getElementById('shareLink').value = shareUrl;
      
      // Generate QR code using qrcodejs library (same as mobile-verify.html)
      const qrContainer = document.getElementById('qrContainer');
      qrContainer.innerHTML = '';
      
      try {
        if (typeof QRCode !== 'function') {
          qrContainer.innerHTML = '<div style="color:#ff6b6b;padding:20px;">QR library not available</div>';
          return;
        }
        new QRCode(qrContainer, {
          text: shareUrl,
          width: 200,
          height: 200,
          correctLevel: QRCode.CorrectLevel.M
        });
      } catch (e) {
        console.error('QR generation error:', e);
        qrContainer.innerHTML = '<div style="color:#ff6b6b;padding:20px;">QR generation failed</div>';
      }
      
      document.getElementById('shareModal').style.display = 'flex';
    }

    function showAddContactModal() {
      document.getElementById('addContactInput').value = '';
      document.getElementById('addContactModal').style.display = 'flex';
    }

    // QR Scanner state
    let qrScannerStream = null;
    let qrScannerActive = false;

    async function toggleQrScanner() {
      if (qrScannerActive) {
        stopQrScanner();
      } else {
        await startQrScanner();
      }
    }

    async function startQrScanner() {
      const container = document.getElementById('qrScannerContainer');
      const video = document.getElementById('qrScannerVideo');
      const status = document.getElementById('qrScannerStatus');
      const btn = document.getElementById('scanQrBtn');
      
      try {
        qrScannerStream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'environment' } 
        });
        video.srcObject = qrScannerStream;
        await video.play();
        
        container.style.display = 'block';
        btn.textContent = '‚úï Stop Scanner';
        btn.style.background = '#c0392b';
        qrScannerActive = true;
        status.textContent = 'Point camera at QR code...';
        
        // Start scanning
        scanQrCode(video, status);
      } catch (e) {
        console.error('Camera error:', e);
        status.textContent = 'Could not access camera';
        alert('Could not access camera. Please grant permission.');
      }
    }

    function stopQrScanner() {
      const container = document.getElementById('qrScannerContainer');
      const video = document.getElementById('qrScannerVideo');
      const btn = document.getElementById('scanQrBtn');
      
      if (qrScannerStream) {
        qrScannerStream.getTracks().forEach(t => t.stop());
        qrScannerStream = null;
      }
      video.srcObject = null;
      container.style.display = 'none';
      btn.textContent = 'üì∑ Scan QR Code';
      btn.style.background = '#333';
      qrScannerActive = false;
    }

    function scanQrCode(video, status) {
      if (!qrScannerActive) return;
      
      // Use canvas to capture frame and analyze
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth || 320;
      canvas.height = video.videoHeight || 240;
      
      const scan = () => {
        if (!qrScannerActive) return;
        
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // Use jsQR library if available, otherwise try BarcodeDetector API
        if (typeof jsQR !== 'undefined') {
          const code = jsQR(imageData.data, canvas.width, canvas.height);
          if (code && code.data) {
            handleQrResult(code.data);
            return;
          }
        } else if ('BarcodeDetector' in window) {
          const detector = new BarcodeDetector({ formats: ['qr_code'] });
          detector.detect(canvas).then(barcodes => {
            if (barcodes.length > 0) {
              handleQrResult(barcodes[0].rawValue);
              return;
            }
          }).catch(() => {});
        }
        
        // Continue scanning
        requestAnimationFrame(scan);
      };
      
      requestAnimationFrame(scan);
    }

    function handleQrResult(data) {
      console.log('QR scanned:', data);
      
      // Stop scanner FIRST and ensure camera is fully released
      stopQrScanner();
      
      // Extract contact ID from scanned data
      let contactId = data;
      if (data.includes('contact=')) {
        const match = data.match(/contact=([^&]+)/);
        if (match) contactId = match[1];
      } else if (data.includes('/m/messages?')) {
        try {
          const url = new URL(data);
          contactId = url.searchParams.get('contact') || data;
        } catch {}
      }
      
      // Close modal and add contact (don't auto-open conversation to avoid camera conflicts)
      closeModals();
      
      if (contactId) {
        // Just add contact to list, don't open conversation immediately
        addContactOnly(contactId);
      }
    }
    
    async function addContactOnly(contactId) {
      const wallet = WalletAuth.getWallet();
      if (!wallet || contactId === wallet.publicKey) {
        alert("You can't add yourself as a contact");
        return;
      }
      
      try {
        const res = await fetch('/api/messages/contacts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ contactId: contactId })
        });
        
        if (res.ok) {
          alert('Contact added! Tap their name in the list to start chatting.');
          loadConversations();
        } else {
          const data = await res.json().catch(() => ({}));
          alert('Failed to add contact: ' + (data.error || 'Unknown error'));
        }
      } catch (e) {
        console.error('Add contact error:', e);
        alert('Error adding contact');
      }
    }

    function closeModals() {
      stopQrScanner();
      document.getElementById('shareModal').style.display = 'none';
      document.getElementById('addContactModal').style.display = 'none';
    }

    function copyShareLink() {
      const input = document.getElementById('shareLink');
      input.select();
      navigator.clipboard.writeText(input.value).then(() => {
        const btn = input.nextElementSibling;
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy', 2000);
      });
    }

    function addContactFromInput() {
      const input = document.getElementById('addContactInput').value.trim();
      if (!input) return;
      
      // Extract accountId from input (could be full URL or just the ID)
      let contactId = input;
      
      // Check if it's a URL with contact parameter
      if (input.includes('contact=')) {
        const match = input.match(/contact=([^&]+)/);
        if (match) contactId = match[1];
      } else if (input.includes('/m/messages?')) {
        const url = new URL(input);
        contactId = url.searchParams.get('contact') || input;
      }
      
      if (contactId) {
        addContactAndStartChat(contactId);
        closeModals();
      }
    }

    async function addContactAndStartChat(contactId) {
      const wallet = WalletAuth.getWallet();
      if (!wallet || contactId === wallet.publicKey) {
        alert("You can't add yourself as a contact");
        return;
      }
      
      // Add to contacts via API
      try {
        await fetch('/api/messages/contacts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ contactId })
        });
      } catch (e) {
        console.log('Contact add request:', e);
      }
      
      // Clear URL parameters
      window.history.replaceState({}, '', '/m/messages');
      
      // Start conversation with the contact
      currentRecipientId = contactId;
      currentRecipientPublicKey = contactId;
      currentItemId = null;
      currentConversationId = null;
      
      document.getElementById('inboxView').style.display = 'none';
      document.getElementById('chatView').classList.add('active');
      document.getElementById('chatParticipantName').textContent = contactId.substring(0, 12) + '...';
      document.getElementById('chatItemContext').textContent = '';
      
      // Load any existing messages (might be empty for new contact)
      const convId = await generateConversationId(wallet.publicKey, contactId, null);
      currentConversationId = convId;
      await loadMessages(convId);
      
      // Refresh contacts
      loadContacts();
    }

    async function addCurrentRecipientToContacts() {
      if (!currentRecipientId) return;
      
      const btn = document.getElementById('addContactChatBtn');
      btn.disabled = true;
      
      try {
        const response = await fetch('/api/messages/contacts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({ contactId: currentRecipientId })
        });
        
        const data = await response.json();
        if (data.success) {
          btn.textContent = '‚úì Added';
          btn.classList.add('added');
          loadContacts();
        } else {
          alert(data.error || 'Failed to add contact');
        }
      } catch (e) {
        console.error('Add contact error:', e);
      } finally {
        btn.disabled = false;
      }
    }

    function updateAddContactButton(isAlreadyContact) {
      const btn = document.getElementById('addContactChatBtn');
      if (isAlreadyContact) {
        btn.textContent = '‚úì Contact';
        btn.classList.add('added');
      } else {
        btn.textContent = '‚ûï Add';
        btn.classList.remove('added');
      }
    }

    // ============================================================
    // MEDIA MESSAGING FUNCTIONS
    // ============================================================
    
    let pendingMedia = null; // { type: 'image'|'video'|'audio', data: base64, name: string, size: number }
    let audioRecorder = null;
    let audioChunks = [];
    let audioTimerInterval = null;
    let audioStartTime = null;
    const MAX_AUDIO_SECONDS = 30;
    const MAX_VIDEO_SECONDS = 15;
    const MAX_IMAGE_SIZE = 500 * 1024; // 500KB after compression
    const MAX_VIDEO_SIZE = 5 * 1024 * 1024; // 5MB

    async function handlePhotoSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      try {
        const compressed = await compressImage(file, MAX_IMAGE_SIZE);
        pendingMedia = {
          type: 'image',
          data: compressed.data,
          name: file.name || 'Photo',
          size: compressed.size
        };
        showMediaPreview();
      } catch (e) {
        console.error('Photo processing error:', e);
        alert('Failed to process photo');
      }
      event.target.value = ''; // Reset input
    }

    async function handleVideoSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      if (file.size > MAX_VIDEO_SIZE) {
        alert(`Video too large. Maximum size is ${Math.round(MAX_VIDEO_SIZE / 1024 / 1024)}MB`);
        event.target.value = '';
        return;
      }
      
      try {
        const data = await fileToBase64(file);
        pendingMedia = {
          type: 'video',
          data: data,
          name: file.name || 'Video',
          size: file.size
        };
        showMediaPreview();
      } catch (e) {
        console.error('Video processing error:', e);
        alert('Failed to process video');
      }
      event.target.value = '';
    }

    async function compressImage(file, maxSize) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;
            
            // Scale down if needed
            const maxDim = 1200;
            if (width > maxDim || height > maxDim) {
              if (width > height) {
                height = Math.round(height * maxDim / width);
                width = maxDim;
              } else {
                width = Math.round(width * maxDim / height);
                height = maxDim;
              }
            }
            
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            // Try different quality levels
            let quality = 0.8;
            let data = canvas.toDataURL('image/jpeg', quality);
            
            while (data.length > maxSize * 1.37 && quality > 0.1) { // base64 is ~37% larger
              quality -= 0.1;
              data = canvas.toDataURL('image/jpeg', quality);
            }
            
            resolve({
              data: data,
              size: Math.round(data.length * 0.73) // Approximate actual size
            });
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function showMediaPreview() {
      if (!pendingMedia) return;
      
      const preview = document.getElementById('mediaPreview');
      const thumb = document.getElementById('mediaPreviewThumb');
      const name = document.getElementById('mediaPreviewName');
      const size = document.getElementById('mediaPreviewSize');
      
      name.textContent = pendingMedia.type.charAt(0).toUpperCase() + pendingMedia.type.slice(1);
      size.textContent = formatFileSize(pendingMedia.size);
      
      if (pendingMedia.type === 'image') {
        thumb.innerHTML = `<img src="${pendingMedia.data}" alt="Preview">`;
      } else if (pendingMedia.type === 'video') {
        thumb.innerHTML = `<video src="${pendingMedia.data}" muted></video>`;
      } else if (pendingMedia.type === 'audio') {
        thumb.innerHTML = `<div style="font-size:2rem">üéµ</div>`;
      }
      
      preview.classList.add('active');
    }

    function clearMediaPreview() {
      pendingMedia = null;
      document.getElementById('mediaPreview').classList.remove('active');
      document.getElementById('mediaPreviewThumb').innerHTML = '';
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
      return (bytes / 1024 / 1024).toFixed(1) + ' MB';
    }

    // Audio Recording - detect best supported format for iOS/Android compatibility
    function getSupportedAudioMimeType() {
      const types = [
        'audio/mp4',           // iOS Safari preferred
        'audio/aac',           // iOS fallback
        'audio/webm;codecs=opus', // Chrome/Firefox preferred
        'audio/webm',          // Generic WebM
        'audio/ogg;codecs=opus',
        ''                     // Let browser choose default
      ];
      for (const type of types) {
        if (type === '' || MediaRecorder.isTypeSupported(type)) {
          return type;
        }
      }
      return '';
    }

    let audioMimeType = '';

    async function toggleAudioRecording() {
      if (audioRecorder && audioRecorder.state === 'recording') {
        // Already recording - stop will be handled by sendAudioRecording
        return;
      }
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Use iOS-compatible format if available
        audioMimeType = getSupportedAudioMimeType();
        const options = audioMimeType ? { mimeType: audioMimeType } : {};
        
        audioRecorder = new MediaRecorder(stream, options);
        audioChunks = [];
        
        console.log('Recording with MIME type:', audioRecorder.mimeType);
        
        audioRecorder.ondataavailable = (e) => {
          audioChunks.push(e.data);
        };
        
        audioRecorder.onstop = () => {
          stream.getTracks().forEach(t => t.stop());
        };
        
        audioRecorder.start();
        audioStartTime = Date.now();
        
        // Show recorder UI
        document.getElementById('audioRecorder').classList.add('active');
        document.getElementById('audioBtn').classList.add('recording');
        
        // Start timer
        audioTimerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - audioStartTime) / 1000);
          document.getElementById('audioTimer').textContent = 
            `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
          
          // Auto-stop at max duration
          if (elapsed >= MAX_AUDIO_SECONDS) {
            sendAudioRecording();
          }
        }, 100);
        
      } catch (e) {
        console.error('Audio recording error:', e);
        alert('Could not access microphone. Please grant permission.');
      }
    }

    function cancelAudioRecording() {
      if (audioRecorder && audioRecorder.state === 'recording') {
        audioRecorder.stop();
      }
      clearAudioRecorder();
    }

    function clearAudioRecorder() {
      if (audioTimerInterval) {
        clearInterval(audioTimerInterval);
        audioTimerInterval = null;
      }
      audioRecorder = null;
      audioChunks = [];
      audioStartTime = null;
      document.getElementById('audioRecorder').classList.remove('active');
      document.getElementById('audioBtn').classList.remove('recording');
      document.getElementById('audioTimer').textContent = '0:00';
    }

    async function sendAudioRecording() {
      if (!audioRecorder || audioRecorder.state !== 'recording') return;
      
      audioRecorder.stop();
      
      // Wait for data to be available
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Use the actual MIME type from the recorder (handles iOS MP4 vs Chrome WebM)
      const actualMimeType = audioRecorder?.mimeType || audioMimeType || 'audio/webm';
      const blob = new Blob(audioChunks, { type: actualMimeType });
      console.log('Audio blob created with type:', actualMimeType);
      const data = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
      
      pendingMedia = {
        type: 'audio',
        data: data,
        name: 'Voice message',
        size: blob.size
      };
      
      clearAudioRecorder();
      
      // Send immediately
      await sendMediaMessage();
    }

    async function sendMediaMessage() {
      if (!pendingMedia || !currentRecipientId) return;
      
      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;
      
      try {
        // Create media envelope
        const mediaEnvelope = JSON.stringify({
          type: pendingMedia.type,
          content: pendingMedia.data,
          name: pendingMedia.name,
          timestamp: Date.now()
        });
        
        // Encrypt for recipient
        let encryptedForRecipient = mediaEnvelope;
        let encryptedForSender = mediaEnvelope;
        
        if (myEncryptionKeyPair) {
          // E2E encrypt the media
          encryptedForRecipient = await encryptForRecipient(mediaEnvelope, currentRecipientId);
          // Also encrypt for self
          const wallet = WalletAuth.getWallet();
          encryptedForSender = await encryptForRecipient(mediaEnvelope, wallet.publicKey);
        }
        
        const response = await fetch('/api/messages/send', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...WalletAuth.getAuthHeaders()
          },
          body: JSON.stringify({
            recipientId: currentRecipientId,
            encryptedContent: encryptedForRecipient,
            encryptedForSender: encryptedForSender,
            itemId: currentItemId || undefined,
            conversationId: currentConversationId || undefined
          })
        });
        
        const data = await response.json();
        if (data.success) {
          clearMediaPreview();
          if (data.conversationId) {
            currentConversationId = data.conversationId;
          }
          await loadMessages(currentConversationId);
          loadConversations();
        } else {
          alert(data.error || 'Failed to send media');
        }
      } catch (error) {
        console.error('Send media error:', error);
        alert('Failed to send media');
      } finally {
        sendBtn.disabled = false;
      }
    }

    // Override sendMessage to handle pending media
    const originalSendMessage = sendMessage;
    sendMessage = async function() {
      if (pendingMedia) {
        await sendMediaMessage();
      } else {
        await originalSendMessage();
      }
    };

    // ============================================================
    // PUSH-TO-TALK (WALKIE-TALKIE) FUNCTIONS
    // ============================================================
    
    let pttRecorder = null;
    let pttChunks = [];
    let pttStream = null;
    let pttActive = false;
    
    function initPushToTalk() {
      const pttBtn = document.getElementById('pttBtn');
      if (!pttBtn) return;
      
      // Mouse events (desktop)
      pttBtn.addEventListener('mousedown', startPTT);
      pttBtn.addEventListener('mouseup', stopPTT);
      pttBtn.addEventListener('mouseleave', stopPTT);
      
      // Touch events (mobile)
      pttBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        startPTT();
      });
      pttBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        stopPTT();
      });
      pttBtn.addEventListener('touchcancel', stopPTT);
    }
    
    async function startPTT() {
      if (pttActive || !currentRecipientId) return;
      
      try {
        pttStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        const mimeType = getSupportedAudioMimeType();
        const options = mimeType ? { mimeType } : {};
        
        pttRecorder = new MediaRecorder(pttStream, options);
        pttChunks = [];
        
        pttRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) pttChunks.push(e.data);
        };
        
        pttRecorder.onstop = async () => {
          // Clean up stream
          if (pttStream) {
            pttStream.getTracks().forEach(t => t.stop());
            pttStream = null;
          }
          
          // Only send if we have audio data
          if (pttChunks.length > 0) {
            await sendPTTAudio();
          }
        };
        
        pttRecorder.start();
        pttActive = true;
        
        // Show recording UI
        document.getElementById('pttBtn').classList.add('recording');
        document.getElementById('pttRecording').classList.add('active');
        
      } catch (e) {
        console.error('PTT start error:', e);
        alert('Could not access microphone');
      }
    }
    
    function stopPTT() {
      if (!pttActive || !pttRecorder) return;
      
      pttActive = false;
      document.getElementById('pttBtn').classList.remove('recording');
      document.getElementById('pttRecording').classList.remove('active');
      
      if (pttRecorder.state === 'recording') {
        pttRecorder.stop();
      }
    }
    
    async function sendPTTAudio() {
      if (pttChunks.length === 0) return;
      
      const actualMimeType = pttRecorder?.mimeType || 'audio/webm';
      const blob = new Blob(pttChunks, { type: actualMimeType });
      
      // Convert to base64
      const data = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
      
      // Set as pending media and send
      pendingMedia = {
        type: 'audio',
        data: data,
        name: 'Voice message',
        size: blob.size,
        isPTT: true // Mark as push-to-talk for auto-play
      };
      
      pttChunks = [];
      pttRecorder = null;
      
      await sendMediaMessage();
    }
    
    // Initialize PTT when DOM is ready
    document.addEventListener('DOMContentLoaded', initPushToTalk);

    // Fullscreen media viewer
    function openFullscreen(src, type) {
      const container = document.getElementById('fullscreenContent');
      if (type === 'image') {
        container.innerHTML = `<img src="${src}" alt="Fullscreen">`;
      } else if (type === 'video') {
        container.innerHTML = `<video src="${src}" controls autoplay playsinline webkit-playsinline></video>`;
      }
      document.getElementById('mediaFullscreen').classList.add('active');
    }

    function closeFullscreen() {
      document.getElementById('mediaFullscreen').classList.remove('active');
      document.getElementById('fullscreenContent').innerHTML = '';
    }

    // Update renderMessages to show media with async E2E decryption
    const originalRenderMessages = renderMessages;
    renderMessages = async function(messages) {
      const container = document.getElementById('chatMessages');
      const wallet = WalletAuth.getWallet();
      
      if (messages.length === 0) {
        container.innerHTML = `
          <div style="text-align:center;color:#888;padding:2rem;">
            Start the conversation by sending a message
          </div>
        `;
        return;
      }

      // Process messages with async decryption
      const processedMessages = await Promise.all(messages.map(async (msg) => {
        const isSent = msg.senderId === wallet.publicKey;
        const timeStr = new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const expiresIn = formatTimeUntil(msg.expiresAt);
        
        // Choose correct encrypted content based on who sent it
        const contentToDecrypt = isSent ? msg.encryptedForSender : msg.encryptedContent;
        
        let content = '';
        try {
          // Async decrypt the message
          const decrypted = await decryptMessageAsync(contentToDecrypt || msg.encryptedContent, msg.senderId);
          const parsed = JSON.parse(decrypted);
          
          if (parsed.type === 'image') {
            content = `
              <div class="message-media">
                <img src="${parsed.content}" alt="Photo" onclick="openFullscreen(this.src, 'image')">
              </div>
            `;
          } else if (parsed.type === 'video') {
            // Add #t=0.1 to show first frame as thumbnail on iOS
            const videoSrc = parsed.content + (parsed.content.includes('#') ? '' : '#t=0.1');
            content = `
              <div class="message-media">
                <video src="${videoSrc}" controls playsinline webkit-playsinline preload="metadata"></video>
              </div>
            `;
          } else if (parsed.type === 'audio') {
            content = `
              <div class="message-media">
                <audio src="${parsed.content}" controls></audio>
              </div>
            `;
          } else {
            content = `<div class="message-text">${escapeHtml(parsed.content || decrypted)}</div>`;
          }
        } catch (e) {
          // Fallback for legacy or failed decryption
          try {
            const fallback = await decryptMessageAsync(msg.encryptedContent, msg.senderId);
            content = `<div class="message-text">${escapeHtml(fallback)}</div>`;
          } catch (e2) {
            content = `<div class="message-text" style="color:#ff6b6b;">[Could not decrypt]</div>`;
          }
        }
        
        return `
          <div class="message-bubble ${isSent ? 'sent' : 'received'}">
            ${content}
            <div class="message-meta">
              ${timeStr}
              <span class="message-expires">‚Ä¢ expires ${expiresIn}</span>
            </div>
          </div>
        `;
      }));

      container.innerHTML = processedMessages.join('');
      container.scrollTop = container.scrollHeight;
    };
  </script>
</body>
</html>
