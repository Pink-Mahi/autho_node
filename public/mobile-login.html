<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Wallet Login - Bitcoin Ownership Protocol</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      color: #ffffff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .header {
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      padding: 15px 20px;
      border-bottom: 2px solid #d4af37;
      text-align: center;
    }

    .header h1 {
      font-family: 'Playfair Display', serif;
      font-size: 24px;
      font-weight: 700;
      color: #d4af37;
    }

    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 20px;
      max-width: 500px;
      margin: 0 auto;
      width: 100%;
    }

    .logo {
      text-align: center;
      margin-bottom: 40px;
    }

    .logo-icon {
      font-size: 64px;
      margin-bottom: 15px;
    }

    .logo-text {
      font-family: 'Playfair Display', serif;
      font-size: 20px;
      color: #d4af37;
      font-weight: 600;
    }

    .card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 20px;
      padding: 30px;
      backdrop-filter: blur(10px);
    }

    .card-title {
      font-family: 'Playfair Display', serif;
      font-size: 24px;
      color: #d4af37;
      margin-bottom: 10px;
      text-align: center;
    }

    .card-subtitle {
      color: #999;
      text-align: center;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .wallet-preview {
      background: rgba(212, 175, 55, 0.1);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 25px;
      text-align: center;
    }

    .wallet-preview-label {
      font-size: 12px;
      color: #999;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }

    .wallet-preview-address {
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: #d4af37;
      word-break: break-all;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      margin-bottom: 8px;
      color: #d4af37;
      font-size: 14px;
      font-weight: 500;
    }

    .form-input {
      width: 100%;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 12px;
      color: #ffffff;
      font-size: 16px;
      font-family: 'Courier New', monospace;
      text-align: center;
      letter-spacing: 3px;
    }

    .form-input:focus {
      outline: none;
      border-color: #d4af37;
      background: rgba(255, 255, 255, 0.08);
    }

    .pin-input {
      font-size: 24px;
      letter-spacing: 8px;
    }

    .btn {
      width: 100%;
      background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%);
      color: #1a1a1a;
      border: none;
      border-radius: 12px;
      padding: 16px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      margin-bottom: 12px;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.05);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.3);
    }

    .error-message {
      background: rgba(255, 59, 48, 0.1);
      border: 1px solid rgba(255, 59, 48, 0.3);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 20px;
      color: #ff3b30;
      font-size: 14px;
      text-align: center;
      display: none;
    }

    .error-message.show {
      display: block;
    }

    .help-text {
      text-align: center;
      color: #999;
      font-size: 13px;
      margin-top: 20px;
    }

    .help-link {
      color: #d4af37;
      text-decoration: none;
      cursor: pointer;
    }

    .help-link:hover {
      text-decoration: underline;
    }

    .divider {
      text-align: center;
      margin: 25px 0;
      color: #666;
      font-size: 14px;
      position: relative;
    }

    .divider::before,
    .divider::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 40%;
      height: 1px;
      background: rgba(212, 175, 55, 0.2);
    }

    .divider::before {
      left: 0;
    }

    .divider::after {
      right: 0;
    }

    .screen {
      display: none;
    }

    .screen.active {
      display: block;
    }

    .loading-spinner {
      border: 3px solid rgba(212, 175, 55, 0.2);
      border-top: 3px solid #d4af37;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üîê Wallet Login</h1>
  </div>

  <div class="container">
    <!-- PIN Login Screen -->
    <div id="pinLoginScreen" class="screen active">
      <div class="logo">
        <div class="logo-icon">üíé</div>
        <div class="logo-text">Welcome Back</div>
      </div>

      <div class="card">
        <h2 class="card-title">Unlock Your Wallet</h2>
        <p class="card-subtitle">Enter your wallet passcode</p>

        <div class="wallet-preview">
          <div class="wallet-preview-label">Wallet Address</div>
          <div class="wallet-preview-address" id="walletAddressPreview">Loading...</div>
        </div>

        <div id="errorMessage" class="error-message"></div>

        <div class="form-group">
          <input 
            type="password" 
            id="pinInput" 
            class="form-input pin-input" 
            placeholder="Enter passcode (6+ characters)" 
            autocomplete="off"
          >
        </div>

        <button class="btn" onclick="unlockWithPin()">
          üîì Unlock Wallet
        </button>

        <div class="divider">OR</div>

        <button class="btn btn-secondary" onclick="showEmailLogin()">
          üìß Sign In with Email
        </button>

        <button class="btn btn-secondary" onclick="showSeedRecovery()">
          üîë Recover with Seed Phrase
        </button>

        <div class="help-text">
          <a href="#" class="help-link" onclick="forgotPin(); return false;">Forgot PIN?</a>
          <br><br>
          <a href="/m/wallet" class="help-link">Create New Wallet</a>
        </div>
      </div>
    </div>

    <!-- Seed Recovery Screen -->
    <div id="seedRecoveryScreen" class="screen">
      <div class="card">
        <h2 class="card-title">Recover Wallet</h2>
        <p class="card-subtitle">Enter your 24-word seed phrase</p>

        <div id="seedErrorMessage" class="error-message"></div>

        <div class="form-group">
          <label class="form-label">Seed Phrase</label>
          <textarea 
            id="seedPhraseInput" 
            class="form-input" 
            rows="4" 
            placeholder="word1 word2 word3 ..."
            style="letter-spacing: normal; text-align: left; font-size: 14px;"
          ></textarea>
        </div>

        <div class="form-group">
          <label class="form-label">Set New Passcode (6+ characters)</label>
          <input 
            type="password" 
            id="newPinInput" 
            class="form-input pin-input" 
            placeholder="Enter new passcode"
          >
        </div>

        <button class="btn" onclick="recoverWallet()">
          ‚ôªÔ∏è Recover Wallet
        </button>

        <button class="btn btn-secondary" onclick="showPinLogin()">
          ‚Üê Back to PIN Login
        </button>
      </div>
    </div>

    <!-- Email Login Screen -->
    <div id="emailLoginScreen" class="screen">
      <div class="card">
        <h2 class="card-title">Sign In</h2>
        <p class="card-subtitle">Use your account email + password to restore and unlock this wallet</p>

        <div id="emailErrorMessage" class="error-message"></div>

        <div class="form-group">
          <label class="form-label">Email</label>
          <input type="email" id="emailInput" class="form-input" placeholder="you@email.com" style="letter-spacing: normal; text-align: left; font-family: Inter, sans-serif;">
        </div>

        <div class="form-group">
          <label class="form-label">Password</label>
          <input type="password" id="passwordInput" class="form-input" placeholder="Account password" style="letter-spacing: normal; text-align: left; font-family: Inter, sans-serif;">
        </div>

        <button class="btn" id="emailLoginBtn" onclick="loginWithEmail()">üîì Sign In & Unlock</button>
        <button class="btn btn-secondary" onclick="showPinLogin()">‚Üê Back</button>
      </div>
    </div>
  </div>

  <script src="/js/nacl-fast.min.js" integrity="sha384-05+sicyRJQ56XpL4U9HJ8YbtSzFDvAg7apPKOGV6A0JsAJKFM68jp5oLnUjG5mEp" crossorigin="anonymous"></script>
  <script src="/js/btc.bundle.js"></script>
  <script>
    // --- PIN Security: PBKDF2 hashing (shared inline) ---
    async function hashPinPBKDF2(pin) {
      const enc = new TextEncoder();
      const salt = enc.encode('autho_pin_salt_v1');
      const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(pin), 'PBKDF2', false, ['deriveBits']);
      const bits = await crypto.subtle.deriveBits({ name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' }, keyMaterial, 256);
      const hashArray = Array.from(new Uint8Array(bits));
      return 'pbkdf2v1:' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }
    async function verifyStoredPin(pin, stored) {
      if (!stored || !pin) return false;
      if (stored.startsWith('pbkdf2v1:')) {
        const computed = await hashPinPBKDF2(pin);
        return computed === stored;
      }
      try {
        if (btoa(pin) === stored) {
          try { const upgraded = await hashPinPBKDF2(pin); localStorage.setItem('autho_wallet_pin', upgraded); } catch {}
          return true;
        }
      } catch {}
      return false;
    }
  </script>
  <script>
    let walletData = null;

    // Load wallet preview on page load
    window.addEventListener('load', () => {
      loadWalletPreview();
    });

    function loadWalletPreview() {
      try {
        const wallet = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
        if (wallet.address) {
          const address = wallet.address;
          const preview = address.substring(0, 8) + '...' + address.substring(address.length - 8);
          document.getElementById('walletAddressPreview').textContent = preview;
          walletData = wallet;
        } else {
          // No wallet found, redirect to wallet creation
          window.location.href = '/m/wallet';
        }
      } catch (error) {
        console.error('Error loading wallet:', error);
        window.location.href = '/m/wallet';
      }
    }

    function showError(message, elementId = 'errorMessage') {
      const errorEl = document.getElementById(elementId);
      errorEl.textContent = message;
      errorEl.classList.add('show');
      setTimeout(() => {
        errorEl.classList.remove('show');
      }, 5000);
    }

    async function unlockWithPin() {
      const pin = document.getElementById('pinInput').value.trim();
      
      if (!pin) {
        showError('Please enter your passcode');
        return;
      }

      if (pin.length < 6) {
        showError('Passcode must be at least 6 characters');
        return;
      }

      try {
        // Get stored PIN hash
        const storedPinHash = localStorage.getItem('autho_wallet_pin');
        
        if (!storedPinHash) {
          showError('No local passcode is set on this device. Tap "Sign In with Email" to restore your wallet.');
          return;
        }

        // Verify PIN (PBKDF2 with legacy base64 backward compat)
        const pinValid = await verifyStoredPin(pin, storedPinHash);
        if (pinValid) {
          sessionStorage.setItem('autho_session_pin', pin);
          await unlockSuccess(pin);
        } else {
          showError('Incorrect passcode. Please try again.');
          document.getElementById('pinInput').value = '';
        }
      } catch (error) {
        console.error('Error unlocking wallet:', error);
        showError('Error unlocking wallet');
      }
    }

    async function unlockSuccess(pin) {
      // Set session flag
      sessionStorage.setItem('autho_wallet_unlocked', 'true');
      const unlockTime = Date.now().toString();
      sessionStorage.setItem('autho_wallet_unlock_time', unlockTime);
      try {
        localStorage.setItem('autho_wallet_unlocked', 'true');
        localStorage.setItem('autho_wallet_unlock_time', unlockTime);
      } catch {}
      
      try {
        let mnemonic = '';
        try {
          const walletData = JSON.parse(localStorage.getItem('autho_wallet') || '{}');
          if (walletData && walletData.mnemonic) mnemonic = String(walletData.mnemonic || '');
        } catch {}

        if (!mnemonic) {
          try {
            const vaultStr = localStorage.getItem('autho_wallet_vault_local') || localStorage.getItem('autho_wallet_vault');
            if (vaultStr && pin) {
              const vault = JSON.parse(vaultStr);
              const payload = await decryptWalletVault(vault, pin);
              if (payload && payload.mnemonic) mnemonic = String(payload.mnemonic || '');
            }
          } catch {}
        }

        if (mnemonic && window.AuthoBTC?.deriveMessagingKeyPairSync) {
          const msgKeys = window.AuthoBTC.deriveMessagingKeyPairSync(mnemonic);
          if (msgKeys?.privateKeyHex && msgKeys?.publicKeyHex) {
            sessionStorage.setItem('autho_messaging_privateKey', msgKeys.privateKeyHex);
            sessionStorage.setItem('autho_messaging_publicKey', msgKeys.publicKeyHex);
            // Publish X25519 encryption key to network immediately (like Signal does)
            publishMessagingKey(msgKeys.privateKeyHex);
          }
        }
      } catch (e) {
        console.error('Failed to derive messaging keys on unlock:', e);
      }
      
      // Redirect to main app
      const returnUrl = new URLSearchParams(window.location.search).get('return') || '/m';
      window.location.href = returnUrl;
    }

    function showSeedRecovery() {
      document.getElementById('pinLoginScreen').classList.remove('active');
      document.getElementById('seedRecoveryScreen').classList.add('active');
      document.getElementById('emailLoginScreen').classList.remove('active');
    }

    function showPinLogin() {
      document.getElementById('seedRecoveryScreen').classList.remove('active');
      document.getElementById('pinLoginScreen').classList.add('active');
      document.getElementById('emailLoginScreen').classList.remove('active');
    }

    function showEmailLogin() {
      document.getElementById('pinLoginScreen').classList.remove('active');
      document.getElementById('seedRecoveryScreen').classList.remove('active');
      document.getElementById('emailLoginScreen').classList.add('active');
      try {
        const remembered = String(localStorage.getItem('autho_email') || '').trim();
        if (remembered) {
          const el = document.getElementById('emailInput');
          if (el) el.value = remembered;
        }
      } catch {}
    }

    function b64FromBytes(bytes) {
      let binary = '';
      const chunkSize = 0x8000;
      for (let i = 0; i < bytes.length; i += chunkSize) {
        binary += String.fromCharCode(...bytes.slice(i, i + chunkSize));
      }
      return btoa(binary);
    }

    function bytesFromB64(b64) {
      return Uint8Array.from(atob(b64), c => c.charCodeAt(0));
    }

    async function deriveVaultKey(password, saltBytes, iterations) {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        'raw',
        enc.encode(String(password)),
        { name: 'PBKDF2' },
        false,
        ['deriveKey']
      );
      return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt: saltBytes, iterations, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
      );
    }

    async function encryptWalletVault(walletPayload, password) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const iterations = 210000;
      const key = await deriveVaultKey(password, salt, iterations);
      const pt = new TextEncoder().encode(JSON.stringify(walletPayload));
      const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, pt);
      return {
        v: 'AUTHO_WALLET_VAULT_V1',
        kdf: { saltB64: b64FromBytes(salt), iterations, hash: 'SHA-256' },
        enc: { ivB64: b64FromBytes(iv), ctB64: b64FromBytes(new Uint8Array(ct)) }
      };
    }

    async function decryptWalletVault(walletVault, password) {
      if (!walletVault || walletVault.v !== 'AUTHO_WALLET_VAULT_V1') {
        throw new Error('Unsupported wallet vault format');
      }
      const salt = bytesFromB64(walletVault.kdf?.saltB64 || '');
      const iterations = Number(walletVault.kdf?.iterations || 0);
      const iv = bytesFromB64(walletVault.enc?.ivB64 || '');
      const ct = bytesFromB64(walletVault.enc?.ctB64 || '');
      const key = await deriveVaultKey(password, salt, iterations);
      const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
      const json = new TextDecoder().decode(pt);
      return JSON.parse(json);
    }

    function persistRestoredWallet(walletPayload) {
      const network = walletPayload.network || 'mainnet';
      const wallet = {
        publicKey: walletPayload.publicKey,
        address: walletPayload.address,
        paymentAddress: walletPayload.paymentAddress || walletPayload.address,
        network: network,
        derivationPath: walletPayload.derivationPath || "m/84'/0'/0'/0/0",
      };
      localStorage.setItem('autho_wallet', JSON.stringify(wallet));
      localStorage.setItem('autho_wallet_encrypted', b64FromBytes(new TextEncoder().encode(JSON.stringify({ createdAt: walletPayload.createdAt || Date.now() }))));
      sessionStorage.setItem('autho_wallet_unlocked', 'true');
      const unlockTime = Date.now().toString();
      sessionStorage.setItem('autho_wallet_unlock_time', unlockTime);
      try {
        localStorage.setItem('autho_wallet_unlocked', 'true');
        localStorage.setItem('autho_wallet_unlock_time', unlockTime);
      } catch {}
      
      // Derive messaging keypair from mnemonic (separate from BTC key, uses domain separation)
      // This key is used for E2E encrypted messaging, NOT for spending BTC
      console.log('[Login] persistRestoredWallet - hasMnemonic:', !!walletPayload.mnemonic, 'hasAuthoBTC:', !!window.AuthoBTC, 'hasDeriveFunc:', !!window.AuthoBTC?.deriveMessagingKeyPairSync);
      if (walletPayload.mnemonic && window.AuthoBTC?.deriveMessagingKeyPairSync) {
        try {
          const msgKeys = window.AuthoBTC.deriveMessagingKeyPairSync(walletPayload.mnemonic);
          console.log('[Login] Derived messaging keys:', !!msgKeys?.privateKeyHex, !!msgKeys?.publicKeyHex);
          if (msgKeys && msgKeys.privateKeyHex && msgKeys.publicKeyHex) {
            sessionStorage.setItem('autho_messaging_privateKey', msgKeys.privateKeyHex);
            sessionStorage.setItem('autho_messaging_publicKey', msgKeys.publicKeyHex);
            console.log('[Login] Messaging keys stored in sessionStorage');
            // Publish X25519 encryption key to network immediately (like Signal does)
            publishMessagingKey(msgKeys.privateKeyHex);
          }
        } catch (e) {
          console.error('Failed to derive messaging keypair:', e);
        }
      } else {
        console.warn('[Login] Cannot derive messaging keys - missing mnemonic or AuthoBTC.deriveMessagingKeyPairSync');
      }
    }

    async function loginWithEmail() {
      const email = String(document.getElementById('emailInput')?.value || '').trim();
      const password = String(document.getElementById('passwordInput')?.value || '');
      const btn = document.getElementById('emailLoginBtn');
      if (!email) {
        showError('Please enter your email', 'emailErrorMessage');
        return;
      }
      if (!password) {
        showError('Please enter your password', 'emailErrorMessage');
        return;
      }

      try {
        if (btn) {
          btn.disabled = true;
          btn.textContent = 'Signing In...';
        }

        const response = await fetch('/api/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, password })
        });
        const data = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(data.error || 'Login failed');
        }

        localStorage.setItem('autho_session_id', data.sessionId);
        localStorage.setItem('autho_account_id', data.accountId);
        localStorage.setItem('autho_email', email);

        if (data.walletVault) {
          localStorage.setItem('autho_wallet_vault', JSON.stringify(data.walletVault));
          const walletPayload = await decryptWalletVault(data.walletVault, password);
          persistRestoredWallet(walletPayload);

          try {
            let pin = sessionStorage.getItem('autho_session_pin') || '';
            if (!pin) {
              const pinStored = localStorage.getItem('autho_wallet_pin');
              if (pinStored && !pinStored.startsWith('pbkdf2v1:')) { try { pin = atob(pinStored); } catch {} }
            }
            if (pin) {
              const localVault = await encryptWalletVault(walletPayload, pin);
              localStorage.setItem('autho_wallet_vault_local', JSON.stringify(localVault));
            }
          } catch {}
        } else {
          const localVaultStr = localStorage.getItem('autho_wallet_vault');
          if (localVaultStr) {
            try {
              const localVault = JSON.parse(localVaultStr);
              const walletPayload = await decryptWalletVault(localVault, password);
              persistRestoredWallet(walletPayload);

              try {
                let pin2 = sessionStorage.getItem('autho_session_pin') || '';
                if (!pin2) {
                  const pinStored2 = localStorage.getItem('autho_wallet_pin');
                  if (pinStored2 && !pinStored2.startsWith('pbkdf2v1:')) { try { pin2 = atob(pinStored2); } catch {} }
                }
                if (pin2) {
                  const vaultLocal = await encryptWalletVault(walletPayload, pin2);
                  localStorage.setItem('autho_wallet_vault_local', JSON.stringify(vaultLocal));
                }
              } catch {}
            } catch {}
          }

          sessionStorage.setItem('autho_wallet_unlocked', 'true');
          const unlockTime = Date.now().toString();
          sessionStorage.setItem('autho_wallet_unlock_time', unlockTime);
          try {
            localStorage.setItem('autho_wallet_unlocked', 'true');
            localStorage.setItem('autho_wallet_unlock_time', unlockTime);
          } catch {}
        }

        const returnUrl = new URLSearchParams(window.location.search).get('return') || '/m';
        window.location.href = returnUrl;
      } catch (e) {
        showError(String(e?.message || e), 'emailErrorMessage');
      } finally {
        try {
          if (btn) {
            btn.disabled = false;
            btn.textContent = 'üîì Sign In & Unlock';
          }
        } catch {}
      }
    }

    async function recoverWallet() {
      const seedPhrase = document.getElementById('seedPhraseInput').value.trim();
      const newPin = document.getElementById('newPinInput').value.trim();

      if (!seedPhrase) {
        showError('Please enter your seed phrase', 'seedErrorMessage');
        return;
      }

      const words = seedPhrase.toLowerCase().split(/\s+/);
      if (words.length !== 24) {
        showError('Seed phrase must be exactly 24 words', 'seedErrorMessage');
        return;
      }

      if (!newPin || newPin.length < 6) {
        showError('Passcode must be at least 6 characters', 'seedErrorMessage');
        return;
      }

      try {
        if (!window.AuthoBTC || typeof window.AuthoBTC.getAddressFromMnemonic !== 'function') {
          throw new Error('Wallet library not loaded');
        }

        const network = 'mainnet';
        const normalizedSeed = seedPhrase.toLowerCase().trim();
        const address = window.AuthoBTC.getAddressFromMnemonic(normalizedSeed, network, 0, 0);
        const publicKey = window.AuthoBTC.getPublicKeyFromMnemonic(normalizedSeed, network, 0, 0);

        const wallet = {
          publicKey,
          address,
          paymentAddress: address,
          network,
          derivationPath: "m/84'/0'/0'/0/0"
        };
        localStorage.setItem('autho_wallet', JSON.stringify(wallet));
        localStorage.setItem('autho_wallet_encrypted', btoa(JSON.stringify({ createdAt: Date.now() })));

        // Set new local PIN (device unlock) - PBKDF2 hashed
        const pinHash = await hashPinPBKDF2(newPin);
        localStorage.setItem('autho_wallet_pin', pinHash);
        sessionStorage.setItem('autho_session_pin', newPin);

        try {
          const walletPayload = {
            mnemonic: normalizedSeed,
            publicKey,
            address,
            paymentAddress: address,
            network,
            derivationPath: wallet.derivationPath || "m/84'/0'/0'/0/0",
            createdAt: Date.now()
          };
          const localVault = await encryptWalletVault(walletPayload, newPin);
          localStorage.setItem('autho_wallet_vault_local', JSON.stringify(localVault));
        } catch {}

        alert('‚úÖ Wallet recovered on this device. Your new passcode has been set. Now sign in with email+password to restore your wallet vault on this device.');
        showPinLogin();
      } catch (error) {
        console.error('Error recovering wallet:', error);
        showError('Error recovering wallet', 'seedErrorMessage');
      }
    }

    function forgotPin() {
      alert('If you forgot your wallet passcode on this device, use "Sign In with Email" (recommended) or recover with your seed phrase to set a new passcode.');
    }

    // Derive X25519 encryption public key from messaging private key
    async function deriveX25519PublicKey(privateKeyHex) {
      try {
        // Wait for nacl to load
        let attempts = 0;
        while (!window.nacl || !window.nacl.box) {
          if (attempts++ > 50) return null;
          await new Promise(r => setTimeout(r, 100));
        }
        // Convert hex to bytes
        const privateKeyBytes = new Uint8Array(privateKeyHex.match(/.{2}/g).map(b => parseInt(b, 16)));
        // SHA-256 hash to get 32-byte seed for X25519
        const hashBuffer = await crypto.subtle.digest('SHA-256', privateKeyBytes);
        const seed = new Uint8Array(hashBuffer);
        // Derive X25519 keypair
        const keyPair = nacl.box.keyPair.fromSecretKey(seed);
        // Return public key as hex
        return Array.from(keyPair.publicKey).map(b => b.toString(16).padStart(2, '0')).join('');
      } catch (e) {
        console.error('Failed to derive X25519 key:', e);
        return null;
      }
    }

    // Publish messaging public key to operator nodes (Signal-style immediate registration)
    async function publishMessagingKey(privateKeyHex) {
      try {
        const sessionId = localStorage.getItem('autho_session_id');
        const accountId = localStorage.getItem('autho_account_id');
        if (!sessionId || !privateKeyHex) return;
        
        // Derive the X25519 encryption public key from the private key
        const encryptionPublicKeyHex = await deriveX25519PublicKey(privateKeyHex);
        if (!encryptionPublicKeyHex) {
          console.log('Could not derive X25519 key, will publish on messages page');
          return;
        }
        
        await fetch('/api/messages/keys', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${sessionId}`,
            'X-Account-Id': accountId || ''
          },
          body: JSON.stringify({ encryptionPublicKeyHex })
        });
      } catch (e) {
        console.log('Messaging key publish (best effort):', e.message);
      }
    }

    // Handle Enter key on PIN input
    document.addEventListener('DOMContentLoaded', () => {
      const pinInput = document.getElementById('pinInput');
      if (pinInput) {
        pinInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            unlockWithPin();
          }
        });
      }

      try {
        const hasLocalPasscode = !!localStorage.getItem('autho_wallet_pin');
        if (!hasLocalPasscode) {
          showEmailLogin();
        }
      } catch {}
    });
  </script>
</body>
</html>
