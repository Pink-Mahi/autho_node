<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Autho Mempool Visualizer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
    }
    
    .header {
      background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
      padding: 20px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .header h1 {
      font-size: 24px;
      color: #4ade80;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .header h1 span {
      font-size: 14px;
      color: #888;
      font-weight: normal;
    }
    
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    
    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ef4444;
      animation: pulse 2s infinite;
    }
    
    .status-dot.connected {
      background: #4ade80;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .main-container {
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 20px;
      padding: 20px;
      max-width: 1600px;
      margin: 0 auto;
    }
    
    .mempool-section {
      background: #16213e;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #333;
    }
    
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .section-title {
      font-size: 18px;
      color: #4ade80;
    }
    
    .event-filters {
      display: flex;
      gap: 8px;
    }
    
    .filter-btn {
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid #444;
      background: transparent;
      color: #888;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    
    .filter-btn:hover, .filter-btn.active {
      background: #4ade80;
      color: #1a1a2e;
      border-color: #4ade80;
    }
    
    /* Treemap Container */
    .treemap-container {
      width: 100%;
      height: 500px;
      background: #0f0f1a;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }
    
    .treemap-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #666;
    }
    
    .treemap-empty svg {
      width: 80px;
      height: 80px;
      margin-bottom: 15px;
      opacity: 0.3;
    }
    
    /* Event blocks in treemap */
    .event-block {
      position: absolute;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: rgba(255,255,255,0.9);
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      padding: 2px;
    }
    
    .event-block:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
      z-index: 100;
    }
    
    .event-block.new {
      animation: blockAppear 0.5s ease-out;
    }
    
    @keyframes blockAppear {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* Event type colors */
    .event-block.ACCOUNT_CREATED { background: linear-gradient(135deg, #3b82f6, #1d4ed8); }
    .event-block.ITEM_MINTED { background: linear-gradient(135deg, #22c55e, #15803d); }
    .event-block.TITLE_UPDATED { background: linear-gradient(135deg, #f59e0b, #d97706); }
    .event-block.SETTLEMENT_CREATED { background: linear-gradient(135deg, #8b5cf6, #6d28d9); }
    .event-block.SETTLEMENT_COMPLETED { background: linear-gradient(135deg, #ec4899, #be185d); }
    .event-block.CONSIGNMENT_CREATED { background: linear-gradient(135deg, #06b6d4, #0891b2); }
    .event-block.OPERATOR_CANDIDATE_REQUESTED { background: linear-gradient(135deg, #f97316, #ea580c); }
    .event-block.OPERATOR_ADMITTED { background: linear-gradient(135deg, #84cc16, #65a30d); }
    .event-block.OPERATOR_HEARTBEAT { background: linear-gradient(135deg, #64748b, #475569); }
    .event-block.default { background: linear-gradient(135deg, #6b7280, #4b5563); }
    
    /* Sidebar */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .stats-card {
      background: #16213e;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #333;
    }
    
    .stats-card h3 {
      font-size: 14px;
      color: #888;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid #333;
    }
    
    .stat-row:last-child {
      border-bottom: none;
    }
    
    .stat-label {
      color: #888;
      font-size: 14px;
    }
    
    .stat-value {
      font-size: 18px;
      font-weight: 600;
      color: #4ade80;
    }
    
    .stat-value.warning {
      color: #f59e0b;
    }
    
    .stat-value.danger {
      color: #ef4444;
    }
    
    /* Checkpoint Progress */
    .checkpoint-progress {
      margin-top: 15px;
    }
    
    .progress-bar {
      height: 8px;
      background: #333;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 8px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4ade80, #22c55e);
      border-radius: 4px;
      transition: width 0.3s ease;
    }
    
    .progress-label {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #888;
    }
    
    /* Recent Events List */
    .recent-events {
      max-height: 300px;
      overflow-y: auto;
    }
    
    .event-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 8px;
      background: #0f0f1a;
      transition: background 0.2s;
    }
    
    .event-item:hover {
      background: #1f1f3a;
    }
    
    .event-item.new {
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from { transform: translateX(-20px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    .event-type-badge {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      min-width: 80px;
      text-align: center;
    }
    
    .event-type-badge.ACCOUNT_CREATED { background: #3b82f6; }
    .event-type-badge.ITEM_MINTED { background: #22c55e; }
    .event-type-badge.TITLE_UPDATED { background: #f59e0b; }
    .event-type-badge.SETTLEMENT_CREATED { background: #8b5cf6; }
    .event-type-badge.SETTLEMENT_COMPLETED { background: #ec4899; }
    .event-type-badge.CONSIGNMENT_CREATED { background: #06b6d4; }
    .event-type-badge.OPERATOR_CANDIDATE_REQUESTED { background: #f97316; }
    .event-type-badge.OPERATOR_ADMITTED { background: #84cc16; }
    .event-type-badge.OPERATOR_HEARTBEAT { background: #64748b; }
    .event-type-badge.default { background: #6b7280; }
    
    .event-details {
      flex: 1;
      min-width: 0;
    }
    
    .event-id {
      font-family: monospace;
      font-size: 11px;
      color: #888;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .event-time {
      font-size: 11px;
      color: #666;
    }
    
    /* Network Health */
    .network-nodes {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
      gap: 8px;
      margin-top: 15px;
    }
    
    .node-indicator {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    .node-indicator:hover {
      transform: scale(1.1);
    }
    
    .node-indicator.online {
      background: linear-gradient(135deg, #22c55e, #15803d);
    }
    
    .node-indicator.syncing {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      animation: pulse 1s infinite;
    }
    
    .node-indicator.offline {
      background: linear-gradient(135deg, #ef4444, #b91c1c);
    }
    
    /* Legend */
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: #888;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }
    
    /* Checkpoint Timeline */
    .checkpoint-timeline {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 15px;
      overflow-x: auto;
      padding-bottom: 10px;
    }
    
    .checkpoint-block {
      min-width: 50px;
      height: 40px;
      background: linear-gradient(135deg, #4ade80, #22c55e);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    .checkpoint-block:hover {
      transform: scale(1.05);
    }
    
    .checkpoint-block.pending {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      animation: pulse 1s infinite;
    }
    
    .checkpoint-number {
      font-weight: 600;
    }
    
    .checkpoint-events {
      font-size: 9px;
      opacity: 0.8;
    }
    
    /* Tooltip */
    .tooltip {
      position: fixed;
      background: #1a1a2e;
      border: 1px solid #4ade80;
      border-radius: 8px;
      padding: 12px;
      font-size: 12px;
      z-index: 1000;
      pointer-events: none;
      max-width: 300px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      display: none;
    }
    
    .tooltip.visible {
      display: block;
    }
    
    .tooltip-title {
      font-weight: 600;
      color: #4ade80;
      margin-bottom: 8px;
    }
    
    .tooltip-row {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      margin-bottom: 4px;
    }
    
    .tooltip-label {
      color: #888;
    }
    
    .tooltip-value {
      color: #eee;
      font-family: monospace;
      word-break: break-all;
    }
    
    /* Mobile responsive */
    @media (max-width: 900px) {
      .main-container {
        grid-template-columns: 1fr;
      }
      
      .treemap-container {
        height: 350px;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>
      üîó Autho Mempool Visualizer
      <span>Real-time Consensus Activity</span>
    </h1>
    <div class="status-indicator">
      <div class="status-dot" id="connectionStatus"></div>
      <span id="connectionText">Connecting...</span>
    </div>
  </div>
  
  <div class="main-container">
    <div class="mempool-section">
      <div class="section-header">
        <h2 class="section-title">üì¶ Pending Events</h2>
        <div class="event-filters">
          <button class="filter-btn active" data-filter="all">All</button>
          <button class="filter-btn" data-filter="ITEM_MINTED">Items</button>
          <button class="filter-btn" data-filter="TITLE_UPDATED">Titles</button>
          <button class="filter-btn" data-filter="SETTLEMENT">Settlements</button>
          <button class="filter-btn" data-filter="OPERATOR">Operators</button>
        </div>
      </div>
      
      <div class="treemap-container" id="treemap">
        <div class="treemap-empty">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zM7 10h2v7H7zm4-3h2v10h-2zm4 6h2v4h-2z"/>
          </svg>
          <div>Waiting for events...</div>
          <div style="font-size: 12px; margin-top: 5px;">Events will appear here as they enter the mempool</div>
        </div>
      </div>
      
      <div class="legend">
        <div class="legend-item"><div class="legend-color" style="background: #3b82f6;"></div> Account</div>
        <div class="legend-item"><div class="legend-color" style="background: #22c55e;"></div> Item Mint</div>
        <div class="legend-item"><div class="legend-color" style="background: #f59e0b;"></div> Title Update</div>
        <div class="legend-item"><div class="legend-color" style="background: #8b5cf6;"></div> Settlement</div>
        <div class="legend-item"><div class="legend-color" style="background: #06b6d4;"></div> Consignment</div>
        <div class="legend-item"><div class="legend-color" style="background: #f97316;"></div> Operator</div>
      </div>
    </div>
    
    <div class="sidebar">
      <div class="stats-card">
        <h3>‚ö° Consensus Status</h3>
        <div class="stat-row">
          <span class="stat-label">Mempool Size</span>
          <span class="stat-value" id="mempoolSize">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Valid Events</span>
          <span class="stat-value" id="validEvents">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Pending Validation</span>
          <span class="stat-value" id="pendingEvents">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Current Leader</span>
          <span class="stat-value" id="currentLeader" style="font-size: 12px;">-</span>
        </div>
        
        <div class="checkpoint-progress">
          <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <span style="font-size: 12px; color: #888;">Next Checkpoint</span>
            <span style="font-size: 12px; color: #4ade80;" id="checkpointTimer">30s</span>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="checkpointProgress" style="width: 0%;"></div>
          </div>
          <div class="progress-label">
            <span>Checkpoint #<span id="nextCheckpoint">1</span></span>
            <span id="eventsInCheckpoint">0 events</span>
          </div>
        </div>
      </div>
      
      <div class="stats-card">
        <h3>üåê Network Health</h3>
        <div class="stat-row">
          <span class="stat-label">Active Operators</span>
          <span class="stat-value" id="activeOperators">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Connected Peers</span>
          <span class="stat-value" id="connectedPeers">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Ledger Sequence</span>
          <span class="stat-value" id="ledgerSequence">0</span>
        </div>
        
        <div class="network-nodes" id="networkNodes">
          <!-- Node indicators will be added here -->
        </div>
      </div>
      
      <div class="stats-card">
        <h3>üìã Recent Checkpoints</h3>
        <div class="checkpoint-timeline" id="checkpointTimeline">
          <!-- Checkpoint blocks will be added here -->
        </div>
      </div>
      
      <div class="stats-card">
        <h3>üìú Recent Events</h3>
        <div class="recent-events" id="recentEvents">
          <!-- Event items will be added here -->
        </div>
      </div>
    </div>
  </div>
  
  <div class="tooltip" id="tooltip">
    <div class="tooltip-title" id="tooltipTitle">Event Details</div>
    <div id="tooltipContent"></div>
  </div>
  
  <script>
    // State
    let ws = null;
    let mempoolEvents = [];
    let recentEvents = [];
    let checkpoints = [];
    let consensusState = null;
    let currentFilter = 'all';
    let checkpointStartTime = Date.now();
    const CHECKPOINT_INTERVAL = 30000;
    
    // DOM Elements
    const treemap = document.getElementById('treemap');
    const tooltip = document.getElementById('tooltip');
    const connectionStatus = document.getElementById('connectionStatus');
    const connectionText = document.getElementById('connectionText');
    
    // Connect to WebSocket
    function connect() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}`;
      
      ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        connectionStatus.classList.add('connected');
        connectionText.textContent = 'Connected';
        
        // Request initial state
        ws.send(JSON.stringify({ type: 'sync_request' }));
        
        // Subscribe to consensus updates
        ws.send(JSON.stringify({ type: 'subscribe_consensus' }));
      };
      
      ws.onclose = () => {
        connectionStatus.classList.remove('connected');
        connectionText.textContent = 'Disconnected - Reconnecting...';
        setTimeout(connect, 3000);
      };
      
      ws.onerror = () => {
        connectionStatus.classList.remove('connected');
        connectionText.textContent = 'Connection Error';
      };
      
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleMessage(data);
        } catch (e) {
          console.error('Failed to parse message:', e);
        }
      };
    }
    
    // Handle incoming messages
    function handleMessage(data) {
      switch (data.type) {
        case 'consensus_state':
          consensusState = data.state;
          updateStats();
          break;
          
        case 'mempool_event':
          addMempoolEvent(data.payload || data.event);
          break;
          
        case 'mempool_snapshot':
          mempoolEvents = data.events || [];
          renderTreemap();
          break;
          
        case 'checkpoint_proposal':
          handleCheckpointProposal(data.payload);
          break;
          
        case 'checkpoint_finalized':
          handleCheckpointFinalized(data.payload);
          break;
          
        case 'sync_response':
        case 'sync_data':
          if (data.data?.events) {
            // Add recent events from sync
            data.data.events.slice(-20).forEach(e => {
              addRecentEvent({
                eventId: e.eventHash,
                type: e.payload?.type || e.type,
                timestamp: e.timestamp,
              });
            });
          }
          break;
          
        case 'registry_update':
          document.getElementById('ledgerSequence').textContent = data.data?.sequenceNumber || 0;
          break;
      }
    }
    
    // Add event to mempool
    function addMempoolEvent(event) {
      if (!event) return;
      
      // Check for duplicate
      const exists = mempoolEvents.find(e => e.eventId === event.eventId);
      if (exists) return;
      
      event.isNew = true;
      mempoolEvents.push(event);
      
      // Also add to recent events
      addRecentEvent(event);
      
      // Re-render treemap
      renderTreemap();
      
      // Update stats
      updateStats();
      
      // Remove "new" flag after animation
      setTimeout(() => {
        event.isNew = false;
      }, 500);
    }
    
    // Add to recent events list
    function addRecentEvent(event) {
      recentEvents.unshift({
        ...event,
        isNew: true,
      });
      
      // Keep only last 20
      if (recentEvents.length > 20) {
        recentEvents = recentEvents.slice(0, 20);
      }
      
      renderRecentEvents();
      
      setTimeout(() => {
        event.isNew = false;
      }, 300);
    }
    
    // Handle checkpoint proposal
    function handleCheckpointProposal(proposal) {
      checkpointStartTime = Date.now();
      document.getElementById('nextCheckpoint').textContent = proposal.checkpointNumber;
      document.getElementById('eventsInCheckpoint').textContent = `${proposal.eventIds?.length || 0} events`;
    }
    
    // Handle checkpoint finalized
    function handleCheckpointFinalized(checkpoint) {
      // Remove finalized events from mempool
      const finalizedIds = new Set(checkpoint.events?.map(e => e.eventId) || []);
      mempoolEvents = mempoolEvents.filter(e => !finalizedIds.has(e.eventId));
      
      // Add to checkpoints
      checkpoints.push(checkpoint);
      if (checkpoints.length > 10) {
        checkpoints = checkpoints.slice(-10);
      }
      
      // Reset checkpoint timer
      checkpointStartTime = Date.now();
      
      renderTreemap();
      renderCheckpointTimeline();
      updateStats();
    }
    
    // Render treemap visualization
    function renderTreemap() {
      let filtered = mempoolEvents;
      
      // Apply filter
      if (currentFilter !== 'all') {
        filtered = mempoolEvents.filter(e => {
          const type = e.type || '';
          if (currentFilter === 'SETTLEMENT') {
            return type.includes('SETTLEMENT');
          }
          if (currentFilter === 'OPERATOR') {
            return type.includes('OPERATOR');
          }
          return type === currentFilter;
        });
      }
      
      if (filtered.length === 0) {
        treemap.innerHTML = `
          <div class="treemap-empty">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zM7 10h2v7H7zm4-3h2v10h-2zm4 6h2v4h-2z"/>
            </svg>
            <div>Waiting for events...</div>
            <div style="font-size: 12px; margin-top: 5px;">Events will appear here as they enter the mempool</div>
          </div>
        `;
        return;
      }
      
      // Calculate treemap layout
      const containerWidth = treemap.clientWidth;
      const containerHeight = treemap.clientHeight;
      const padding = 4;
      
      // Simple squarified treemap algorithm
      const layout = calculateTreemapLayout(filtered, containerWidth, containerHeight, padding);
      
      // Render blocks
      treemap.innerHTML = '';
      layout.forEach((item, index) => {
        const block = document.createElement('div');
        const eventType = item.event.type || 'default';
        const typeClass = eventType.replace(/_/g, '_');
        
        block.className = `event-block ${typeClass} ${item.event.isNew ? 'new' : ''}`;
        block.style.left = `${item.x}px`;
        block.style.top = `${item.y}px`;
        block.style.width = `${item.width}px`;
        block.style.height = `${item.height}px`;
        
        // Show type abbreviation for larger blocks
        if (item.width > 40 && item.height > 20) {
          block.textContent = getTypeAbbrev(eventType);
        }
        
        // Tooltip events
        block.addEventListener('mouseenter', (e) => showTooltip(e, item.event));
        block.addEventListener('mousemove', (e) => moveTooltip(e));
        block.addEventListener('mouseleave', hideTooltip);
        
        treemap.appendChild(block);
      });
    }
    
    // Calculate treemap layout (simple row-based algorithm)
    function calculateTreemapLayout(events, width, height, padding) {
      const layout = [];
      const n = events.length;
      
      if (n === 0) return layout;
      
      // Calculate grid dimensions
      const cols = Math.ceil(Math.sqrt(n * (width / height)));
      const rows = Math.ceil(n / cols);
      
      const cellWidth = (width - padding * (cols + 1)) / cols;
      const cellHeight = (height - padding * (rows + 1)) / rows;
      
      events.forEach((event, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        
        // Add some size variation based on event "weight"
        const weight = getEventWeight(event);
        const sizeMultiplier = 0.8 + (weight * 0.4);
        
        const w = Math.min(cellWidth * sizeMultiplier, cellWidth);
        const h = Math.min(cellHeight * sizeMultiplier, cellHeight);
        
        layout.push({
          event,
          x: padding + col * (cellWidth + padding) + (cellWidth - w) / 2,
          y: padding + row * (cellHeight + padding) + (cellHeight - h) / 2,
          width: w,
          height: h,
        });
      });
      
      return layout;
    }
    
    // Get event weight for sizing
    function getEventWeight(event) {
      const type = event.type || '';
      if (type.includes('SETTLEMENT')) return 1.0;
      if (type.includes('ITEM_MINTED')) return 0.8;
      if (type.includes('TITLE_UPDATED')) return 0.7;
      if (type.includes('OPERATOR')) return 0.9;
      if (type.includes('ACCOUNT')) return 0.6;
      return 0.5;
    }
    
    // Get type abbreviation
    function getTypeAbbrev(type) {
      const abbrevs = {
        'ACCOUNT_CREATED': 'ACC',
        'ITEM_MINTED': 'MINT',
        'TITLE_UPDATED': 'TITLE',
        'SETTLEMENT_CREATED': 'SETL',
        'SETTLEMENT_COMPLETED': 'DONE',
        'CONSIGNMENT_CREATED': 'CONS',
        'OPERATOR_CANDIDATE_REQUESTED': 'OP+',
        'OPERATOR_ADMITTED': 'OP‚úì',
        'OPERATOR_HEARTBEAT': '‚ô•',
      };
      return abbrevs[type] || type.substring(0, 4);
    }
    
    // Tooltip functions
    function showTooltip(e, event) {
      const content = `
        <div class="tooltip-row">
          <span class="tooltip-label">Type:</span>
          <span class="tooltip-value">${event.type}</span>
        </div>
        <div class="tooltip-row">
          <span class="tooltip-label">Event ID:</span>
          <span class="tooltip-value">${event.eventId?.substring(0, 16)}...</span>
        </div>
        <div class="tooltip-row">
          <span class="tooltip-label">Creator:</span>
          <span class="tooltip-value">${event.creatorId || 'Unknown'}</span>
        </div>
        <div class="tooltip-row">
          <span class="tooltip-label">Age:</span>
          <span class="tooltip-value">${formatAge(event.timestamp || event.receivedAt)}</span>
        </div>
        <div class="tooltip-row">
          <span class="tooltip-label">Status:</span>
          <span class="tooltip-value">${event.validationStatus || 'pending'}</span>
        </div>
      `;
      
      document.getElementById('tooltipTitle').textContent = getTypeAbbrev(event.type) + ' Event';
      document.getElementById('tooltipContent').innerHTML = content;
      tooltip.classList.add('visible');
      moveTooltip(e);
    }
    
    function moveTooltip(e) {
      tooltip.style.left = `${e.clientX + 15}px`;
      tooltip.style.top = `${e.clientY + 15}px`;
    }
    
    function hideTooltip() {
      tooltip.classList.remove('visible');
    }
    
    // Render recent events list
    function renderRecentEvents() {
      const container = document.getElementById('recentEvents');
      container.innerHTML = recentEvents.map(event => {
        const type = event.type || 'UNKNOWN';
        const typeClass = type.replace(/_/g, '_');
        return `
          <div class="event-item ${event.isNew ? 'new' : ''}">
            <span class="event-type-badge ${typeClass}">${getTypeAbbrev(type)}</span>
            <div class="event-details">
              <div class="event-id">${event.eventId?.substring(0, 20) || 'Unknown'}...</div>
              <div class="event-time">${formatAge(event.timestamp)}</div>
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Render checkpoint timeline
    function renderCheckpointTimeline() {
      const container = document.getElementById('checkpointTimeline');
      
      const blocks = checkpoints.slice(-8).map(cp => `
        <div class="checkpoint-block" title="Checkpoint #${cp.checkpointNumber}">
          <span class="checkpoint-number">#${cp.checkpointNumber}</span>
          <span class="checkpoint-events">${cp.events?.length || 0} txs</span>
        </div>
      `);
      
      // Add pending checkpoint
      blocks.push(`
        <div class="checkpoint-block pending" title="Next checkpoint">
          <span class="checkpoint-number">#${(checkpoints[checkpoints.length - 1]?.checkpointNumber || 0) + 1}</span>
          <span class="checkpoint-events">pending</span>
        </div>
      `);
      
      container.innerHTML = blocks.join('');
    }
    
    // Update stats display
    function updateStats() {
      document.getElementById('mempoolSize').textContent = mempoolEvents.length;
      document.getElementById('validEvents').textContent = mempoolEvents.filter(e => e.validationStatus === 'valid').length;
      document.getElementById('pendingEvents').textContent = mempoolEvents.filter(e => e.validationStatus === 'pending').length;
      
      if (consensusState) {
        document.getElementById('currentLeader').textContent = consensusState.currentLeaderId || '-';
        document.getElementById('activeOperators').textContent = consensusState.activeOperators?.length || 0;
        document.getElementById('nextCheckpoint').textContent = (consensusState.currentCheckpointNumber || 0) + 1;
        
        // Render network nodes
        renderNetworkNodes(consensusState.activeOperators || []);
      }
    }
    
    // Render network node indicators
    function renderNetworkNodes(operators) {
      const container = document.getElementById('networkNodes');
      container.innerHTML = operators.map((op, i) => {
        const status = 'online'; // Would come from actual health check
        const initial = (op.nodeId || op.operatorId || `N${i}`).substring(0, 2).toUpperCase();
        return `
          <div class="node-indicator ${status}" title="${op.nodeId || op.operatorId}">
            ${initial}
          </div>
        `;
      }).join('');
      
      document.getElementById('connectedPeers').textContent = operators.length;
    }
    
    // Format age
    function formatAge(timestamp) {
      if (!timestamp) return 'Unknown';
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return `${seconds}s ago`;
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
      return `${Math.floor(seconds / 3600)}h ago`;
    }
    
    // Update checkpoint progress bar
    function updateCheckpointProgress() {
      const elapsed = Date.now() - checkpointStartTime;
      const progress = Math.min(100, (elapsed / CHECKPOINT_INTERVAL) * 100);
      const remaining = Math.max(0, Math.ceil((CHECKPOINT_INTERVAL - elapsed) / 1000));
      
      document.getElementById('checkpointProgress').style.width = `${progress}%`;
      document.getElementById('checkpointTimer').textContent = `${remaining}s`;
      document.getElementById('eventsInCheckpoint').textContent = `${mempoolEvents.length} events`;
    }
    
    // Filter buttons
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentFilter = btn.dataset.filter;
        renderTreemap();
      });
    });
    
    // Poll for consensus status
    async function pollConsensusStatus() {
      try {
        const response = await fetch('/api/consensus/status');
        const data = await response.json();
        
        if (data.success) {
          consensusState = data.consensus;
          consensusState.activeOperators = data.consensus.activeOperators || [];
          
          // Update mempool stats
          document.getElementById('mempoolSize').textContent = data.mempool?.totalEvents || 0;
          document.getElementById('validEvents').textContent = data.mempool?.validEvents || 0;
          document.getElementById('pendingEvents').textContent = data.mempool?.pendingEvents || 0;
          document.getElementById('currentLeader').textContent = data.consensus?.currentLeaderId || '-';
          document.getElementById('activeOperators').textContent = data.consensus?.activeOperators?.length || 0;
          document.getElementById('connectedPeers').textContent = data.connections?.operatorConnections || data.peers?.operatorPeers || 0;
          document.getElementById('ledgerSequence').textContent = data.consensus?.currentCheckpointNumber || 0;
          
          // Update checkpoints
          if (data.checkpoints?.recent) {
            checkpoints = data.checkpoints.recent.map(c => ({
              checkpointNumber: c.number,
              events: new Array(c.eventCount),
            }));
            renderCheckpointTimeline();
          }
          
          renderNetworkNodes(data.consensus?.activeOperators || []);
        }
      } catch (e) {
        console.error('Failed to poll consensus status:', e);
      }
    }
    
    // Initialize
    window.addEventListener('resize', () => renderTreemap());
    
    // Start polling and progress updates
    setInterval(updateCheckpointProgress, 100);
    setInterval(pollConsensusStatus, 2000);
    
    // Initial load
    pollConsensusStatus();
    connect();
    renderCheckpointTimeline();
  </script>
</body>
</html>
