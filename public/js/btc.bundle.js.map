{
  "version": 3,
  "sources": ["../../node_modules/@noble/hashes/src/crypto.ts", "../../node_modules/@noble/hashes/src/utils.ts", "../../node_modules/@noble/hashes/src/_md.ts", "../../node_modules/@noble/hashes/src/_u64.ts", "../../node_modules/@noble/hashes/src/sha2.ts", "../../node_modules/@noble/hashes/src/hmac.ts", "../../node_modules/@noble/curves/src/utils.ts", "../../node_modules/@noble/curves/src/abstract/modular.ts", "../../node_modules/@noble/curves/src/abstract/curve.ts", "../../node_modules/@noble/curves/src/abstract/weierstrass.ts", "../../node_modules/@noble/curves/src/_shortw_utils.ts", "../../node_modules/@noble/curves/src/secp256k1.ts", "../../node_modules/@noble/hashes/src/legacy.ts", "../../node_modules/@scure/base/index.ts", "../../node_modules/micro-packed/src/index.ts", "../../node_modules/@scure/btc-signer/src/utils.ts", "../../node_modules/@scure/btc-signer/src/script.ts", "../../node_modules/@scure/btc-signer/src/psbt.ts", "../../node_modules/@scure/btc-signer/src/payment.ts", "../../node_modules/@scure/btc-signer/src/transaction.ts", "../../node_modules/@scure/btc-signer/src/utxo.ts", "../../node_modules/@scure/bip32/index.ts", "../../node_modules/@noble/hashes/src/pbkdf2.ts", "../../node_modules/@scure/bip39/esm/index.js", "../../node_modules/@scure/bip39/esm/wordlists/english.js", "../../src/client/btc-browser.ts"],
  "sourcesContent": ["/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes, type CHash, type Input } from './utils.ts';\n\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Input): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Input, message: Input): Uint8Array;\n  create(hash: CHash, key: Input): HMAC<any>;\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes as abytes_,\n  bytesToHex as bytesToHex_,\n  concatBytes as concatBytes_,\n  hexToBytes as hexToBytes_,\n  isBytes as isBytes_,\n} from '@noble/hashes/utils.js';\nexport {\n  abytes,\n  anumber,\n  bytesToHex,\n  bytesToUtf8,\n  concatBytes,\n  hexToBytes,\n  isBytes,\n  randomBytes,\n  utf8ToBytes,\n} from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// tmp name until v2\nexport function _abool2(value: boolean, title: string = ''): boolean {\n  if (typeof value !== 'boolean') {\n    const prefix = title && `\"${title}\"`;\n    throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n  }\n  return value;\n}\n\n// tmp name until v2\n/** Asserts something is Uint8Array. */\nexport function _abytes2(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes_(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes_(bytes);\n  return hexToNumber(bytesToHex_(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes_(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes_(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes_(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */\nexport function asciiToBytes(ascii: string): Uint8Array {\n  return Uint8Array.from(ascii, (c, i) => {\n    const charCode = c.charCodeAt(0);\n    if (c.length !== 1 || charCode > 127) {\n      throw new Error(\n        `string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`\n      );\n    }\n    return charCode;\n  });\n}\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  const u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\n  const u8of = (byte: number) => Uint8Array.of(byte); // another shortcut\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes_(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes_(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\nexport function isHash(val: CHash): boolean {\n  return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nexport function _validateObject(\n  object: Record<string, any>,\n  fields: Record<string, string>,\n  optFields: Record<string, string> = {}\n): void {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  type Item = keyof typeof object;\n  function checkField(fieldName: Item, expectedType: string, isOpt: boolean) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null)\n      throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n", "/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  anumber,\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n} from '../utils.ts';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  return FpPow(Field(modulo), num, power);\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction assertIsSquare<T>(Fp: IField<T>, root: T, n: T): void {\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n}\n\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4<T>(Fp: IField<T>, n: T) {\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\n  const root = Fp.pow(n, p1div4);\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\nfunction sqrt5mod8<T>(Fp: IField<T>, n: T) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  const Fp_ = Field(P);\n  const tn = tonelliShanks(P);\n  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));//  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n  const c2 = tn(Fp_, c1);              //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n  const c3 = tn(Fp_, Fp_.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n  const c4 = (P + _7n) / _16n;         //  4. c4 = (q + 7) / 16        # Integer arithmetic\n  return <T>(Fp: IField<T>, n: T) => {\n    let tv1 = Fp.pow(n, c4);           //  1. tv1 = x^c4\n    let tv2 = Fp.mul(tv1, c1);         //  2. tv2 = c1 * tv1\n    const tv3 = Fp.mul(tv1, c2);       //  3. tv3 = c2 * tv1\n    const tv4 = Fp.mul(tv1, c3);       //  4. tv4 = c3 * tv1\n    const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n    const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n    tv1 = Fp.cmov(tv1, tv2, e1);       //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    tv2 = Fp.cmov(tv4, tv3, e2);       //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n    const root = Fp.cmov(tv1, tv2, e3);// 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n    assertIsSquare(Fp, root, n);\n    return root;\n  };\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Initialization (precomputation).\n  // Caching initialization could boost perf by 7%.\n  if (P < _3n) throw new Error('sqrt is not defined for small field');\n  // Factor P - 1 = Q * 2^S, where Q is odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n\n  // Find the first quadratic non-residue Z >= 2\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    // Basic primality test for P. After x iterations, chance of\n    // not finding quadratic non-residue is 2^x, so 2^1000.\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path; usually done before Z, but we do \"primality test\".\n  if (S === 1) return sqrt3mod4;\n\n  // Slow-path\n  // TODO: test on Fp2 and others\n  let cc = _Fp.pow(Z, Q); // c = z^Q\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    if (Fp.is0(n)) return n;\n    // Check if n is a quadratic residue using Legendre symbol\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\n\n    // Initialize variables for the main loop\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n\n    // Main loop\n    // while t != 1\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n      let i = 1;\n\n      // Find the smallest i >= 1 such that t^(2^i) \u2261 1 (mod P)\n      let t_tmp = Fp.sqr(t); // t^(2^1)\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n        if (i === M) throw new Error('Cannot find square root');\n      }\n\n      // Calculate the exponent for b: 2^(M - i - 1)\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n\n      // Update variables\n      M = i;\n      c = Fp.sqr(b); // c = b^2\n      t = Fp.mul(t, c); // t = (t * b^2)\n      R = Fp.mul(R, b); // R = R*b\n    }\n    return R;\n  };\n}\n\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P \u2261 3 (mod 4)\n * 2. P \u2261 5 (mod 8)\n * 3. P \u2261 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P \u2261 3 (mod 4) => \u221An = n^((P+1)/4)\n  if (P % _4n === _3n) return sqrt3mod4;\n  // P \u2261 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n  if (P % _8n === _5n) return sqrt5mod8;\n  // P \u2261 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n  if (P % _16n === _9n) return sqrt9mod16(P);\n  // Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  isLE: boolean;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  isValidNot0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  allowedLengths?: number[];\n  // legendre?(num: T): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array, skipValidation?: boolean): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'number',\n    BITS: 'number',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  _validateObject(field, opts);\n  // const max = 16384;\n  // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n  // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n  return field;\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(Fp: IField<T>, num: T, power: bigint): T {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch<T>(Fp: IField<T>, nums: T[], passZero = false): T[] {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n\n// TODO: remove\nexport function FpDiv<T>(Fp: IField<T>, lhs: T, rhs: T | bigint): T {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) \u2261 1    if a is a square (mod p), quadratic residue\n * * (a | p) \u2261 -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) \u2261 0    if a \u2261 0 (mod p)\n */\nexport function FpLegendre<T>(Fp: IField<T>, n: T): -1 | 0 | 1 {\n  // We can use 3rd argument as optional cache of this value\n  // but seems unneeded for now. The operation is very fast.\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\n  return yes ? 1 : zero ? 0 : -1;\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(Fp: IField<T>, n: T): boolean {\n  const l = FpLegendre(Fp, n);\n  return l === 1;\n}\n\nexport type NLength = { nByteLength: number; nBitLength: number };\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number): NLength {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\ntype SqrtFn = (n: bigint) => bigint;\ntype FieldOpts = Partial<{\n  sqrt: SqrtFn;\n  isLE: boolean;\n  BITS: number;\n  modFromBytes: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  allowedLengths?: readonly number[]; // for P521 (adds padding for smaller sizes)\n}>;\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLenOrOpts?: number | FieldOpts, // TODO: use opts only in v2?\n  isLE = false,\n  opts: { sqrt?: SqrtFn } = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  let _nbitLength: number | undefined = undefined;\n  let _sqrt: SqrtFn | undefined = undefined;\n  let modFromBytes: boolean = false;\n  let allowedLengths: undefined | readonly number[] = undefined;\n  if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n    if (opts.sqrt || isLE) throw new Error('cannot specify opts in two arguments');\n    const _opts = bitLenOrOpts;\n    if (_opts.BITS) _nbitLength = _opts.BITS;\n    if (_opts.sqrt) _sqrt = _opts.sqrt;\n    if (typeof _opts.isLE === 'boolean') isLE = _opts.isLE;\n    if (typeof _opts.modFromBytes === 'boolean') modFromBytes = _opts.modFromBytes;\n    allowedLengths = _opts.allowedLengths;\n  } else {\n    if (typeof bitLenOrOpts === 'number') _nbitLength = bitLenOrOpts;\n    if (opts.sqrt) _sqrt = opts.sqrt;\n  }\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    allowedLengths: allowedLengths,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    // is valid and invertible\n    isValidNot0: (num: bigint) => !f.is0(num) && f.isValid(num),\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      _sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes, skipValidation = true) => {\n      if (allowedLengths) {\n        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n          throw new Error(\n            'Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length\n          );\n        }\n        const padded = new Uint8Array(BYTES);\n        // isLE add 0 to right, !isLE to the left.\n        padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n        bytes = padded;\n      }\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n      if (modFromBytes) scalar = mod(scalar, ORDER);\n      if (!skipValidation)\n        if (!f.isValid(scalar)) throw new Error('invalid field element: outside of range 0..ORDER');\n      // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n      // protocol may allow non-reduced scalar that reduced later or changed some other way.\n      return scalar;\n    },\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov: (a, b, c) => (c ? b : a),\n  } as FpField);\n  return Object.freeze(f);\n}\n\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, validateObject } from '../utils.ts';\nimport { Field, FpInvertBatch, nLength, validateField, type IField } from './modular.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { Z?: never };\n\n// This was initialy do this way to re-use montgomery ladder in field (add->mul,double->sqr), but\n// that didn't happen and there is probably not much reason to have separate Group like this?\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n  toAffine?(invertedZ?: any): AffinePoint<any>;\n}\n\n// We can't \"abstract out\" coordinates (X, Y, Z; and T in Edwards): argument names of constructor\n// are not accessible. See Typescript gh-56093, gh-41594.\n//\n// We have to use recursive types, so it will return actual point, not constained `CurvePoint`.\n// If, at any point, P is `any`, it will erase all types and replace it\n// with `any`, because of recursion, `any implements CurvePoint`,\n// but we lose all constrains on methods.\n\n/** Base interface for all elliptic curve Points. */\nexport interface CurvePoint<F, P extends CurvePoint<F, P>> extends Group<P> {\n  /** Affine x coordinate. Different from projective / extended X coordinate. */\n  x: F;\n  /** Affine y coordinate. Different from projective / extended Y coordinate. */\n  y: F;\n  Z?: F;\n  double(): P;\n  negate(): P;\n  add(other: P): P;\n  subtract(other: P): P;\n  equals(other: P): boolean;\n  multiply(scalar: bigint): P;\n  assertValidity(): void;\n  clearCofactor(): P;\n  is0(): boolean;\n  isTorsionFree(): boolean;\n  isSmallOrder(): boolean;\n  multiplyUnsafe(scalar: bigint): P;\n  /**\n   * Massively speeds up `p.multiply(n)` by using precompute tables (caching). See {@link wNAF}.\n   * @param isLazy calculate cache now. Default (true) ensures it's deferred to first `multiply()`\n   */\n  precompute(windowSize?: number, isLazy?: boolean): P;\n  /** Converts point to 2D xy affine coordinates */\n  toAffine(invertedZ?: F): AffinePoint<F>;\n  toBytes(): Uint8Array;\n  toHex(): string;\n}\n\n/** Base interface for all elliptic curve Point constructors. */\nexport interface CurvePointCons<P extends CurvePoint<any, P>> {\n  [Symbol.hasInstance]: (item: unknown) => boolean;\n  BASE: P;\n  ZERO: P;\n  /** Field for basic curve math */\n  Fp: IField<P_F<P>>;\n  /** Scalar field, for scalars in multiply and others */\n  Fn: IField<bigint>;\n  /** Creates point from x, y. Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  fromAffine(p: AffinePoint<P_F<P>>): P;\n  fromBytes(bytes: Uint8Array): P;\n  fromHex(hex: Uint8Array | string): P;\n}\n\n// Type inference helpers: PC - PointConstructor, P - Point, Fp - Field element\n// Short names, because we use them a lot in result types:\n// * we can't do 'P = GetCurvePoint<PC>': this is default value and doesn't constrain anything\n// * we can't do 'type X = GetCurvePoint<PC>': it won't be accesible for arguments/return types\n// * `CurvePointCons<P extends CurvePoint<any, P>>` constraints from interface definition\n//   won't propagate, if `PC extends CurvePointCons<any>`: the P would be 'any', which is incorrect\n// * PC could be super specific with super specific P, which implements CurvePoint<any, P>.\n//   this means we need to do stuff like\n//   `function test<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(`\n//   if we want type safety around P, otherwise PC_P<PC> will be any\n\n/** Returns Fp type from Point (P_F<P> == P.F) */\nexport type P_F<P extends CurvePoint<any, P>> = P extends CurvePoint<infer F, P> ? F : never;\n/** Returns Fp type from PointCons (PC_F<PC> == PC.P.F) */\nexport type PC_F<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['Fp']['ZERO'];\n/** Returns Point type from PointCons (PC_P<PC> == PC.P) */\nexport type PC_P<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['ZERO'];\n\n// Ugly hack to get proper type inference, because in typescript fails to infer resursively.\n// The hack allows to do up to 10 chained operations without applying type erasure.\n//\n// Types which won't work:\n// * `CurvePointCons<CurvePoint<any, any>>`, will return `any` after 1 operation\n// * `CurvePointCons<any>: WeierstrassPointCons<bigint> extends CurvePointCons<any> = false`\n// * `P extends CurvePoint, PC extends CurvePointCons<P>`\n//     * It can't infer P from PC alone\n//     * Too many relations between F, P & PC\n//     * It will infer P/F if `arg: CurvePointCons<F, P>`, but will fail if PC is generic\n//     * It will work correctly if there is an additional argument of type P\n//     * But generally, we don't want to parametrize `CurvePointCons` over `F`: it will complicate\n//       types, making them un-inferable\n// prettier-ignore\nexport type PC_ANY = CurvePointCons<\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any, any>\n  >>>>>>>>>\n>;\n\nexport interface CurveLengths {\n  secretKey?: number;\n  publicKey?: number;\n  publicKeyUncompressed?: number;\n  publicKeyHasPrefix?: boolean;\n  signature?: number;\n  seed?: number;\n}\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\n/** @deprecated */\nexport type ExtendedGroupConstructor<T> = GroupConstructor<T> & {\n  Fp: IField<any>;\n  Fn: IField<bigint>;\n  fromAffine(ap: AffinePoint<any>): T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\nexport function negateCt<T extends { negate: () => T }>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[]\n): P[] {\n  const invertedZs = FpInvertBatch(\n    c.Fp,\n    points.map((p) => p.Z!)\n  );\n  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\n/** Internal wNAF opts for specific W and scalarBits */\nexport type WOpts = {\n  windows: number;\n  windowSize: number;\n  mask: bigint;\n  maxNumber: number;\n  shiftBy: bigint;\n};\n\nfunction calcWOpts(W: number, scalarBits: number): WOpts {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n  const maxNumber = 2 ** W; // W=8 256\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\n  const shiftBy = BigInt(W); // W=8 8\n  return { windows, windowSize, mask, maxNumber, shiftBy };\n}\n\nfunction calcOffsets(n: bigint, window: number, wOpts: WOpts) {\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n  let wbits = Number(n & mask); // extract W bits.\n  let nextN = n >> shiftBy; // shift number by W bits.\n\n  // What actually happens here:\n  // const highestBit = Number(mask ^ (mask >> 1n));\n  // let wbits2 = wbits - 1; // skip zero\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n\n  // split if bits > max: +224 => 256-32\n  if (wbits > windowSize) {\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n    nextN += _1n; // +256 (carry)\n  }\n  const offsetStart = window * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n  const isZero = wbits === 0; // is current window slice a 0?\n  const isNeg = wbits < 0; // is current window slice negative?\n  const isNegF = window % 2 !== 0; // fake random statement for noise\n  const offsetF = offsetStart; // fake offset for noise\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>();\n\nfunction getW(P: any): number {\n  // To disable precomputes:\n  // return 1;\n  return pointWindowSizes.get(P) || 1;\n}\n\nfunction assert0(n: bigint): void {\n  if (n !== _0n) throw new Error('invalid wNAF');\n}\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / \uD835\uDC4A) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF<PC extends PC_ANY> {\n  private readonly BASE: PC_P<PC>;\n  private readonly ZERO: PC_P<PC>;\n  private readonly Fn: PC['Fn'];\n  readonly bits: number;\n\n  // Parametrized with a given Point class (not individual point)\n  constructor(Point: PC, bits: number) {\n    this.BASE = Point.BASE;\n    this.ZERO = Point.ZERO;\n    this.Fn = Point.Fn;\n    this.bits = bits;\n  }\n\n  // non-const time multiplication ladder\n  _unsafeLadder(elm: PC_P<PC>, n: bigint, p: PC_P<PC> = this.ZERO): PC_P<PC> {\n    let d: PC_P<PC> = elm;\n    while (n > _0n) {\n      if (n & _1n) p = p.add(d);\n      d = d.double();\n      n >>= _1n;\n    }\n    return p;\n  }\n\n  /**\n   * Creates a wNAF precomputation window. Used for caching.\n   * Default window size is set by `utils.precompute()` and is equal to 8.\n   * Number of precomputed points depends on the curve size:\n   * 2^(\uD835\uDC4A\u22121) * (Math.ceil(\uD835\uDC5B / \uD835\uDC4A) + 1), where:\n   * - \uD835\uDC4A is the window size\n   * - \uD835\uDC5B is the bitlength of the curve order.\n   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n   * @param point Point instance\n   * @param W window size\n   * @returns precomputed point tables flattened to a single array\n   */\n  private precomputeWindow(point: PC_P<PC>, W: number): PC_P<PC>[] {\n    const { windows, windowSize } = calcWOpts(W, this.bits);\n    const points: PC_P<PC>[] = [];\n    let p: PC_P<PC> = point;\n    let base = p;\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n      // i=1, bc we skip 0\n      for (let i = 1; i < windowSize; i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n\n  /**\n   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n   * More compact implementation:\n   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n   * @returns real and fake (for const-time) points\n   */\n  private wNAF(W: number, precomputes: PC_P<PC>[], n: bigint): { p: PC_P<PC>; f: PC_P<PC> } {\n    // Scalar should be smaller than field order\n    if (!this.Fn.isValid(n)) throw new Error('invalid scalar');\n    // Accumulators\n    let p = this.ZERO;\n    let f = this.BASE;\n    // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n    // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n    // there is negate now: it is possible that negated element from low value\n    // would be the same as high element, which will create carry into next window.\n    // It's not obvious how this can fail, but still worth investigating later.\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // bits are 0: add garbage to fake point\n        // Important part for const-time getPublicKey: add random \"noise\" point to f.\n        f = f.add(negateCt(isNegF, precomputes[offsetF]));\n      } else {\n        // bits are 1: add to result point\n        p = p.add(negateCt(isNeg, precomputes[offset]));\n      }\n    }\n    assert0(n);\n    // Return both real and fake points: JIT won't eliminate f.\n    // At this point there is a way to F be infinity-point even if p is not,\n    // which makes it less const-time: around 1 bigint multiply.\n    return { p, f };\n  }\n\n  /**\n   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n   * @param acc accumulator point to add result of multiplication\n   * @returns point\n   */\n  private wNAFUnsafe(\n    W: number,\n    precomputes: PC_P<PC>[],\n    n: bigint,\n    acc: PC_P<PC> = this.ZERO\n  ): PC_P<PC> {\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      if (n === _0n) break; // Early-exit, skip 0 value\n      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // Window bits are 0: skip processing.\n        // Move to next window.\n        continue;\n      } else {\n        const item = precomputes[offset];\n        acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n      }\n    }\n    assert0(n);\n    return acc;\n  }\n\n  private getPrecomputes(W: number, point: PC_P<PC>, transform?: Mapper<PC_P<PC>>): PC_P<PC>[] {\n    // Calculate precomputes on a first run, reuse them after\n    let comp = pointPrecomputes.get(point);\n    if (!comp) {\n      comp = this.precomputeWindow(point, W) as PC_P<PC>[];\n      if (W !== 1) {\n        // Doing transform outside of if brings 15% perf hit\n        if (typeof transform === 'function') comp = transform(comp);\n        pointPrecomputes.set(point, comp);\n      }\n    }\n    return comp;\n  }\n\n  cached(\n    point: PC_P<PC>,\n    scalar: bigint,\n    transform?: Mapper<PC_P<PC>>\n  ): { p: PC_P<PC>; f: PC_P<PC> } {\n    const W = getW(point);\n    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n  }\n\n  unsafe(point: PC_P<PC>, scalar: bigint, transform?: Mapper<PC_P<PC>>, prev?: PC_P<PC>): PC_P<PC> {\n    const W = getW(point);\n    if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n  }\n\n  // We calculate precomputes for elliptic curve point multiplication\n  // using windowed method. This specifies window size and\n  // stores precomputed values. Usually only base point would be precomputed.\n  createCache(P: PC_P<PC>, W: number): void {\n    validateW(W, this.bits);\n    pointWindowSizes.set(P, W);\n    pointPrecomputes.delete(P);\n  }\n\n  hasCache(elm: PC_P<PC>): boolean {\n    return getW(elm) !== 1;\n  }\n}\n\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  Point: PC,\n  point: P,\n  k1: bigint,\n  k2: bigint\n): { p1: P; p2: P } {\n  let acc = point;\n  let p1 = Point.ZERO;\n  let p2 = Point.ZERO;\n  while (k1 > _0n || k2 > _0n) {\n    if (k1 & _1n) p1 = p1.add(acc);\n    if (k2 & _1n) p2 = p2.add(acc);\n    acc = acc.double();\n    k1 >>= _1n;\n    k2 >>= _1n;\n  }\n  return { p1, p2 };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  fieldN: IField<bigint>,\n  points: P[],\n  scalars: bigint[]\n): P {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  const plength = points.length;\n  const slength = scalars.length;\n  if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');\n  // if (plength === 0) throw new Error('array must be of length >= 2');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(plength));\n  let windowSize = 1; // bits\n  if (wbits > 12) windowSize = wbits - 3;\n  else if (wbits > 4) windowSize = wbits - 2;\n  else if (wbits > 0) windowSize = 2;\n  const MASK = bitMask(windowSize);\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < slength; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & MASK);\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as P;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  fieldN: IField<bigint>,\n  points: P[],\n  windowSize: number\n): (scalars: bigint[]) => P {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar \u00D7 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 \u00D7 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 \u00D7 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = bitMask(windowSize);\n  const tables = points.map((p: P) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): P => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\n// TODO: remove\n/**\n * Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n * Though generator can be different (Fp2 / Fp6 for BLS).\n */\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\n// TODO: remove\n/** @deprecated */\nexport function validateBasic<FP, T>(\n  curve: BasicCurve<FP> & T\n): Readonly<\n  {\n    readonly nBitLength: number;\n    readonly nByteLength: number;\n  } & BasicCurve<FP> &\n    T & {\n      p: bigint;\n    }\n> {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n\nexport type ValidCurveParams<T> = {\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b?: T;\n  d?: T;\n  Gx: T;\n  Gy: T;\n};\n\nfunction createField<T>(order: bigint, field?: IField<T>, isLE?: boolean): IField<T> {\n  if (field) {\n    if (field.ORDER !== order) throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n    validateField(field);\n    return field;\n  } else {\n    return Field(order, { isLE }) as unknown as IField<T>;\n  }\n}\nexport type FpFn<T> = { Fp: IField<T>; Fn: IField<bigint> };\n\n/** Validates CURVE opts and creates fields */\nexport function _createCurveFields<T>(\n  type: 'weierstrass' | 'edwards',\n  CURVE: ValidCurveParams<T>,\n  curveOpts: Partial<FpFn<T>> = {},\n  FpFnLE?: boolean\n): FpFn<T> & { CURVE: ValidCurveParams<T> } {\n  if (FpFnLE === undefined) FpFnLE = type === 'edwards';\n  if (!CURVE || typeof CURVE !== 'object') throw new Error(`expected valid ${type} CURVE object`);\n  for (const p of ['p', 'n', 'h'] as const) {\n    const val = CURVE[p];\n    if (!(typeof val === 'bigint' && val > _0n))\n      throw new Error(`CURVE.${p} must be positive bigint`);\n  }\n  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n  const _b: 'b' | 'd' = type === 'weierstrass' ? 'b' : 'd';\n  const params = ['Gx', 'Gy', 'a', _b] as const;\n  for (const p of params) {\n    // @ts-ignore\n    if (!Fp.isValid(CURVE[p]))\n      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n  }\n  CURVE = Object.freeze(Object.assign({}, CURVE));\n  return { CURVE, Fp, Fn };\n}\n", "/**\n * Short Weierstrass curve methods. The formula is: y\u00B2 = x\u00B3 + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac as nobleHmac } from '@noble/hashes/hmac.js';\nimport { ahash } from '@noble/hashes/utils';\nimport {\n  _validateObject,\n  _abool2 as abool,\n  _abytes2 as abytes,\n  aInRange,\n  bitLen,\n  bitMask,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes,\n  createHmacDrbg,\n  ensureBytes,\n  hexToBytes,\n  inRange,\n  isBytes,\n  memoized,\n  numberToHexUnpadded,\n  randomBytes as randomBytesWeb,\n  type CHash,\n  type Hex,\n  type PrivKey,\n} from '../utils.ts';\nimport {\n  _createCurveFields,\n  mulEndoUnsafe,\n  negateCt,\n  normalizeZ,\n  pippenger,\n  wNAF,\n  type AffinePoint,\n  type BasicCurve,\n  type CurveLengths,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport {\n  Field,\n  FpInvertBatch,\n  getMinHashLength,\n  mapHashToField,\n  nLength,\n  validateField,\n  type IField,\n  type NLength,\n} from './modular.ts';\n\nexport type { AffinePoint };\nexport type HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\n\ntype EndoBasis = [[bigint, bigint], [bigint, bigint]];\n/**\n * When Weierstrass curve has `a=0`, it becomes Koblitz curve.\n * Koblitz curves allow using **efficiently-computable GLV endomorphism \u03C8**.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n *\n * Endomorphism consists of beta, lambda and splitScalar:\n *\n * 1. GLV endomorphism \u03C8 transforms a point: `P = (x, y) \u21A6 \u03C8(P) = (\u03B2\u00B7x mod p, y)`\n * 2. GLV scalar decomposition transforms a scalar: `k \u2261 k\u2081 + k\u2082\u00B7\u03BB (mod n)`\n * 3. Then these are combined: `k\u00B7P = k\u2081\u00B7P + k\u2082\u00B7\u03C8(P)`\n * 4. Two 128-bit point-by-scalar multiplications + one point addition is faster than\n *    one 256-bit multiplication.\n *\n * where\n * * beta: \u03B2 \u2208 F\u209A with \u03B2\u00B3 = 1, \u03B2 \u2260 1\n * * lambda: \u03BB \u2208 F\u2099 with \u03BB\u00B3 = 1, \u03BB \u2260 1\n * * splitScalar decomposes k \u21A6 k\u2081, k\u2082, by using reduced basis vectors.\n *   Gauss lattice reduction calculates them from initial basis vectors `(n, 0), (-\u03BB, 0)`\n *\n * Check out `test/misc/endomorphism.js` and\n * [gist](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n */\nexport type EndomorphismOpts = {\n  beta: bigint;\n  basises?: EndoBasis;\n  splitScalar?: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\n\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num: bigint, den: bigint) => (num + (num >= 0 ? den : -den) / _2n) / den;\n\nexport type ScalarEndoParts = { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n\n/**\n * Splits scalar for GLV endomorphism.\n */\nexport function _splitEndoScalar(k: bigint, basis: EndoBasis, n: bigint): ScalarEndoParts {\n  // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n  // Since part can be negative, we need to do this on point.\n  // TODO: verifyScalar function which consumes lambda\n  const [[a1, b1], [a2, b2]] = basis;\n  const c1 = divNearest(b2 * k, n);\n  const c2 = divNearest(-b1 * k, n);\n  // |k1|/|k2| is < sqrt(N), but can be negative.\n  // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n  let k1 = k - c1 * a1 - c2 * a2;\n  let k2 = -c1 * b1 - c2 * b2;\n  const k1neg = k1 < _0n;\n  const k2neg = k2 < _0n;\n  if (k1neg) k1 = -k1;\n  if (k2neg) k2 = -k2;\n  // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n  // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n  const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n  if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n    throw new Error('splitScalar (endomorphism): failed, k=' + k);\n  }\n  return { k1neg, k1, k2neg, k2 };\n}\n\nexport type ECDSASigFormat = 'compact' | 'recovered' | 'der';\nexport type ECDSARecoverOpts = {\n  prehash?: boolean;\n};\nexport type ECDSAVerifyOpts = {\n  prehash?: boolean;\n  lowS?: boolean;\n  format?: ECDSASigFormat;\n};\nexport type ECDSASignOpts = {\n  prehash?: boolean;\n  lowS?: boolean;\n  format?: ECDSASigFormat;\n  extraEntropy?: Uint8Array | boolean;\n};\n\nfunction validateSigFormat(format: string): ECDSASigFormat {\n  if (!['compact', 'recovered', 'der'].includes(format))\n    throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n  return format as ECDSASigFormat;\n}\n\nfunction validateSigOpts<T extends ECDSASignOpts, D extends Required<ECDSASignOpts>>(\n  opts: T,\n  def: D\n): Required<ECDSASignOpts> {\n  const optsn: ECDSASignOpts = {};\n  for (let optName of Object.keys(def)) {\n    // @ts-ignore\n    optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n  }\n  abool(optsn.lowS!, 'lowS');\n  abool(optsn.prehash!, 'prehash');\n  if (optsn.format !== undefined) validateSigFormat(optsn.format);\n  return optsn as Required<ECDSASignOpts>;\n}\n\n/** Instance methods for 3D XYZ projective points. */\nexport interface WeierstrassPoint<T> extends CurvePoint<T, WeierstrassPoint<T>> {\n  /** projective X coordinate. Different from affine x. */\n  readonly X: T;\n  /** projective Y coordinate. Different from affine y. */\n  readonly Y: T;\n  /** projective z coordinate */\n  readonly Z: T;\n  /** affine x coordinate. Different from projective X. */\n  get x(): T;\n  /** affine y coordinate. Different from projective Y. */\n  get y(): T;\n  /** Encodes point using IEEE P1363 (DER) encoding. First byte is 2/3/4. Default = isCompressed. */\n  toBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  /** @deprecated use `.X` */\n  readonly px: T;\n  /** @deprecated use `.Y` */\n  readonly py: T;\n  /** @deprecated use `.Z` */\n  readonly pz: T;\n  /** @deprecated use `toBytes` */\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  /** @deprecated use `multiplyUnsafe` */\n  multiplyAndAddUnsafe(\n    Q: WeierstrassPoint<T>,\n    a: bigint,\n    b: bigint\n  ): WeierstrassPoint<T> | undefined;\n  /** @deprecated use `p.y % 2n === 0n` */\n  hasEvenY(): boolean;\n  /** @deprecated use `p.precompute(windowSize)` */\n  _setWindowSize(windowSize: number): void;\n}\n\n/** Static methods for 3D XYZ projective points. */\nexport interface WeierstrassPointCons<T> extends CurvePointCons<WeierstrassPoint<T>> {\n  /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  new (X: T, Y: T, Z: T): WeierstrassPoint<T>;\n  CURVE(): WeierstrassOpts<T>;\n  /** @deprecated use `Point.BASE.multiply(Point.Fn.fromBytes(privateKey))` */\n  fromPrivateKey(privateKey: PrivKey): WeierstrassPoint<T>;\n  /** @deprecated use `import { normalizeZ } from '@noble/curves/abstract/curve.js';` */\n  normalizeZ(points: WeierstrassPoint<T>[]): WeierstrassPoint<T>[];\n  /** @deprecated use `import { pippenger } from '@noble/curves/abstract/curve.js';` */\n  msm(points: WeierstrassPoint<T>[], scalars: bigint[]): WeierstrassPoint<T>;\n}\n\n/**\n * Weierstrass curve options.\n *\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor, usually 1. h*n is group order; n is subgroup order\n * * a: formula param, must be in field of p\n * * b: formula param, must be in field of p\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type WeierstrassOpts<T> = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b: T;\n  Gx: T;\n  Gy: T;\n}>;\n\n// When a cofactor != 1, there can be an effective methods to:\n// 1. Determine whether a point is torsion-free\n// 2. Clear torsion component\n// wrapPrivateKey: bls12-381 requires mod(n) instead of rejecting keys >= n\nexport type WeierstrassExtraOpts<T> = Partial<{\n  Fp: IField<T>;\n  Fn: IField<bigint>;\n  allowInfinityPoint: boolean;\n  endo: EndomorphismOpts;\n  isTorsionFree: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => boolean;\n  clearCofactor: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => WeierstrassPoint<T>;\n  fromBytes: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes: (\n    c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ) => Uint8Array;\n}>;\n\n/**\n * Options for ECDSA signatures over a Weierstrass curve.\n *\n * * lowS: (default: true) whether produced / verified signatures occupy low half of ecdsaOpts.p. Prevents malleability.\n * * hmac: (default: noble-hashes hmac) function, would be used to init hmac-drbg for k generation.\n * * randomBytes: (default: webcrypto os-level CSPRNG) custom method for fetching secure randomness.\n * * bits2int, bits2int_modN: used in sigs, sometimes overridden by curves\n */\nexport type ECDSAOpts = Partial<{\n  lowS: boolean;\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  bits2int: (bytes: Uint8Array) => bigint;\n  bits2int_modN: (bytes: Uint8Array) => bigint;\n}>;\n\n/**\n * Elliptic Curve Diffie-Hellman interface.\n * Provides keygen, secret-to-public conversion, calculating shared secrets.\n */\nexport interface ECDH {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (secretKeyA: PrivKey, publicKeyB: Hex, isCompressed?: boolean) => Uint8Array;\n  Point: WeierstrassPointCons<bigint>;\n  utils: {\n    isValidSecretKey: (secretKey: PrivKey) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, isCompressed?: boolean) => boolean;\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `isValidSecretKey` */\n    isValidPrivateKey: (secretKey: PrivKey) => boolean;\n    /** @deprecated use `Point.Fn.fromBytes()` */\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    /** @deprecated use `point.precompute()` */\n    precompute: (windowSize?: number, point?: WeierstrassPoint<bigint>) => WeierstrassPoint<bigint>;\n  };\n  lengths: CurveLengths;\n}\n\n/**\n * ECDSA interface.\n * Only supported for prime fields, not Fp2 (extension fields).\n */\nexport interface ECDSA extends ECDH {\n  sign: (message: Hex, secretKey: PrivKey, opts?: ECDSASignOpts) => ECDSASigRecovered;\n  verify: (\n    signature: Uint8Array,\n    message: Uint8Array,\n    publicKey: Uint8Array,\n    opts?: ECDSAVerifyOpts\n  ) => boolean;\n  recoverPublicKey(signature: Uint8Array, message: Uint8Array, opts?: ECDSARecoverOpts): Uint8Array;\n  Signature: ECDSASignatureCons;\n}\nexport class DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\nexport type IDER = {\n  // asn.1 DER encoding utils\n  Err: typeof DERErr;\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string) => string;\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array };\n  };\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string;\n    decode(data: Uint8Array): bigint;\n  };\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint };\n  hexFromSig(sig: { r: bigint; s: bigint }): string;\n};\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER: IDER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string): string => {\n      const { Err: E } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = numberToHexUnpadded(dataLen);\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n      const t = numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\n      const { Err: E } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;\n      else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 0b0111_1111;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = (length << 8) | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return { v, l: data.subarray(pos + length) };\n    },\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string {\n      const { Err: E } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data: Uint8Array): bigint {\n      const { Err: E } = DER;\n      if (data[0] & 0b1000_0000) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n        throw new E('invalid signature integer: unnecessary leading zero');\n      return bytesToNumberBE(data);\n    },\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E, _int: int, _tlv: tlv } = DER;\n    const data = ensureBytes('signature', hex);\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    const { _tlv: tlv, _int: int } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function _normFnElement(Fn: IField<bigint>, key: PrivKey): bigint {\n  const { BYTES: expected } = Fn;\n  let num: bigint;\n  if (typeof key === 'bigint') {\n    num = key;\n  } else {\n    let bytes = ensureBytes('private key', key);\n    try {\n      num = Fn.fromBytes(bytes);\n    } catch (error) {\n      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n    }\n  }\n  if (!Fn.isValidNot0(num)) throw new Error('invalid private key: out of range [1..N-1]');\n  return num;\n}\n\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */\nexport function weierstrassN<T>(\n  params: WeierstrassOpts<T>,\n  extraOpts: WeierstrassExtraOpts<T> = {}\n): WeierstrassPointCons<T> {\n  const validated = _createCurveFields('weierstrass', params, extraOpts);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE as WeierstrassOpts<T>;\n  const { h: cofactor, n: CURVE_ORDER } = CURVE;\n  _validateObject(\n    extraOpts,\n    {},\n    {\n      allowInfinityPoint: 'boolean',\n      clearCofactor: 'function',\n      isTorsionFree: 'function',\n      fromBytes: 'function',\n      toBytes: 'function',\n      endo: 'object',\n      wrapPrivateKey: 'boolean',\n    }\n  );\n\n  const { endo } = extraOpts;\n  if (endo) {\n    // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n    if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n      throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n    }\n  }\n\n  const lengths = getWLengths(Fp, Fn);\n\n  function assertCompressionIsSupported() {\n    if (!Fp.isOdd) throw new Error('compression is not supported: Field does not have .isOdd()');\n  }\n\n  // Implements IEEE P1363 point encoding\n  function pointToBytes(\n    _c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ): Uint8Array {\n    const { x, y } = point.toAffine();\n    const bx = Fp.toBytes(x);\n    abool(isCompressed, 'isCompressed');\n    if (isCompressed) {\n      assertCompressionIsSupported();\n      const hasEvenY = !Fp.isOdd!(y);\n      return concatBytes(pprefix(hasEvenY), bx);\n    } else {\n      return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n    }\n  }\n  function pointFromBytes(bytes: Uint8Array) {\n    abytes(bytes, undefined, 'Point');\n    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n    const length = bytes.length;\n    const head = bytes[0];\n    const tail = bytes.subarray(1);\n    // No actual validation is done here: use .assertValidity()\n    if (length === comp && (head === 0x02 || head === 0x03)) {\n      const x = Fp.fromBytes(tail);\n      if (!Fp.isValid(x)) throw new Error('bad point: is not on curve, wrong x');\n      const y2 = weierstrassEquation(x); // y\u00B2 = x\u00B3 + ax + b\n      let y: T;\n      try {\n        y = Fp.sqrt(y2); // y = y\u00B2 ^ (p+1)/4\n      } catch (sqrtError) {\n        const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n        throw new Error('bad point: is not on curve, sqrt error' + err);\n      }\n      assertCompressionIsSupported();\n      const isYOdd = Fp.isOdd!(y); // (y & _1n) === _1n;\n      const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n      if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n      return { x, y };\n    } else if (length === uncomp && head === 0x04) {\n      // TODO: more checks\n      const L = Fp.BYTES;\n      const x = Fp.fromBytes(tail.subarray(0, L));\n      const y = Fp.fromBytes(tail.subarray(L, L * 2));\n      if (!isValidXY(x, y)) throw new Error('bad point: is not on curve');\n      return { x, y };\n    } else {\n      throw new Error(\n        `bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`\n      );\n    }\n  }\n\n  const encodePoint = extraOpts.toBytes || pointToBytes;\n  const decodePoint = extraOpts.fromBytes || pointFromBytes;\n  function weierstrassEquation(x: T): T {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x\u00B2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x\u00B3 + a * x + b\n  }\n\n  // TODO: move top-level\n  /** Checks whether equation holds for given x, y: y\u00B2 == x\u00B3 + ax + b */\n  function isValidXY(x: T, y: T): boolean {\n    const left = Fp.sqr(y); // y\u00B2\n    const right = weierstrassEquation(x); // x\u00B3 + ax + b\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // Test 1: equation y\u00B2 = x\u00B3 + ax + b should work for generator point.\n  if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // Test 2: discriminant \u0394 part should be non-zero: 4a\u00B3 + 27b\u00B2 != 0.\n  // Guarantees curve is genus-1, smooth (non-singular).\n  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n  if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');\n\n  /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n  function acoord(title: string, n: T, banZero = false) {\n    if (!Fp.isValid(n) || (banZero && Fp.is0(n))) throw new Error(`bad point coordinate ${title}`);\n    return n;\n  }\n\n  function aprjpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n\n  function splitEndoScalarN(k: bigint) {\n    if (!endo || !endo.basises) throw new Error('no endo');\n    return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n  }\n\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (X, Y, Z) \u220B (x=X/Z, y=Y/Z)\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\n    const { X, Y, Z } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(Z, Fp.ONE)) return { x: X, y: Y };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);\n    const x = Fp.mul(X, iz);\n    const y = Fp.mul(Y, iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized((p: Point) => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const { x, y } = p.toAffine();\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not field elements');\n    if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n\n  function finishEndo(\n    endoBeta: EndomorphismOpts['beta'],\n    k1p: Point,\n    k2p: Point,\n    k1neg: boolean,\n    k2neg: boolean\n  ) {\n    k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n    k1p = negateCt(k1neg, k1p);\n    k2p = negateCt(k2neg, k2p);\n    return k1p.add(k2p);\n  }\n\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) \u220B (x=X/Z, y=Y/Z).\n   * Default Point works in 2d / affine coordinates: (x, y).\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements WeierstrassPoint<T> {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    static readonly Fp = Fp;\n    // scalar field\n    static readonly Fn = Fn;\n\n    readonly X: T;\n    readonly Y: T;\n    readonly Z: T;\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    constructor(X: T, Y: T, Z: T) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y, true);\n      this.Z = acoord('z', Z);\n      Object.freeze(this);\n    }\n\n    static CURVE(): WeierstrassOpts<T> {\n      return CURVE;\n    }\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n      if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    static fromBytes(bytes: Uint8Array): Point {\n      const P = Point.fromAffine(decodePoint(abytes(bytes, undefined, 'point')));\n      P.assertValidity();\n      return P;\n    }\n    static fromHex(hex: Hex): Point {\n      return Point.fromBytes(ensureBytes('pointHex', hex));\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     *\n     * @param windowSize\n     * @param isLazy true will defer table computation until the first multiplication\n     * @returns\n     */\n    precompute(windowSize: number = 8, isLazy = true): Point {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_3n); // random number\n      return this;\n    }\n\n    // TODO: return `this`\n    /** A point on curve is valid if it conforms to equation. */\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n      return !Fp.isOdd(y);\n    }\n\n    /** Compare one point to another. */\n    equals(other: Point): boolean {\n      aprjpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n    negate(): Point {\n      return new Point(this.X, Fp.neg(this.Y), this.Z);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      aprjpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      const { endo } = extraOpts;\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: out of range'); // 0 is invalid\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const mul = (n: bigint) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n      /** See docs for {@link EndomorphismOpts} */\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n        const { p: k1p, f: k1f } = mul(k1);\n        const { p: k2p, f: k2f } = mul(k2);\n        fake = k1f.add(k2f);\n        point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n      } else {\n        const { p, f } = mul(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return normalizeZ(Point, [point, fake])[0];\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed secret key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc: bigint): Point {\n      const { endo } = extraOpts;\n      const p = this as Point;\n      if (!Fn.isValid(sc)) throw new Error('invalid scalar: out of range'); // 0 is valid\n      if (sc === _0n || p.is0()) return Point.ZERO;\n      if (sc === _1n) return p; // fast-path\n      if (wnaf.hasCache(this)) return this.multiply(sc);\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n        const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n        return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n      } else {\n        return wnaf.unsafe(p, sc);\n      }\n    }\n\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    /**\n     * Converts Projective point to affine (x, y) coordinates.\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n     */\n    toAffine(invertedZ?: T): AffinePoint<T> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    /**\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\n     * Always torsion-free for cofactor=1 curves.\n     */\n    isTorsionFree(): boolean {\n      const { isTorsionFree } = extraOpts;\n      if (cofactor === _1n) return true;\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      return wnaf.unsafe(this, CURVE_ORDER).is0();\n    }\n\n    clearCofactor(): Point {\n      const { clearCofactor } = extraOpts;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    isSmallOrder(): boolean {\n      // can we use this.clearCofactor()?\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    toBytes(isCompressed = true): Uint8Array {\n      abool(isCompressed, 'isCompressed');\n      this.assertValidity();\n      return encodePoint(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return bytesToHex(this.toBytes(isCompressed));\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n\n    // TODO: remove\n    get px(): T {\n      return this.X;\n    }\n    get py(): T {\n      return this.X;\n    }\n    get pz(): T {\n      return this.Z;\n    }\n    toRawBytes(isCompressed = true): Uint8Array {\n      return this.toBytes(isCompressed);\n    }\n    _setWindowSize(windowSize: number) {\n      this.precompute(windowSize);\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      return normalizeZ(Point, points);\n    }\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n    }\n  }\n  const bits = Fn.BITS;\n  const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n\n/** Methods of ECDSA signature instance. */\nexport interface ECDSASignature {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  addRecoveryBit(recovery: number): ECDSASigRecovered;\n  hasHighS(): boolean;\n  toBytes(format?: string): Uint8Array;\n  toHex(format?: string): string;\n\n  /** @deprecated */\n  assertValidity(): void;\n  /** @deprecated */\n  normalizeS(): ECDSASignature;\n  /** @deprecated use standalone method `curve.recoverPublicKey(sig.toBytes('recovered'), msg)` */\n  recoverPublicKey(msgHash: Hex): WeierstrassPoint<bigint>;\n  /** @deprecated use `.toBytes('compact')` */\n  toCompactRawBytes(): Uint8Array;\n  /** @deprecated use `.toBytes('compact')` */\n  toCompactHex(): string;\n  /** @deprecated use `.toBytes('der')` */\n  toDERRawBytes(): Uint8Array;\n  /** @deprecated use `.toBytes('der')` */\n  toDERHex(): string;\n}\nexport type ECDSASigRecovered = ECDSASignature & {\n  readonly recovery: number;\n};\n/** Methods of ECDSA signature constructor. */\nexport type ECDSASignatureCons = {\n  new (r: bigint, s: bigint, recovery?: number): ECDSASignature;\n  fromBytes(bytes: Uint8Array, format?: ECDSASigFormat): ECDSASignature;\n  fromHex(hex: string, format?: ECDSASigFormat): ECDSASignature;\n\n  /** @deprecated use `.fromBytes(bytes, 'compact')` */\n  fromCompact(hex: Hex): ECDSASignature;\n  /** @deprecated use `.fromBytes(bytes, 'der')` */\n  fromDER(hex: Hex): ECDSASignature;\n};\n\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY: boolean): Uint8Array {\n  return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(\n  Fp: IField<T>,\n  Z: T\n): (u: T, v: T) => { isValid: boolean; value: T } {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n): (u: T) => { x: T; y: T } {\n  validateField(Fp);\n  const { A, B, Z } = opts;\n  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n  if (!Fp.isOdd) throw new Error('Field does not have .isOdd()');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n\nfunction getWLengths<T>(Fp: IField<T>, Fn: IField<bigint>) {\n  return {\n    secretKey: Fn.BYTES,\n    publicKey: 1 + Fp.BYTES,\n    publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n    publicKeyHasPrefix: true,\n    signature: 2 * Fn.BYTES,\n  };\n}\n\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nexport function ecdh(\n  Point: WeierstrassPointCons<bigint>,\n  ecdhOpts: { randomBytes?: (bytesLength?: number) => Uint8Array } = {}\n): ECDH {\n  const { Fn } = Point;\n  const randomBytes_ = ecdhOpts.randomBytes || randomBytesWeb;\n  const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n\n  function isValidSecretKey(secretKey: PrivKey) {\n    try {\n      return !!_normFnElement(Fn, secretKey);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  function isValidPublicKey(publicKey: Uint8Array, isCompressed?: boolean): boolean {\n    const { publicKey: comp, publicKeyUncompressed } = lengths;\n    try {\n      const l = publicKey.length;\n      if (isCompressed === true && l !== comp) return false;\n      if (isCompressed === false && l !== publicKeyUncompressed) return false;\n      return !!Point.fromBytes(publicKey);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Produces cryptographically secure secret key from random of size\n   * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n   */\n  function randomSecretKey(seed = randomBytes_(lengths.seed)): Uint8Array {\n    return mapHashToField(abytes(seed, lengths.seed, 'seed'), Fn.ORDER);\n  }\n\n  /**\n   * Computes public key for a secret key. Checks for validity of the secret key.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(secretKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n  }\n\n  function keygen(seed?: Uint8Array) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean | undefined {\n    if (typeof item === 'bigint') return false;\n    if (item instanceof Point) return true;\n    const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n    if (Fn.allowedLengths || secretKey === publicKey) return undefined;\n    const l = ensureBytes('key', item).length;\n    return l === publicKey || l === publicKeyUncompressed;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from secret key A and public key B.\n   * Checks: 1) secret key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(secretKeyA: PrivKey, publicKeyB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(secretKeyA) === true) throw new Error('first arg must be private key');\n    if (isProbPub(publicKeyB) === false) throw new Error('second arg must be public key');\n    const s = _normFnElement(Fn, secretKeyA);\n    const b = Point.fromHex(publicKeyB); // checks for being on-curve\n    return b.multiply(s).toBytes(isCompressed);\n  }\n\n  const utils = {\n    isValidSecretKey,\n    isValidPublicKey,\n    randomSecretKey,\n\n    // TODO: remove\n    isValidPrivateKey: isValidSecretKey,\n    randomPrivateKey: randomSecretKey,\n    normPrivateKeyToScalar: (key: PrivKey) => _normFnElement(Fn, key),\n    precompute(windowSize = 8, point = Point.BASE): WeierstrassPoint<bigint> {\n      return point.precompute(windowSize, false);\n    },\n  };\n\n  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nexport function ecdsa(\n  Point: WeierstrassPointCons<bigint>,\n  hash: CHash,\n  ecdsaOpts: ECDSAOpts = {}\n): ECDSA {\n  ahash(hash);\n  _validateObject(\n    ecdsaOpts,\n    {},\n    {\n      hmac: 'function',\n      lowS: 'boolean',\n      randomBytes: 'function',\n      bits2int: 'function',\n      bits2int_modN: 'function',\n    }\n  );\n\n  const randomBytes = ecdsaOpts.randomBytes || randomBytesWeb;\n  const hmac: HmacFnSync =\n    ecdsaOpts.hmac ||\n    (((key, ...msgs) => nobleHmac(hash, key, concatBytes(...msgs))) satisfies HmacFnSync);\n\n  const { Fp, Fn } = Point;\n  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n  const defaultSigOpts: Required<ECDSASignOpts> = {\n    prehash: false,\n    lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,\n    format: undefined as any, //'compact' as ECDSASigFormat,\n    extraEntropy: false,\n  };\n  const defaultSigOpts_format = 'compact';\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n  function validateRS(title: string, num: bigint): bigint {\n    if (!Fn.isValidNot0(num))\n      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n    return num;\n  }\n  function validateSigLength(bytes: Uint8Array, format: ECDSASigFormat) {\n    validateSigFormat(format);\n    const size = lengths.signature!;\n    const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n    return abytes(bytes, sizer, `${format} signature`);\n  }\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n   */\n  class Signature implements ECDSASignature {\n    readonly r: bigint;\n    readonly s: bigint;\n    readonly recovery?: number;\n    constructor(r: bigint, s: bigint, recovery?: number) {\n      this.r = validateRS('r', r); // r in [1..N-1];\n      this.s = validateRS('s', s); // s in [1..N-1];\n      if (recovery != null) this.recovery = recovery;\n      Object.freeze(this);\n    }\n\n    static fromBytes(bytes: Uint8Array, format: ECDSASigFormat = defaultSigOpts_format): Signature {\n      validateSigLength(bytes, format);\n      let recid: number | undefined;\n      if (format === 'der') {\n        const { r, s } = DER.toSig(abytes(bytes));\n        return new Signature(r, s);\n      }\n      if (format === 'recovered') {\n        recid = bytes[0];\n        format = 'compact';\n        bytes = bytes.subarray(1);\n      }\n      const L = Fn.BYTES;\n      const r = bytes.subarray(0, L);\n      const s = bytes.subarray(L, L * 2);\n      return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n    }\n\n    static fromHex(hex: string, format?: ECDSASigFormat) {\n      return this.fromBytes(hexToBytes(hex), format);\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(messageHash: Hex): WeierstrassPoint<bigint> {\n      const FIELD_ORDER = Fp.ORDER;\n      const { r, s, recovery: rec } = this;\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n\n      // ECDSA recovery is hard for cofactor > 1 curves.\n      // In sign, `r = q.x mod n`, and here we recover q.x from r.\n      // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n      // However, for cofactor>1, r+n may not get q.x:\n      // r+n*i would need to be done instead where i is unknown.\n      // To easily get i, we either need to:\n      // a. increase amount of valid recid values (4, 5...); OR\n      // b. prohibit non-prime-order signatures (recid > 1).\n      const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n      if (hasCofactor && rec > 1) throw new Error('recovery id is ambiguous for h>1 curve');\n\n      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n      if (!Fp.isValid(radj)) throw new Error('recovery id 2 or 3 invalid');\n      const x = Fp.toBytes(radj);\n      const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));\n      const ir = Fn.inv(radj); // r^-1\n      const h = bits2int_modN(ensureBytes('msgHash', messageHash)); // Truncate hash\n      const u1 = Fn.create(-h * ir); // -hr^-1\n      const u2 = Fn.create(s * ir); // sr^-1\n      // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n      if (Q.is0()) throw new Error('point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    toBytes(format: ECDSASigFormat = defaultSigOpts_format) {\n      validateSigFormat(format);\n      if (format === 'der') return hexToBytes(DER.hexFromSig(this));\n      const r = Fn.toBytes(this.r);\n      const s = Fn.toBytes(this.s);\n      if (format === 'recovered') {\n        if (this.recovery == null) throw new Error('recovery bit must be present');\n        return concatBytes(Uint8Array.of(this.recovery), r, s);\n      }\n      return concatBytes(r, s);\n    }\n\n    toHex(format?: ECDSASigFormat) {\n      return bytesToHex(this.toBytes(format));\n    }\n\n    // TODO: remove\n    assertValidity(): void {}\n    static fromCompact(hex: Hex) {\n      return Signature.fromBytes(ensureBytes('sig', hex), 'compact');\n    }\n    static fromDER(hex: Hex) {\n      return Signature.fromBytes(ensureBytes('sig', hex), 'der');\n    }\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n    }\n    toDERRawBytes() {\n      return this.toBytes('der');\n    }\n    toDERHex() {\n      return bytesToHex(this.toBytes('der'));\n    }\n    toCompactRawBytes() {\n      return this.toBytes('compact');\n    }\n    toCompactHex() {\n      return bytesToHex(this.toBytes('compact'));\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    ecdsaOpts.bits2int ||\n    function bits2int_def(bytes: Uint8Array): bigint {\n      // Our custom check \"just in case\", for protection against DoS\n      if (bytes.length > 8192) throw new Error('input is too large');\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    ecdsaOpts.bits2int_modN ||\n    function bits2int_modN_def(bytes: Uint8Array): bigint {\n      return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // Pads output with zero as per spec\n  const ORDER_MASK = bitMask(fnBits);\n  /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n  function int2octets(num: bigint): Uint8Array {\n    // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n    aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n    return Fn.toBytes(num);\n  }\n\n  function validateMsgAndHash(message: Uint8Array, prehash: boolean) {\n    abytes(message, undefined, 'message');\n    return prehash ? abytes(hash(message), undefined, 'prehashed message') : message;\n  }\n\n  /**\n   * Steps A, D of RFC6979 3.2.\n   * Creates RFC6979 seed; converts msg/privKey to numbers.\n   * Used only in sign, not in verify.\n   *\n   * Warning: we cannot assume here that message has same amount of bytes as curve order,\n   * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n   */\n  function prepSig(message: Uint8Array, privateKey: PrivKey, opts: ECDSASignOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(message);\n    const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (extraEntropy != null && extraEntropy !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      // gen random bytes OR pass as-is\n      const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    // To transform k => Signature:\n    // q = k\u22C5G\n    // r = q.x mod n\n    // s = k^-1(m + rd) mod n\n    // Can use scalar blinding b^-1(bm + bdr) where b \u2208 [1,q\u22121] according to\n    // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n    // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      // Important: all mod() calls here must be done over N\n      const k = bits2int(kBytes); // mod n, not mod p\n      if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n      const ik = Fn.inv(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = k\u22C5G\n      const r = Fn.create(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = Fn.neg(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n\n  /**\n   * Signs message hash with a secret key.\n   *\n   * ```\n   * sign(m, d) where\n   *   k = rfc6979_hmac_drbg(m, d)\n   *   (x, y) = G \u00D7 k\n   *   r = x mod n\n   *   s = (m + dr) / k mod n\n   * ```\n   */\n  function sign(message: Hex, secretKey: PrivKey, opts: ECDSASignOpts = {}): RecoveredSignature {\n    message = ensureBytes('message', message);\n    const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n    const drbg = createHmacDrbg<RecoveredSignature>(hash.outputLen, Fn.BYTES, hmac);\n    const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    return sig;\n  }\n\n  function tryParsingSig(sg: Hex | SignatureLike) {\n    // Try to deduce format\n    let sig: Signature | undefined = undefined;\n    const isHex = typeof sg === 'string' || isBytes(sg);\n    const isObj =\n      !isHex &&\n      sg !== null &&\n      typeof sg === 'object' &&\n      typeof sg.r === 'bigint' &&\n      typeof sg.s === 'bigint';\n    if (!isHex && !isObj)\n      throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n    if (isObj) {\n      sig = new Signature(sg.r, sg.s);\n    } else if (isHex) {\n      try {\n        sig = Signature.fromBytes(ensureBytes('sig', sg), 'der');\n      } catch (derError) {\n        if (!(derError instanceof DER.Err)) throw derError;\n      }\n      if (!sig) {\n        try {\n          sig = Signature.fromBytes(ensureBytes('sig', sg), 'compact');\n        } catch (error) {\n          return false;\n        }\n      }\n    }\n    if (!sig) return false;\n    return sig;\n  }\n\n  /**\n   * Verifies a signature against message and public key.\n   * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n   * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   u1 = hs^-1 mod n\n   *   u2 = rs^-1 mod n\n   *   R = u1\u22C5G + u2\u22C5P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    message: Hex,\n    publicKey: Hex,\n    opts: ECDSAVerifyOpts = {}\n  ): boolean {\n    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n    publicKey = ensureBytes('publicKey', publicKey);\n    message = validateMsgAndHash(ensureBytes('message', message), prehash);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const sig =\n      format === undefined\n        ? tryParsingSig(signature)\n        : Signature.fromBytes(ensureBytes('sig', signature as Hex), format);\n    if (sig === false) return false;\n    try {\n      const P = Point.fromBytes(publicKey);\n      if (lowS && sig.hasHighS()) return false;\n      const { r, s } = sig;\n      const h = bits2int_modN(message); // mod n, not mod p\n      const is = Fn.inv(s); // s^-1 mod n\n      const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n      const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1\u22C5G + u2\u22C5P\n      if (R.is0()) return false;\n      const v = Fn.create(R.x); // v = r.x mod n\n      return v === r;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function recoverPublicKey(\n    signature: Uint8Array,\n    message: Uint8Array,\n    opts: ECDSARecoverOpts = {}\n  ): Uint8Array {\n    const { prehash } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash);\n    return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n  }\n\n  return Object.freeze({\n    keygen,\n    getPublicKey,\n    getSharedSecret,\n    utils,\n    lengths,\n    Point,\n    sign,\n    verify,\n    recoverPublicKey,\n    Signature,\n    hash,\n  });\n}\n\n// TODO: remove everything below\n/** @deprecated use ECDSASignature */\nexport type SignatureType = ECDSASignature;\n/** @deprecated use ECDSASigRecovered */\nexport type RecoveredSignatureType = ECDSASigRecovered;\n/** @deprecated switch to Uint8Array signatures in format 'compact' */\nexport type SignatureLike = { r: bigint; s: bigint };\nexport type ECDSAExtraEntropy = Hex | boolean;\n/** @deprecated use `ECDSAExtraEntropy` */\nexport type Entropy = Hex | boolean;\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts;\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => WeierstrassPoint<T>;\n};\n/** @deprecated use ECDSASignOpts */\nexport type SignOpts = ECDSASignOpts;\n/** @deprecated use ECDSASignOpts */\nexport type VerOpts = ECDSAVerifyOpts;\n\n/** @deprecated use WeierstrassPoint */\nexport type ProjPointType<T> = WeierstrassPoint<T>;\n/** @deprecated use WeierstrassPointCons */\nexport type ProjConstructor<T> = WeierstrassPointCons<T>;\n/** @deprecated use ECDSASignatureCons */\nexport type SignatureConstructor = ECDSASignatureCons;\n\n// TODO: remove\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (\n    c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ) => Uint8Array;\n};\n\n// LegacyWeierstrassOpts\nexport type CurvePointsTypeWithLength<T> = Readonly<CurvePointsType<T> & Partial<NLength>>;\n\n// LegacyWeierstrass\nexport type CurvePointsRes<T> = {\n  Point: WeierstrassPointCons<T>;\n\n  /** @deprecated use `Point.CURVE()` */\n  CURVE: CurvePointsType<T>;\n  /** @deprecated use `Point` */\n  ProjectivePoint: WeierstrassPointCons<T>;\n  /** @deprecated use `Point.Fn.fromBytes(privateKey)` */\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  /** @deprecated */\n  weierstrassEquation: (x: T) => T;\n  /** @deprecated use `Point.Fn.isValidNot0(num)` */\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// Aliases to legacy types\n// export type CurveType = LegacyECDSAOpts;\n// export type CurveFn = LegacyECDSA;\n// export type CurvePointsRes<T> = LegacyWeierstrass<T>;\n// export type CurvePointsType<T> = LegacyWeierstrassOpts<T>;\n// export type CurvePointsTypeWithLength<T> = LegacyWeierstrassOpts<T>;\n// export type BasicWCurve<T> = LegacyWeierstrassOpts<T>;\n\n/** @deprecated use `Uint8Array` */\nexport type PubKey = Hex | WeierstrassPoint<bigint>;\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac?: HmacFnSync;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\nexport type CurveFn = {\n  /** @deprecated use `Point.CURVE()` */\n  CURVE: CurvePointsType<bigint>;\n  keygen: ECDSA['keygen'];\n  getPublicKey: ECDSA['getPublicKey'];\n  getSharedSecret: ECDSA['getSharedSecret'];\n  sign: ECDSA['sign'];\n  verify: ECDSA['verify'];\n  Point: WeierstrassPointCons<bigint>;\n  /** @deprecated use `Point` */\n  ProjectivePoint: WeierstrassPointCons<bigint>;\n  Signature: ECDSASignatureCons;\n  utils: ECDSA['utils'];\n  lengths: ECDSA['lengths'];\n};\n/** @deprecated use `weierstrass` in newer releases */\nexport function weierstrassPoints<T>(c: CurvePointsTypeWithLength<T>): CurvePointsRes<T> {\n  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  return _weierstrass_new_output_to_legacy(c, Point);\n}\nexport type WsPointComposed<T> = {\n  CURVE: WeierstrassOpts<T>;\n  curveOpts: WeierstrassExtraOpts<T>;\n};\nexport type WsComposed = {\n  /** @deprecated use `Point.CURVE()` */\n  CURVE: WeierstrassOpts<bigint>;\n  hash: CHash;\n  curveOpts: WeierstrassExtraOpts<bigint>;\n  ecdsaOpts: ECDSAOpts;\n};\nfunction _weierstrass_legacy_opts_to_new<T>(c: CurvePointsType<T>): WsPointComposed<T> {\n  const CURVE: WeierstrassOpts<T> = {\n    a: c.a,\n    b: c.b,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy,\n  };\n  const Fp = c.Fp;\n  let allowedLengths = c.allowedPrivateKeyLengths\n    ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))\n    : undefined;\n  const Fn = Field(CURVE.n, {\n    BITS: c.nBitLength,\n    allowedLengths: allowedLengths,\n    modFromBytes: c.wrapPrivateKey,\n  });\n  const curveOpts: WeierstrassExtraOpts<T> = {\n    Fp,\n    Fn,\n    allowInfinityPoint: c.allowInfinityPoint,\n    endo: c.endo,\n    isTorsionFree: c.isTorsionFree,\n    clearCofactor: c.clearCofactor,\n    fromBytes: c.fromBytes,\n    toBytes: c.toBytes,\n  };\n  return { CURVE, curveOpts };\n}\nfunction _ecdsa_legacy_opts_to_new(c: CurveType): WsComposed {\n  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n  const ecdsaOpts: ECDSAOpts = {\n    hmac: c.hmac,\n    randomBytes: c.randomBytes,\n    lowS: c.lowS,\n    bits2int: c.bits2int,\n    bits2int_modN: c.bits2int_modN,\n  };\n  return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };\n}\nexport function _legacyHelperEquat<T>(Fp: IField<T>, a: T, b: T): (x: T) => T {\n  /**\n   * y\u00B2 = x\u00B3 + ax + b: Short weierstrass curve formula. Takes x, returns y\u00B2.\n   * @returns y\u00B2\n   */\n  function weierstrassEquation(x: T): T {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x\u00B2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x\u00B3 + a * x + b\n  }\n  return weierstrassEquation;\n}\nfunction _weierstrass_new_output_to_legacy<T>(\n  c: CurvePointsType<T>,\n  Point: WeierstrassPointCons<T>\n): CurvePointsRes<T> {\n  const { Fp, Fn } = Point;\n  function isWithinCurveOrder(num: bigint): boolean {\n    return inRange(num, _1n, Fn.ORDER);\n  }\n  const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n  return Object.assign(\n    {},\n    {\n      CURVE: c,\n      Point: Point,\n      ProjectivePoint: Point,\n      normPrivateKeyToScalar: (key: PrivKey) => _normFnElement(Fn, key),\n      weierstrassEquation,\n      isWithinCurveOrder,\n    }\n  );\n}\nfunction _ecdsa_new_output_to_legacy(c: CurveType, _ecdsa: ECDSA): CurveFn {\n  const Point = _ecdsa.Point;\n  return Object.assign({}, _ecdsa, {\n    ProjectivePoint: Point,\n    CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS)),\n  });\n}\n\n// _ecdsa_legacy\nexport function weierstrass(c: CurveType): CurveFn {\n  const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  const signs = ecdsa(Point, hash, ecdsaOpts);\n  return _ecdsa_new_output_to_legacy(c, signs);\n}\n", "/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type CurveFn, type CurveType, weierstrass } from './abstract/weierstrass.ts';\nimport type { CHash } from './utils.ts';\n\n/** connects noble-curves to noble-hashes */\nexport function getHash(hash: CHash): { hash: CHash } {\n  return { hash };\n}\n/** Same API as @noble/hashes, with ability to create curve with custom hash */\nexport type CurveDef = Readonly<Omit<CurveType, 'hash'>>;\nexport type CurveFnWithCreate = CurveFn & { create: (hash: CHash) => CurveFn };\n\n/** @deprecated use new `weierstrass()` and `ecdsa()` methods */\nexport function createCurve(curveDef: CurveDef, defHash: CHash): CurveFnWithCreate {\n  const create = (hash: CHash): CurveFn => weierstrass({ ...curveDef, hash: hash });\n  return { ...create(defHash), create };\n}\n", "/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism \u03C8,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport type { CurveLengths } from './abstract/curve.ts';\nimport {\n  createHasher,\n  type H2CHasher,\n  type H2CMethod,\n  isogenyMap,\n} from './abstract/hash-to-curve.ts';\nimport { Field, mapHashToField, mod, pow2 } from './abstract/modular.ts';\nimport {\n  _normFnElement,\n  type EndomorphismOpts,\n  mapToCurveSimpleSWU,\n  type WeierstrassPoint as PointType,\n  type WeierstrassOpts,\n  type WeierstrassPointCons,\n} from './abstract/weierstrass.ts';\nimport type { Hex, PrivKey } from './utils.ts';\nimport {\n  bytesToNumberBE,\n  concatBytes,\n  ensureBytes,\n  inRange,\n  numberToBytesBE,\n  utf8ToBytes,\n} from './utils.ts';\n\n// Seems like generator was produced from some seed:\n// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: BigInt(1),\n  a: BigInt(0),\n  b: BigInt(7),\n  Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n  Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\n};\n\nconst secp256k1_ENDO: EndomorphismOpts = {\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n  basises: [\n    [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],\n    [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],\n  ],\n};\n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\n\n/**\n * \u221An = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1_CURVE.p;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });\n\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey) === true;\n * ```\n */\nexport const secp256k1: CurveFnWithCreate = createCurve(\n  { ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(utf8ToBytes(tag));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toBytes(true).slice(1);\nconst Pointk1 = /* @__PURE__ */ (() => secp256k1.Point)();\nconst hasEven = (y: bigint) => y % _2n === _0n;\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  const { Fn, BASE } = Pointk1;\n  const d_ = _normFnElement(Fn, priv);\n  const p = BASE.multiply(d_); // P = d'\u22C5G; 0 < d' < n check is done inside\n  const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n  return { scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  const Fp = Fpk1;\n  if (!Fp.isValidNot0(x)) throw new Error('invalid x: Fail if x \u2265 p');\n  const xx = Fp.create(x * x);\n  const c = Fp.create(xx * x + BigInt(7)); // Let c = x\u00B3 + 7 mod p.\n  let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n  // Return the unique point P such that x(P) = x and\n  // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  if (!hasEven(y)) y = Fp.neg(y);\n  const p = Pointk1.fromAffine({ x, y });\n  p.assertValidity();\n  return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(secretKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'\u2265n. Ret bytes(d'\u22C5G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message: Hex, secretKey: PrivKey, auxRand: Hex = randomBytes(32)): Uint8Array {\n  const { Fn } = Pointk1;\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'\u22C5G\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const { Fn, BASE } = Pointk1;\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r \u2265 p.\n    if (!inRange(r, _1n, secp256k1_CURVE.p)) return false;\n    const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s \u2265 n.\n    if (!inRange(s, _1n, secp256k1_CURVE.n)) return false;\n    // int(challenge(bytes(r)||bytes(P)||m))%n\n    const e = challenge(Fn.toBytes(r), pointToBytes(P), m);\n    // R = s\u22C5G - e\u22C5P, where -eP == (n-e)P\n    const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n    const { x, y } = R.toAffine();\n    // Fail if is_infinite(R) / not has_even_y(R) / x(R) \u2260 r.\n    if (R.is0() || !hasEven(y) || x !== r) return false;\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport type SecpSchnorr = {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: typeof schnorrGetPublicKey;\n  sign: typeof schnorrSign;\n  verify: typeof schnorrVerify;\n  Point: WeierstrassPointCons<bigint>;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    pointToBytes: (point: PointType<bigint>) => Uint8Array;\n    lift_x: typeof lift_x;\n    taggedHash: typeof taggedHash;\n\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `utils` */\n    numberToBytesBE: typeof numberToBytesBE;\n    /** @deprecated use `utils` */\n    bytesToNumberBE: typeof bytesToNumberBE;\n    /** @deprecated use `modular` */\n    mod: typeof mod;\n  };\n  lengths: CurveLengths;\n};\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */\nexport const schnorr: SecpSchnorr = /* @__PURE__ */ (() => {\n  const size = 32;\n  const seedLength = 48;\n  const randomSecretKey = (seed = randomBytes(seedLength)): Uint8Array => {\n    return mapHashToField(seed, secp256k1_CURVE.n);\n  };\n  // TODO: remove\n  secp256k1.utils.randomSecretKey;\n  function keygen(seed?: Uint8Array) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };\n  }\n  return {\n    keygen,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    Point: Pointk1,\n    utils: {\n      randomSecretKey: randomSecretKey,\n      randomPrivateKey: randomSecretKey,\n      taggedHash,\n\n      // TODO: remove\n      lift_x,\n      pointToBytes,\n      numberToBytesBE,\n      bytesToNumberBE,\n      mod,\n    },\n    lengths: {\n      secretKey: size,\n      publicKey: size,\n      publicKeyHasPrefix: false,\n      signature: size * 2,\n      seed: seedLength,\n    },\n  };\n})();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fpk1,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n  }))();\n\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.Point,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fpk1.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\n\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexport const hashToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\n  secp256k1_hasher.hashToCurve)();\n\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexport const encodeToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\n  secp256k1_hasher.encodeToCurve)();\n", "/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.ts';\nimport { type CHash, clean, createHasher, rotl } from './utils.ts';\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD<SHA1> {\n  private A = SHA1_IV[0] | 0;\n  private B = SHA1_IV[1] | 0;\n  private C = SHA1_IV[2] | 0;\n  private D = SHA1_IV[3] | 0;\n  private E = SHA1_IV[4] | 0;\n\n  constructor() {\n    super(64, 20, 8, false);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { A, B, C, D, E } = this;\n    return [A, B, C, D, E];\n  }\n  protected set(A: number, B: number, C: number, D: number, E: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 80; i++)\n      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n    // Compression function main loop, 80 rounds\n    let { A, B, C, D, E } = this;\n    for (let i = 0; i < 80; i++) {\n      let F, K;\n      if (i < 20) {\n        F = Chi(B, C, D);\n        K = 0x5a827999;\n      } else if (i < 40) {\n        F = B ^ C ^ D;\n        K = 0x6ed9eba1;\n      } else if (i < 60) {\n        F = Maj(B, C, D);\n        K = 0x8f1bbcdc;\n      } else {\n        F = B ^ C ^ D;\n        K = 0xca62c1d6;\n      }\n      const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n      E = D;\n      D = C;\n      C = rotl(B, 30);\n      B = A;\n      A = T;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    this.set(A, B, C, D, E);\n  }\n  protected roundClean(): void {\n    clean(SHA1_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1: CHash = /* @__PURE__ */ createHasher(() => new SHA1());\n\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) =>\n  Math.floor(p32 * Math.abs(Math.sin(i + 1)))\n);\n\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD<MD5> {\n  private A = MD5_IV[0] | 0;\n  private B = MD5_IV[1] | 0;\n  private C = MD5_IV[2] | 0;\n  private D = MD5_IV[3] | 0;\n\n  constructor() {\n    super(64, 16, 8, true);\n  }\n  protected get(): [number, number, number, number] {\n    const { A, B, C, D } = this;\n    return [A, B, C, D];\n  }\n  protected set(A: number, B: number, C: number, D: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D } = this;\n    for (let i = 0; i < 64; i++) {\n      let F, g, s;\n      if (i < 16) {\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = (7 * i) % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    this.set(A, B, C, D);\n  }\n  protected roundClean(): void {\n    clean(MD5_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5: CHash = /* @__PURE__ */ createHasher(() => new MD5());\n\n// RIPEMD-160\n\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n  const L = [Id160];\n  const R = [Pi160];\n  const res = [L, R];\n  for (let i = 0; i < 4; i++) for (let j of res) j.push(j[i].map((k) => Rho160[k]));\n  return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\n\nconst shifts160 = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  if (group === 1) return (x & y) | (~x & z);\n  if (group === 2) return (x | ~y) ^ z;\n  if (group === 3) return (x & z) | (y & ~z);\n  return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number): void {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF_160[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean(): void {\n    clean(BUF_160);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160: CHash = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\n// no abytes: seems to have 10% slowdown. Why?!\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\n  typeof (Uint8Array as any).fromBase64 === 'function')();\n\nconst decodeBase64Builtin = (s: string, isUrl: boolean) => {\n  astr('base64', s);\n  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n  const alphabet = isUrl ? 'base64url' : 'base64';\n  if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');\n  return (Uint8Array as any).fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64(); },\n  decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\n  decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\n  createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32: Bech32 = genBech32('bech32');\n\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\n  typeof (Uint8Array as any).fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin: BytesCoder = {\n  encode(data) { abytes(data); return (data as any).toHex(); },\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex: BytesCoder = hasHexBuiltin\n  ? hexBuiltin\n  : chain(\n      radix2(4),\n      alphabet('0123456789abcdef'),\n      join(''),\n      normalize((s: string) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n          throw new TypeError(\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\n          );\n        return s.toLowerCase();\n      })\n    );\n\nexport type SomeCoders = {\n  utf8: BytesCoder;\n  hex: BytesCoder;\n  base16: BytesCoder;\n  base32: BytesCoder;\n  base64: BytesCoder;\n  base64url: BytesCoder;\n  base58: BytesCoder;\n  base58xmr: BytesCoder;\n};\n// prettier-ignore\nconst CODERS: SomeCoders = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof SomeCoders;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\n/** @deprecated */\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\n/** @deprecated */\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\n\n/** @deprecated */\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\n", "import { hex as baseHex, utf8, type Coder as BaseCoder } from '@scure/base';\n\n/**\n * Define complex binary structures using composable primitives.\n * Main ideas:\n * - Encode / decode can be chained, same as in `scure-base`\n * - A complex structure can be created from an array and struct of primitive types\n * - Strings / bytes are arrays with specific optimizations: we can just read bytes directly\n *   without creating plain array first and reading each byte separately.\n * - Types are inferred from definition\n * @module\n * @example\n * import * as P from 'micro-packed';\n * const s = P.struct({\n *   field1: P.U32BE, // 32-bit unsigned big-endian integer\n *   field2: P.string(P.U8), // String with U8 length prefix\n *   field3: P.bytes(32), // 32 bytes\n *   field4: P.array(P.U16BE, P.struct({ // Array of structs with U16BE length\n *     subField1: P.U64BE, // 64-bit unsigned big-endian integer\n *     subField2: P.string(10) // 10-byte string\n *   }))\n * });\n */\n\n// TODO: remove dependency on scure-base & inline?\n\n/*\nExports can be groupped like this:\n\n- Primitive types: P.bytes, P.string, P.hex, P.constant, P.pointer\n- Complex types: P.array, P.struct, P.tuple, P.map, P.tag, P.mappedTag\n- Padding, prefix, magic: P.padLeft, P.padRight, P.prefix, P.magic, P.magicBytes\n- Flags: P.flag, P.flagged, P.optional\n- Wrappers: P.apply, P.wrap, P.lazy\n- Bit fiddling: P.bits, P.bitset\n- utils: P.validate, coders.decimal\n- Debugger\n*/\n\n/** Shortcut to zero-length (empty) byte array */\nexport const EMPTY: Uint8Array = /* @__PURE__ */ new Uint8Array();\n/** Shortcut to one-element (element is 0) byte array */\nexport const NULL: Uint8Array = /* @__PURE__ */ new Uint8Array([0]);\n\n/** Checks if two Uint8Arrays are equal. Not constant-time. */\nfunction equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\n/** Checks if the given value is a Uint8Array. */\nfunction isBytes(a: unknown): a is Bytes {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/**\n * Concatenates multiple Uint8Arrays.\n * Engines limit functions to 65K+ arguments.\n * @param arrays Array of Uint8Array elements\n * @returns Concatenated Uint8Array\n */\nfunction concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    if (!isBytes(a)) throw new Error('Uint8Array expected');\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n/**\n * Creates DataView from Uint8Array\n * @param arr - bytes\n * @returns DataView\n */\nconst createView = (arr: Uint8Array) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n/**\n * Checks if the provided value is a plain object, not created from any class or special constructor.\n * Array, Uint8Array and others are not plain objects.\n * @param obj - The value to be checked.\n */\nfunction isPlainObject(obj: any): boolean {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nfunction isNum(num: unknown): num is number {\n  return Number.isSafeInteger(num);\n}\n\nexport const utils: {\n  equalBytes: typeof equalBytes;\n  isBytes: typeof isBytes;\n  isCoder: typeof isCoder;\n  checkBounds: typeof checkBounds;\n  concatBytes: typeof concatBytes;\n  createView: (arr: Uint8Array) => DataView;\n  isPlainObject: typeof isPlainObject;\n} = {\n  equalBytes,\n  isBytes,\n  isCoder,\n  checkBounds,\n  concatBytes,\n  createView,\n  isPlainObject,\n};\n\n// Types\nexport type Bytes = Uint8Array;\nexport type Option<T> = T | undefined;\n/**\n * Coder encodes and decodes between two types.\n * @property {(from: F) => T} encode - Encodes (converts) F to T\n * @property {(to: T) => F} decode - Decodes (converts) T to F\n */\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n/**\n * BytesCoder converts value between a type and a byte array\n * @property {number} [size] - Size hint for the element.\n * @property {(data: T) => Bytes} encode - Encodes a value of type T to a byte array\n * @property {(data: Bytes, opts?: ReaderOpts) => T} decode - Decodes a byte array to a value of type T\n */\nexport interface BytesCoder<T> extends Coder<T, Bytes> {\n  size?: number; // Size hint element\n  encode: (data: T) => Bytes;\n  decode: (data: Bytes, opts?: ReaderOpts) => T;\n}\n/**\n * BytesCoderStream converts value between a type and a byte array, using streams.\n * @property {number} [size] - Size hint for the element.\n * @property {(w: Writer, value: T) => void} encodeStream - Encodes a value of type T to a byte array using a Writer stream.\n * @property {(r: Reader) => T} decodeStream - Decodes a byte array to a value of type T using a Reader stream.\n */\nexport interface BytesCoderStream<T> {\n  size?: number;\n  encodeStream: (w: Writer, value: T) => void;\n  decodeStream: (r: Reader) => T;\n}\nexport type CoderType<T> = BytesCoderStream<T> & BytesCoder<T>;\nexport type Sized<T> = CoderType<T> & { size: number };\nexport type UnwrapCoder<T> = T extends CoderType<infer U> ? U : T;\n/**\n * Validation function. Should return value after validation.\n * Can be used to narrow types\n */\nexport type Validate<T> = (elm: T) => T;\n\nexport type Length = CoderType<number> | CoderType<bigint> | number | Bytes | string | null;\n\n// NOTE: we can't have terminator separate function, since it won't know about boundaries\n// E.g. array of U16LE ([1,2,3]) would be [1, 0, 2, 0, 3, 0]\n// But terminator will find array at index '1', which happens to be inside of an element itself\n/**\n * Can be:\n * - Dynamic (CoderType)\n * - Fixed (number)\n * - Terminated (usually zero): Uint8Array with terminator\n * - Field path to field with length (string)\n * - Infinity (null) - decodes until end of buffer\n * Used in:\n * - bytes (string, prefix is implementation of bytes)\n * - array\n */\nconst lengthCoder = (len: Length) => {\n  if (len !== null && typeof len !== 'string' && !isCoder(len) && !isBytes(len) && !isNum(len)) {\n    throw new Error(\n      `lengthCoder: expected null | number | Uint8Array | CoderType, got ${len} (${typeof len})`\n    );\n  }\n  return {\n    encodeStream(w: Writer, value: number | null) {\n      if (len === null) return;\n      if (isCoder(len)) return len.encodeStream(w, value);\n      let byteLen;\n      if (typeof len === 'number') byteLen = len;\n      else if (typeof len === 'string') byteLen = Path.resolve((w as _Writer).stack, len);\n      if (typeof byteLen === 'bigint') byteLen = Number(byteLen);\n      if (byteLen === undefined || byteLen !== value)\n        throw w.err(`Wrong length: ${byteLen} len=${len} exp=${value} (${typeof value})`);\n    },\n    decodeStream(r: Reader) {\n      let byteLen;\n      if (isCoder(len)) byteLen = Number(len.decodeStream(r));\n      else if (typeof len === 'number') byteLen = len;\n      else if (typeof len === 'string') byteLen = Path.resolve((r as _Reader).stack, len);\n      if (typeof byteLen === 'bigint') byteLen = Number(byteLen);\n      if (typeof byteLen !== 'number') throw r.err(`Wrong length: ${byteLen}`);\n      return byteLen;\n    },\n  };\n};\n\ntype ArrLike<T> = Array<T> | ReadonlyArray<T>;\n// prettier-ignore\nexport type TypedArray =\n  | Uint8Array  | Int8Array | Uint8ClampedArray\n  | Uint16Array | Int16Array\n  | Uint32Array | Int32Array;\n\n/** Writable version of a type, where readonly properties are made writable. */\nexport type Writable<T> = T extends {}\n  ? T extends TypedArray\n    ? T\n    : {\n        -readonly [P in keyof T]: Writable<T[P]>;\n      }\n  : T;\nexport type Values<T> = T[keyof T];\nexport type NonUndefinedKey<T, K extends keyof T> = T[K] extends undefined ? never : K;\nexport type NullableKey<T, K extends keyof T> = T[K] extends NonNullable<T[K]> ? never : K;\n// Opt: value !== undefined, but value === T|undefined\nexport type OptKey<T, K extends keyof T> = NullableKey<T, K> & NonUndefinedKey<T, K>;\nexport type ReqKey<T, K extends keyof T> = T[K] extends NonNullable<T[K]> ? K : never;\n\nexport type OptKeys<T> = Pick<T, { [K in keyof T]: OptKey<T, K> }[keyof T]>;\nexport type ReqKeys<T> = Pick<T, { [K in keyof T]: ReqKey<T, K> }[keyof T]>;\nexport type StructInput<T extends Record<string, any>> = { [P in keyof ReqKeys<T>]: T[P] } & {\n  [P in keyof OptKeys<T>]?: T[P];\n};\nexport type StructRecord<T extends Record<string, any>> = {\n  [P in keyof T]: CoderType<T[P]>;\n};\n\nexport type StructOut = Record<string, any>;\n/** Padding function that takes an index and returns a padding value. */\nexport type PadFn = (i: number) => number;\n\n/**\n * Small bitset structure to store position of ranges that have been read.\n * Can be more efficient when internal trees are utilized at the cost of complexity.\n * Needs `O(N/8)` memory for parsing.\n * Purpose: if there are pointers in parsed structure,\n * they can cause read of two distinct ranges:\n * [0-32, 64-128], which means 'pos' is not enough to handle them\n */\nconst Bitset = {\n  BITS: 32,\n  FULL_MASK: -1 >>> 0, // 1<<32 will overflow\n  len: (len: number) => Math.ceil(len / 32),\n  create: (len: number) => new Uint32Array(Bitset.len(len)),\n  clean: (bs: Uint32Array) => bs.fill(0),\n  debug: (bs: Uint32Array) => Array.from(bs).map((i) => (i >>> 0).toString(2).padStart(32, '0')),\n  checkLen: (bs: Uint32Array, len: number) => {\n    if (Bitset.len(len) === bs.length) return;\n    throw new Error(`wrong length=${bs.length}. Expected: ${Bitset.len(len)}`);\n  },\n  chunkLen: (bsLen: number, pos: number, len: number) => {\n    if (pos < 0) throw new Error(`wrong pos=${pos}`);\n    if (pos + len > bsLen) throw new Error(`wrong range=${pos}/${len} of ${bsLen}`);\n  },\n  set: (bs: Uint32Array, chunk: number, value: number, allowRewrite = true) => {\n    if (!allowRewrite && (bs[chunk] & value) !== 0) return false;\n    bs[chunk] |= value;\n    return true;\n  },\n  pos: (pos: number, i: number) => ({\n    chunk: Math.floor((pos + i) / 32),\n    mask: 1 << (32 - ((pos + i) % 32) - 1),\n  }),\n  indices: (bs: Uint32Array, len: number, invert = false) => {\n    Bitset.checkLen(bs, len);\n    const { FULL_MASK, BITS } = Bitset;\n    const left = BITS - (len % BITS);\n    const lastMask = left ? (FULL_MASK >>> left) << left : FULL_MASK;\n    const res = [];\n    for (let i = 0; i < bs.length; i++) {\n      let c = bs[i];\n      if (invert) c = ~c; // allows to gen unset elements\n      // apply mask to last element, so we won't iterate non-existent items\n      if (i === bs.length - 1) c &= lastMask;\n      if (c === 0) continue; // fast-path\n      for (let j = 0; j < BITS; j++) {\n        const m = 1 << (BITS - j - 1);\n        if (c & m) res.push(i * BITS + j);\n      }\n    }\n    return res;\n  },\n  range: (arr: number[]) => {\n    const res = [];\n    let cur;\n    for (const i of arr) {\n      if (cur === undefined || i !== cur.pos + cur.length) res.push((cur = { pos: i, length: 1 }));\n      else cur.length += 1;\n    }\n    return res;\n  },\n  rangeDebug: (bs: Uint32Array, len: number, invert = false) =>\n    `[${Bitset.range(Bitset.indices(bs, len, invert))\n      .map((i) => `(${i.pos}/${i.length})`)\n      .join(', ')}]`,\n  setRange: (bs: Uint32Array, bsLen: number, pos: number, len: number, allowRewrite = true) => {\n    Bitset.chunkLen(bsLen, pos, len);\n    const { FULL_MASK, BITS } = Bitset;\n    // Try to set range with maximum efficiency:\n    // - first chunk is always    '0000[1111]' (only right ones)\n    // - middle chunks are set to '[1111 1111]' (all ones)\n    // - last chunk is always     '[1111]0000' (only left ones)\n    // - max operations:          (N/32) + 2 (first and last)\n    const first = pos % BITS ? Math.floor(pos / BITS) : undefined;\n    const lastPos = pos + len;\n    const last = lastPos % BITS ? Math.floor(lastPos / BITS) : undefined;\n    // special case, whole range inside single chunk\n    if (first !== undefined && first === last)\n      return Bitset.set(\n        bs,\n        first,\n        (FULL_MASK >>> (BITS - len)) << (BITS - len - pos),\n        allowRewrite\n      );\n    if (first !== undefined) {\n      if (!Bitset.set(bs, first, FULL_MASK >>> pos % BITS, allowRewrite)) return false; // first chunk\n    }\n    // middle chunks\n    const start = first !== undefined ? first + 1 : pos / BITS;\n    const end = last !== undefined ? last : lastPos / BITS;\n    for (let i = start; i < end; i++) if (!Bitset.set(bs, i, FULL_MASK, allowRewrite)) return false;\n    if (last !== undefined && first !== last)\n      if (!Bitset.set(bs, last, FULL_MASK << (BITS - (lastPos % BITS)), allowRewrite)) return false; // last chunk\n    return true;\n  },\n};\n\n/** Path related utils (internal) */\ntype Path = { obj: StructOut; field?: string };\ntype PathStack = Path[];\nexport type _PathObjFn = (cb: (field: string, fieldFn: Function) => void) => void;\nconst Path = {\n  /**\n   * Internal method for handling stack of paths (debug, errors, dynamic fields via path)\n   * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).\n   * Also, this makes impossible:\n   * - pushing field when stack is empty\n   * - pushing field inside of field (real bug)\n   * NOTE: we don't want to do '.pop' on error!\n   */\n  pushObj: (stack: PathStack, obj: StructOut, objFn: _PathObjFn): void => {\n    const last: Path = { obj };\n    stack.push(last);\n    objFn((field: string, fieldFn: Function) => {\n      last.field = field;\n      fieldFn();\n      last.field = undefined;\n    });\n    stack.pop();\n  },\n  path: (stack: PathStack): string => {\n    const res = [];\n    for (const i of stack) if (i.field !== undefined) res.push(i.field);\n    return res.join('/');\n  },\n  err: (name: string, stack: PathStack, msg: string | Error): Error => {\n    const err = new Error(\n      `${name}(${Path.path(stack)}): ${typeof msg === 'string' ? msg : msg.message}`\n    );\n    if (msg instanceof Error && msg.stack) err.stack = msg.stack;\n    return err;\n  },\n  resolve: (stack: PathStack, path: string): StructOut | undefined => {\n    const parts = path.split('/');\n    const objPath = stack.map((i) => i.obj);\n    let i = 0;\n    for (; i < parts.length; i++) {\n      if (parts[i] === '..') objPath.pop();\n      else break;\n    }\n    let cur = objPath.pop();\n    for (; i < parts.length; i++) {\n      if (!cur || cur[parts[i]] === undefined) return undefined;\n      cur = cur[parts[i]];\n    }\n    return cur;\n  },\n};\n\n/**\n * Options for the Reader class.\n * @property {boolean} [allowUnreadBytes: false] - If there are remaining unparsed bytes, the decoding is probably wrong.\n * @property {boolean} [allowMultipleReads: false] - The check enforces parser termination. If pointers can read the same region of memory multiple times, you can cause combinatorial explosion by creating an array of pointers to the same address and cause DoS.\n */\nexport type ReaderOpts = {\n  allowUnreadBytes?: boolean;\n  allowMultipleReads?: boolean;\n};\n// These are safe API for external usage\nexport type Reader = {\n  // Utils\n  /** Current position in the buffer. */\n  readonly pos: number;\n  /** Number of bytes left in the buffer. */\n  readonly leftBytes: number;\n  /** Total number of bytes in the buffer. */\n  readonly totalBytes: number;\n  /** Checks if the end of the buffer has been reached. */\n  isEnd(): boolean;\n  /**\n   * Creates an error with the given message. Adds information about current field path.\n   * If Error object provided, saves original stack trace.\n   * @param msg - The error message or an Error object.\n   * @returns The created Error object.\n   */\n  err(msg: string | Error): Error;\n  /**\n   * Reads a specified number of bytes from the buffer.\n   *\n   * WARNING: Uint8Array is subarray of original buffer. Do not modify.\n   * @param n - The number of bytes to read.\n   * @param peek - If `true`, the bytes are read without advancing the position.\n   * @returns The read bytes as a Uint8Array.\n   */\n  bytes(n: number, peek?: boolean): Uint8Array;\n  /**\n   * Reads a single byte from the buffer.\n   * @param peek - If `true`, the byte is read without advancing the position.\n   * @returns The read byte as a number.\n   */\n  byte(peek?: boolean): number;\n  /**\n   * Reads a specified number of bits from the buffer.\n   * @param bits - The number of bits to read.\n   * @returns The read bits as a number.\n   */\n  bits(bits: number): number;\n  /**\n   * Finds the first occurrence of a needle in the buffer.\n   * @param needle - The needle to search for.\n   * @param pos - The starting position for the search.\n   * @returns The position of the first occurrence of the needle, or `undefined` if not found.\n   */\n  find(needle: Bytes, pos?: number): number | undefined;\n  /**\n   * Creates a new Reader instance at the specified offset.\n   * Complex and unsafe API: currently only used in eth ABI parsing of pointers.\n   * Required to break pointer boundaries inside arrays for complex structure.\n   * Please use only if absolutely necessary!\n   * @param n - The offset to create the new Reader at.\n   * @returns A new Reader instance at the specified offset.\n   */\n  offsetReader(n: number): Reader;\n};\n\nexport type Writer = {\n  /**\n   * Creates an error with the given message. Adds information about current field path.\n   * If Error object provided, saves original stack trace.\n   * @param msg - The error message or an Error object.\n   * @returns The created Error object.\n   */\n  err(msg: string | Error): Error;\n  /**\n   * Writes a byte array to the buffer.\n   * @param b - The byte array to write.\n   */\n  bytes(b: Bytes): void;\n  /**\n   * Writes a single byte to the buffer.\n   * @param b - The byte to write.\n   */\n  byte(b: number): void;\n  /**\n   * Writes a specified number of bits to the buffer.\n   * @param value - The value to write.\n   * @param bits - The number of bits to write.\n   */\n  bits(value: number, bits: number): void;\n};\n\n/**\n * Internal structure. Reader class for reading from a byte array.\n * `stack` is internal: for debugger and logging\n * @class Reader\n */\nclass _Reader implements Reader {\n  pos = 0;\n  readonly data: Bytes;\n  readonly opts: ReaderOpts;\n  readonly stack: PathStack;\n  private parent: _Reader | undefined;\n  private parentOffset: number;\n  private bitBuf = 0;\n  private bitPos = 0;\n  private bs: Uint32Array | undefined; // bitset\n  private view: DataView;\n  constructor(\n    data: Bytes,\n    opts: ReaderOpts = {},\n    stack: PathStack = [],\n    parent: _Reader | undefined = undefined,\n    parentOffset: number = 0\n  ) {\n    this.data = data;\n    this.opts = opts;\n    this.stack = stack;\n    this.parent = parent;\n    this.parentOffset = parentOffset;\n    this.view = createView(data);\n  }\n  /** Internal method for pointers. */\n  _enablePointers(): void {\n    if (this.parent) return this.parent._enablePointers();\n    if (this.bs) return;\n    this.bs = Bitset.create(this.data.length);\n    Bitset.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads);\n  }\n  private markBytesBS(pos: number, len: number): boolean {\n    if (this.parent) return this.parent.markBytesBS(this.parentOffset + pos, len);\n    if (!len) return true;\n    if (!this.bs) return true;\n    return Bitset.setRange(this.bs, this.data.length, pos, len, false);\n  }\n  private markBytes(len: number): boolean {\n    const pos = this.pos;\n    this.pos += len;\n    const res = this.markBytesBS(pos, len);\n    if (!this.opts.allowMultipleReads && !res)\n      throw this.err(`multiple read pos=${this.pos} len=${len}`);\n    return res;\n  }\n\n  pushObj(obj: StructOut, objFn: _PathObjFn): void {\n    return Path.pushObj(this.stack, obj, objFn);\n  }\n  readView(n: number, fn: (view: DataView, pos: number) => number): number {\n    if (!Number.isFinite(n)) throw this.err(`readView: wrong length=${n}`);\n    if (this.pos + n > this.data.length) throw this.err('readView: Unexpected end of buffer');\n    const res = fn(this.view, this.pos);\n    this.markBytes(n);\n    return res;\n  }\n  // read bytes by absolute offset\n  absBytes(n: number): Uint8Array {\n    if (n > this.data.length) throw new Error('Unexpected end of buffer');\n    return this.data.subarray(n);\n  }\n  finish(): void {\n    if (this.opts.allowUnreadBytes) return;\n    if (this.bitPos) {\n      throw this.err(\n        `${this.bitPos} bits left after unpack: ${baseHex.encode(this.data.slice(this.pos))}`\n      );\n    }\n    if (this.bs && !this.parent) {\n      const notRead = Bitset.indices(this.bs, this.data.length, true);\n      if (notRead.length) {\n        const formatted = Bitset.range(notRead)\n          .map(\n            ({ pos, length }) =>\n              `(${pos}/${length})[${baseHex.encode(this.data.subarray(pos, pos + length))}]`\n          )\n          .join(', ');\n        throw this.err(`unread byte ranges: ${formatted} (total=${this.data.length})`);\n      } else return; // all bytes read, everything is ok\n    }\n    // Default: no pointers enabled\n    if (!this.isEnd()) {\n      throw this.err(\n        `${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${baseHex.encode(\n          this.data.slice(this.pos)\n        )}`\n      );\n    }\n  }\n  // User methods\n  err(msg: string | Error): Error {\n    return Path.err('Reader', this.stack, msg);\n  }\n  offsetReader(n: number): _Reader {\n    if (n > this.data.length) throw this.err('offsetReader: Unexpected end of buffer');\n    return new _Reader(this.absBytes(n), this.opts, this.stack, this, n);\n  }\n  bytes(n: number, peek = false): Uint8Array {\n    if (this.bitPos) throw this.err('readBytes: bitPos not empty');\n    if (!Number.isFinite(n)) throw this.err(`readBytes: wrong length=${n}`);\n    if (this.pos + n > this.data.length) throw this.err('readBytes: Unexpected end of buffer');\n    const slice = this.data.subarray(this.pos, this.pos + n);\n    if (!peek) this.markBytes(n);\n    return slice;\n  }\n  byte(peek = false): number {\n    if (this.bitPos) throw this.err('readByte: bitPos not empty');\n    if (this.pos + 1 > this.data.length) throw this.err('readBytes: Unexpected end of buffer');\n    const data = this.data[this.pos];\n    if (!peek) this.markBytes(1);\n    return data;\n  }\n  get leftBytes(): number {\n    return this.data.length - this.pos;\n  }\n  get totalBytes(): number {\n    return this.data.length;\n  }\n  isEnd(): boolean {\n    return this.pos >= this.data.length && !this.bitPos;\n  }\n  // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1\n  bits(bits: number): number {\n    if (bits > 32) throw this.err('BitReader: cannot read more than 32 bits in single call');\n    let out = 0;\n    while (bits) {\n      if (!this.bitPos) {\n        this.bitBuf = this.byte();\n        this.bitPos = 8;\n      }\n      const take = Math.min(bits, this.bitPos);\n      this.bitPos -= take;\n      out = (out << take) | ((this.bitBuf >> this.bitPos) & (2 ** take - 1));\n      this.bitBuf &= 2 ** this.bitPos - 1;\n      bits -= take;\n    }\n    // Fix signed integers\n    return out >>> 0;\n  }\n  find(needle: Bytes, pos: number = this.pos): number | undefined {\n    if (!isBytes(needle)) throw this.err(`find: needle is not bytes! ${needle}`);\n    if (this.bitPos) throw this.err('findByte: bitPos not empty');\n    if (!needle.length) throw this.err(`find: needle is empty`);\n    // indexOf should be faster than full equalBytes check\n    for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n      if (idx === -1) return;\n      const leftBytes = this.data.length - idx;\n      if (leftBytes < needle.length) return;\n      if (equalBytes(needle, this.data.subarray(idx, idx + needle.length))) return idx;\n    }\n    return;\n  }\n}\n\n/**\n * Internal structure. Writer class for writing to a byte array.\n * The `stack` argument of constructor is internal, for debugging and logs.\n * @class Writer\n */\nclass _Writer implements Writer {\n  pos: number = 0;\n  readonly stack: PathStack;\n  // We could have a single buffer here and re-alloc it with\n  // x1.5-2 size each time it full, but it will be slower:\n  // basic/encode bench: 395ns -> 560ns\n  private buffers: Bytes[] = [];\n  ptrs: { pos: number; ptr: CoderType<number>; buffer: Bytes }[] = [];\n  private bitBuf = 0;\n  private bitPos = 0;\n  private viewBuf = new Uint8Array(8);\n  private view: DataView;\n  private finished = false;\n  constructor(stack: PathStack = []) {\n    this.stack = stack;\n    this.view = createView(this.viewBuf);\n  }\n  pushObj(obj: StructOut, objFn: _PathObjFn): void {\n    return Path.pushObj(this.stack, obj, objFn);\n  }\n  writeView(len: number, fn: (view: DataView) => void): void {\n    if (this.finished) throw this.err('buffer: finished');\n    if (!isNum(len) || len > 8) throw new Error(`wrong writeView length=${len}`);\n    fn(this.view);\n    this.bytes(this.viewBuf.slice(0, len));\n    this.viewBuf.fill(0);\n  }\n  // User methods\n  err(msg: string | Error): Error {\n    if (this.finished) throw this.err('buffer: finished');\n    return Path.err('Reader', this.stack, msg);\n  }\n  bytes(b: Bytes): void {\n    if (this.finished) throw this.err('buffer: finished');\n    if (this.bitPos) throw this.err('writeBytes: ends with non-empty bit buffer');\n    this.buffers.push(b);\n    this.pos += b.length;\n  }\n  byte(b: number): void {\n    if (this.finished) throw this.err('buffer: finished');\n    if (this.bitPos) throw this.err('writeByte: ends with non-empty bit buffer');\n    this.buffers.push(new Uint8Array([b]));\n    this.pos++;\n  }\n  finish(clean = true): Bytes {\n    if (this.finished) throw this.err('buffer: finished');\n    if (this.bitPos) throw this.err('buffer: ends with non-empty bit buffer');\n    // Can't use concatBytes, because it limits amount of arguments (65K).\n    const buffers = this.buffers.concat(this.ptrs.map((i) => i.buffer));\n    const sum = buffers.map((b) => b.length).reduce((a, b) => a + b, 0);\n    const buf = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < buffers.length; i++) {\n      const a = buffers[i];\n      buf.set(a, pad);\n      pad += a.length;\n    }\n\n    for (let pos = this.pos, i = 0; i < this.ptrs.length; i++) {\n      const ptr = this.ptrs[i];\n      buf.set(ptr.ptr.encode(pos), ptr.pos);\n      pos += ptr.buffer.length;\n    }\n    // Cleanup\n    if (clean) {\n      // We cannot cleanup buffers here, since it can be static user provided buffer.\n      // Only '.byte' and '.bits' create buffer which we can safely clean.\n      // for (const b of this.buffers) b.fill(0);\n      this.buffers = [];\n      for (const p of this.ptrs) p.buffer.fill(0);\n      this.ptrs = [];\n      this.finished = true;\n      this.bitBuf = 0;\n    }\n    return buf;\n  }\n  bits(value: number, bits: number): void {\n    if (bits > 32) throw this.err('writeBits: cannot write more than 32 bits in single call');\n    if (value >= 2 ** bits) throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n    while (bits) {\n      const take = Math.min(bits, 8 - this.bitPos);\n      this.bitBuf = (this.bitBuf << take) | (value >> (bits - take));\n      this.bitPos += take;\n      bits -= take;\n      value &= 2 ** bits - 1;\n      if (this.bitPos === 8) {\n        this.bitPos = 0;\n        this.buffers.push(new Uint8Array([this.bitBuf]));\n        this.pos++;\n      }\n    }\n  }\n}\n// Immutable LE<->BE\nconst swapEndianness = (b: Bytes): Bytes => Uint8Array.from(b).reverse();\n/** Internal function for checking bit bounds of bigint in signed/unsinged form */\nfunction checkBounds(value: bigint, bits: bigint, signed: boolean): void {\n  if (signed) {\n    // [-(2**(32-1)), 2**(32-1)-1]\n    const signBit = 2n ** (bits - 1n);\n    if (value < -signBit || value >= signBit)\n      throw new Error(`value out of signed bounds. Expected ${-signBit} <= ${value} < ${signBit}`);\n  } else {\n    // [0, 2**32-1]\n    if (0n > value || value >= 2n ** bits)\n      throw new Error(`value out of unsigned bounds. Expected 0 <= ${value} < ${2n ** bits}`);\n  }\n}\n\nfunction _wrap<T>(inner: BytesCoderStream<T>): CoderType<T> {\n  return {\n    // NOTE: we cannot export validate here, since it is likely mistake.\n    encodeStream: inner.encodeStream,\n    decodeStream: inner.decodeStream,\n    size: inner.size,\n    encode: (value: T): Bytes => {\n      const w = new _Writer();\n      inner.encodeStream(w, value);\n      return w.finish();\n    },\n    decode: (data: Bytes, opts: ReaderOpts = {}): T => {\n      const r = new _Reader(data, opts);\n      const res = inner.decodeStream(r);\n      r.finish();\n      return res;\n    },\n  };\n}\n\n/**\n * Validates a value before encoding and after decoding using a provided function.\n * @param inner - The inner CoderType.\n * @param fn - The validation function.\n * @returns CoderType which check value with validation function.\n * @example\n * const val = (n: number) => {\n *   if (n > 10) throw new Error(`${n} > 10`);\n *   return n;\n * };\n *\n * const RangedInt = P.validate(P.U32LE, val); // Will check if value is <= 10 during encoding and decoding\n */\nexport function validate<T>(inner: CoderType<T>, fn: Validate<T>): CoderType<T> {\n  if (!isCoder(inner)) throw new Error(`validate: invalid inner value ${inner}`);\n  if (typeof fn !== 'function') throw new Error('validate: fn should be function');\n  return _wrap({\n    size: inner.size,\n    encodeStream: (w: Writer, value: T) => {\n      let res;\n      try {\n        res = fn(value);\n      } catch (e) {\n        throw w.err(e as Error);\n      }\n      inner.encodeStream(w, res);\n    },\n    decodeStream: (r: Reader): T => {\n      const res = inner.decodeStream(r);\n      try {\n        return fn(res);\n      } catch (e) {\n        throw r.err(e as Error);\n      }\n    },\n  });\n}\n\n/**\n * Wraps a stream encoder into a generic encoder and optionally validation function\n * @param {inner} inner BytesCoderStream & { validate?: Validate<T> }.\n * @returns The wrapped CoderType.\n * @example\n * const U8 = P.wrap({\n *   encodeStream: (w: Writer, value: number) => w.byte(value),\n *   decodeStream: (r: Reader): number => r.byte()\n * });\n * const checkedU8 = P.wrap({\n *   encodeStream: (w: Writer, value: number) => w.byte(value),\n *   decodeStream: (r: Reader): number => r.byte()\n *   validate: (n: number) => {\n *    if (n > 10) throw new Error(`${n} > 10`);\n *    return n;\n *   }\n * });\n */\nexport const wrap = <T>(inner: BytesCoderStream<T> & { validate?: Validate<T> }): CoderType<T> => {\n  const res = _wrap(inner);\n  return inner.validate ? validate(res, inner.validate) : res;\n};\n\nconst isBaseCoder = (elm: any) =>\n  isPlainObject(elm) && typeof elm.decode === 'function' && typeof elm.encode === 'function';\n\n/**\n * Checks if the given value is a CoderType.\n * @param elm - The value to check.\n * @returns True if the value is a CoderType, false otherwise.\n */\nexport function isCoder<T>(elm: any): elm is CoderType<T> {\n  return (\n    isPlainObject(elm) &&\n    isBaseCoder(elm) &&\n    typeof elm.encodeStream === 'function' &&\n    typeof elm.decodeStream === 'function' &&\n    (elm.size === undefined || isNum(elm.size))\n  );\n}\n\n// Coders (like in @scure/base) for common operations\n\n/**\n * Base coder for working with dictionaries (records, objects, key-value map)\n * Dictionary is dynamic type like: `[key: string, value: any][]`\n * @returns base coder that encodes/decodes between arrays of key-value tuples and dictionaries.\n * @example\n * const dict: P.CoderType<Record<string, number>> = P.apply(\n *  P.array(P.U16BE, P.tuple([P.cstring, P.U32LE] as const)),\n *  P.coders.dict()\n * );\n */\nfunction dict<T>(): BaseCoder<[string, T][], Record<string, T>> {\n  return {\n    encode: (from: [string, T][]): Record<string, T> => {\n      if (!Array.isArray(from)) throw new Error('array expected');\n      const to: Record<string, T> = {};\n      for (const item of from) {\n        if (!Array.isArray(item) || item.length !== 2)\n          throw new Error(`array of two elements expected`);\n        const name = item[0];\n        const value = item[1];\n        if (to[name] !== undefined) throw new Error(`key(${name}) appears twice in struct`);\n        to[name] = value;\n      }\n      return to;\n    },\n    decode: (to: Record<string, T>): [string, T][] => {\n      if (!isPlainObject(to)) throw new Error(`expected plain object, got ${to}`);\n      return Object.entries(to);\n    },\n  };\n}\n/**\n * Safely converts bigint to number.\n * Sometimes pointers / tags use u64 or other big numbers which cannot be represented by number,\n * but we still can use them since real value will be smaller than u32\n */\nconst numberBigint: BaseCoder<bigint, number> = {\n  encode: (from: bigint): number => {\n    if (typeof from !== 'bigint') throw new Error(`expected bigint, got ${typeof from}`);\n    if (from > BigInt(Number.MAX_SAFE_INTEGER))\n      throw new Error(`element bigger than MAX_SAFE_INTEGER=${from}`);\n    return Number(from);\n  },\n  decode: (to: number): bigint => {\n    if (!isNum(to)) throw new Error('element is not a safe integer');\n    return BigInt(to);\n  },\n};\n// TODO: replace map with this?\ntype Enum = { [k: string]: number | string } & { [k: number]: string };\n// Doesn't return numeric keys, so it's fine\ntype EnumKeys<T extends Enum> = keyof T;\n/**\n * Base coder for working with TypeScript enums.\n * @param e - TypeScript enum.\n * @returns base coder that encodes/decodes between numbers and enum keys.\n * @example\n * enum Color { Red, Green, Blue }\n * const colorCoder = P.coders.tsEnum(Color);\n * colorCoder.encode(Color.Red); // 'Red'\n * colorCoder.decode('Green'); // 1\n */\nfunction tsEnum<T extends Enum>(e: T): BaseCoder<number, EnumKeys<T>> {\n  if (!isPlainObject(e)) throw new Error('plain object expected');\n  return {\n    encode: (from: number): string => {\n      if (!isNum(from) || !(from in e)) throw new Error(`wrong value ${from}`);\n      return e[from];\n    },\n    decode: (to: string): number => {\n      if (typeof to !== 'string') throw new Error(`wrong value ${typeof to}`);\n      return e[to] as number;\n    },\n  };\n}\n/**\n * Base coder for working with decimal numbers.\n * @param precision - Number of decimal places.\n * @param round - Round fraction part if bigger than precision (throws error by default)\n * @returns base coder that encodes/decodes between bigints and decimal strings.\n * @example\n * const decimal8 = P.coders.decimal(8);\n * decimal8.encode(630880845n); // '6.30880845'\n * decimal8.decode('6.30880845'); // 630880845n\n */\nfunction decimal(precision: number, round = false): Coder<bigint, string> {\n  if (!isNum(precision)) throw new Error(`decimal/precision: wrong value ${precision}`);\n  if (typeof round !== 'boolean')\n    throw new Error(`decimal/round: expected boolean, got ${typeof round}`);\n  const decimalMask = 10n ** BigInt(precision);\n  return {\n    encode: (from: bigint): string => {\n      if (typeof from !== 'bigint') throw new Error(`expected bigint, got ${typeof from}`);\n      let s = (from < 0n ? -from : from).toString(10);\n      let sep = s.length - precision;\n      if (sep < 0) {\n        s = s.padStart(s.length - sep, '0');\n        sep = 0;\n      }\n      let i = s.length - 1;\n      for (; i >= sep && s[i] === '0'; i--);\n      let int = s.slice(0, sep);\n      let frac = s.slice(sep, i + 1);\n      if (!int) int = '0';\n      if (from < 0n) int = '-' + int;\n      if (!frac) return int;\n      return `${int}.${frac}`;\n    },\n    decode: (to: string): bigint => {\n      if (typeof to !== 'string') throw new Error(`expected string, got ${typeof to}`);\n      if (to === '-0') throw new Error(`negative zero is not allowed`);\n      let neg = false;\n      if (to.startsWith('-')) {\n        neg = true;\n        to = to.slice(1);\n      }\n      if (!/^(0|[1-9]\\d*)(\\.\\d+)?$/.test(to)) throw new Error(`wrong string value=${to}`);\n      let sep = to.indexOf('.');\n      sep = sep === -1 ? to.length : sep;\n      // split by separator and strip trailing zeros from fraction. always returns [string, string] (.split doesn't).\n      const intS = to.slice(0, sep);\n      const fracS = to.slice(sep + 1).replace(/0+$/, '');\n      const int = BigInt(intS) * decimalMask;\n      if (!round && fracS.length > precision) {\n        throw new Error(\n          `fractional part cannot be represented with this precision (num=${to}, prec=${precision})`\n        );\n      }\n      const fracLen = Math.min(fracS.length, precision);\n      const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n      const value = int + frac;\n      return neg ? -value : value;\n    },\n  };\n}\n\n// TODO: export from @scure/base?\ntype BaseInput<F> = F extends BaseCoder<infer T, any> ? T : never;\ntype BaseOutput<F> = F extends BaseCoder<any, infer T> ? T : never;\n\n/**\n * Combines multiple coders into a single coder, allowing conditional encoding/decoding based on input.\n * Acts as a parser combinator, splitting complex conditional coders into smaller parts.\n *\n *   `encode = [Ae, Be]; decode = [Ad, Bd]`\n *   ->\n *   `match([{encode: Ae, decode: Ad}, {encode: Be; decode: Bd}])`\n *\n * @param lst - Array of coders to match.\n * @returns Combined coder for conditional encoding/decoding.\n */\nfunction match<\n  L extends BaseCoder<unknown | undefined, unknown | undefined>[],\n  I = { [K in keyof L]: NonNullable<BaseInput<L[K]>> }[number],\n  O = { [K in keyof L]: NonNullable<BaseOutput<L[K]>> }[number],\n>(lst: L): BaseCoder<I, O> {\n  if (!Array.isArray(lst)) throw new Error(`expected array, got ${typeof lst}`);\n  for (const i of lst) if (!isBaseCoder(i)) throw new Error(`wrong base coder ${i}`);\n  return {\n    encode: (from: I): O => {\n      for (const c of lst) {\n        const elm = c.encode(from);\n        if (elm !== undefined) return elm as O;\n      }\n      throw new Error(`match/encode: cannot find match in ${from}`);\n    },\n    decode: (to: O): I => {\n      for (const c of lst) {\n        const elm = c.decode(to);\n        if (elm !== undefined) return elm as I;\n      }\n      throw new Error(`match/decode: cannot find match in ${to}`);\n    },\n  };\n}\n/** Reverses direction of coder */\nconst reverse = <F, T>(coder: Coder<F, T>): Coder<T, F> => {\n  if (!isBaseCoder(coder)) throw new Error('BaseCoder expected');\n  return { encode: coder.decode, decode: coder.encode };\n};\n\nexport const coders: {\n  dict: typeof dict;\n  numberBigint: BaseCoder<bigint, number>;\n  tsEnum: typeof tsEnum;\n  decimal: typeof decimal;\n  match: typeof match;\n  reverse: <F, T>(coder: Coder<F, T>) => Coder<T, F>;\n} = { dict, numberBigint, tsEnum, decimal, match, reverse };\n\n/**\n * CoderType for parsing individual bits.\n * NOTE: Structure should parse whole amount of bytes before it can start parsing byte-level elements.\n * @param len - Number of bits to parse.\n * @returns CoderType representing the parsed bits.\n * @example\n * const s = P.struct({ magic: P.bits(1), version: P.bits(1), tag: P.bits(4), len: P.bits(2) });\n */\nexport const bits = (len: number): CoderType<number> => {\n  if (!isNum(len)) throw new Error(`bits: wrong length ${len} (${typeof len})`);\n  return wrap({\n    encodeStream: (w: Writer, value: number) => w.bits(value, len),\n    decodeStream: (r: Reader): number => r.bits(len),\n    validate: (value) => {\n      if (!isNum(value)) throw new Error(`bits: wrong value ${value}`);\n      return value;\n    },\n  });\n};\n\n/**\n * CoderType for working with bigint values.\n * Unsized bigint values should be wrapped in a container (e.g., bytes or string).\n *\n * `0n = new Uint8Array([])`\n *\n * `1n = new Uint8Array([1n])`\n *\n * Please open issue, if you need different behavior for zero.\n *\n * @param size - Size of the bigint in bytes.\n * @param le - Whether to use little-endian byte order.\n * @param signed - Whether the bigint is signed.\n * @param sized - Whether the bigint should have a fixed size.\n * @returns CoderType representing the bigint value.\n * @example\n * const U512BE = P.bigint(64, false, true, true); // Define a CoderType for a 512-bit unsigned big-endian integer\n */\nexport const bigint = (\n  size: number,\n  le = false,\n  signed = false,\n  sized = true\n): CoderType<bigint> => {\n  if (!isNum(size)) throw new Error(`bigint/size: wrong value ${size}`);\n  if (typeof le !== 'boolean') throw new Error(`bigint/le: expected boolean, got ${typeof le}`);\n  if (typeof signed !== 'boolean')\n    throw new Error(`bigint/signed: expected boolean, got ${typeof signed}`);\n  if (typeof sized !== 'boolean')\n    throw new Error(`bigint/sized: expected boolean, got ${typeof sized}`);\n  const bLen = BigInt(size);\n  const signBit = 2n ** (8n * bLen - 1n);\n  return wrap({\n    size: sized ? size : undefined,\n    encodeStream: (w: Writer, value: bigint) => {\n      if (signed && value < 0) value = value | signBit;\n      const b = [];\n      for (let i = 0; i < size; i++) {\n        b.push(Number(value & 255n));\n        value >>= 8n;\n      }\n      let res = new Uint8Array(b).reverse();\n      if (!sized) {\n        let pos = 0;\n        for (pos = 0; pos < res.length; pos++) if (res[pos] !== 0) break;\n        res = res.subarray(pos); // remove leading zeros\n      }\n      w.bytes(le ? res.reverse() : res);\n    },\n    decodeStream: (r: Reader): bigint => {\n      // TODO: for le we can read until first zero?\n      const value = r.bytes(sized ? size : Math.min(size, r.leftBytes));\n      const b = le ? value : swapEndianness(value);\n      let res = 0n;\n      for (let i = 0; i < b.length; i++) res |= BigInt(b[i]) << (8n * BigInt(i));\n      if (signed && res & signBit) res = (res ^ signBit) - signBit;\n      return res;\n    },\n    validate: (value) => {\n      if (typeof value !== 'bigint') throw new Error(`bigint: invalid value: ${value}`);\n      checkBounds(value, 8n * bLen, !!signed);\n      return value;\n    },\n  });\n};\n/** Unsigned 256-bit little-endian integer CoderType. */\nexport const U256LE: CoderType<bigint> = /* @__PURE__ */ bigint(32, true);\n/** Unsigned 256-bit big-endian integer CoderType. */\nexport const U256BE: CoderType<bigint> = /* @__PURE__ */ bigint(32, false);\n/** Signed 256-bit little-endian integer CoderType. */\nexport const I256LE: CoderType<bigint> = /* @__PURE__ */ bigint(32, true, true);\n/** Signed 256-bit big-endian integer CoderType. */\nexport const I256BE: CoderType<bigint> = /* @__PURE__ */ bigint(32, false, true);\n/** Unsigned 128-bit little-endian integer CoderType. */\nexport const U128LE: CoderType<bigint> = /* @__PURE__ */ bigint(16, true);\n/** Unsigned 128-bit big-endian integer CoderType. */\nexport const U128BE: CoderType<bigint> = /* @__PURE__ */ bigint(16, false);\n/** Signed 128-bit little-endian integer CoderType. */\nexport const I128LE: CoderType<bigint> = /* @__PURE__ */ bigint(16, true, true);\n/** Signed 128-bit big-endian integer CoderType. */\nexport const I128BE: CoderType<bigint> = /* @__PURE__ */ bigint(16, false, true);\n/** Unsigned 64-bit little-endian integer CoderType. */\nexport const U64LE: CoderType<bigint> = /* @__PURE__ */ bigint(8, true);\n/** Unsigned 64-bit big-endian integer CoderType. */\nexport const U64BE: CoderType<bigint> = /* @__PURE__ */ bigint(8, false);\n/** Signed 64-bit little-endian integer CoderType. */\nexport const I64LE: CoderType<bigint> = /* @__PURE__ */ bigint(8, true, true);\n/** Signed 64-bit big-endian integer CoderType. */\nexport const I64BE: CoderType<bigint> = /* @__PURE__ */ bigint(8, false, true);\n\n/**\n * CoderType for working with numbber values (up to 6 bytes/48 bits).\n * Unsized int values should be wrapped in a container (e.g., bytes or string).\n *\n * `0 = new Uint8Array([])`\n *\n * `1 = new Uint8Array([1n])`\n *\n * Please open issue, if you need different behavior for zero.\n *\n * @param size - Size of the number in bytes.\n * @param le - Whether to use little-endian byte order.\n * @param signed - Whether the number is signed.\n * @param sized - Whether the number should have a fixed size.\n * @returns CoderType representing the number value.\n * @example\n * const uint64BE = P.bigint(8, false, true); // Define a CoderType for a 64-bit unsigned big-endian integer\n */\nexport const int = (size: number, le = false, signed = false, sized = true): CoderType<number> => {\n  if (!isNum(size)) throw new Error(`int/size: wrong value ${size}`);\n  if (typeof le !== 'boolean') throw new Error(`int/le: expected boolean, got ${typeof le}`);\n  if (typeof signed !== 'boolean')\n    throw new Error(`int/signed: expected boolean, got ${typeof signed}`);\n  if (typeof sized !== 'boolean')\n    throw new Error(`int/sized: expected boolean, got ${typeof sized}`);\n  if (size > 6) throw new Error('int supports size up to 6 bytes (48 bits): use bigints instead');\n  return apply(bigint(size, le, signed, sized), coders.numberBigint);\n};\n\ntype ViewCoder = {\n  read: (view: DataView, pos: number) => number;\n  write: (view: DataView, value: number) => void;\n  validate?: (value: number) => void;\n};\n\nconst view = (len: number, opts: ViewCoder) =>\n  wrap({\n    size: len,\n    encodeStream: (w, value: number) =>\n      (w as _Writer).writeView(len, (view) => opts.write(view, value)),\n    decodeStream: (r) => (r as _Reader).readView(len, opts.read),\n    validate: (value: number) => {\n      if (typeof value !== 'number')\n        throw new Error(`viewCoder: expected number, got ${typeof value}`);\n      if (opts.validate) opts.validate(value);\n      return value;\n    },\n  });\n\nconst intView = (len: number, signed: boolean, opts: ViewCoder) => {\n  const bits = len * 8;\n  const signBit = 2 ** (bits - 1);\n  // Inlined checkBounds for integer\n  const validateSigned = (value: number) => {\n    if (!isNum(value)) throw new Error(`sintView: value is not safe integer: ${value}`);\n    if (value < -signBit || value >= signBit) {\n      throw new Error(\n        `sintView: value out of bounds. Expected ${-signBit} <= ${value} < ${signBit}`\n      );\n    }\n  };\n  const maxVal = 2 ** bits;\n  const validateUnsigned = (value: number) => {\n    if (!isNum(value)) throw new Error(`uintView: value is not safe integer: ${value}`);\n    if (0 > value || value >= maxVal) {\n      throw new Error(`uintView: value out of bounds. Expected 0 <= ${value} < ${maxVal}`);\n    }\n  };\n  return view(len, {\n    write: opts.write,\n    read: opts.read,\n    validate: signed ? validateSigned : validateUnsigned,\n  });\n};\n\n/** Unsigned 32-bit little-endian integer CoderType. */\nexport const U32LE: CoderType<number> = /* @__PURE__ */ intView(4, false, {\n  read: (view, pos) => view.getUint32(pos, true),\n  write: (view, value) => view.setUint32(0, value, true),\n});\n/** Unsigned 32-bit big-endian integer CoderType. */\nexport const U32BE: CoderType<number> = /* @__PURE__ */ intView(4, false, {\n  read: (view, pos) => view.getUint32(pos, false),\n  write: (view, value) => view.setUint32(0, value, false),\n});\n/** Signed 32-bit little-endian integer CoderType. */\nexport const I32LE: CoderType<number> = /* @__PURE__ */ intView(4, true, {\n  read: (view, pos) => view.getInt32(pos, true),\n  write: (view, value) => view.setInt32(0, value, true),\n});\n/** Signed 32-bit big-endian integer CoderType. */\nexport const I32BE: CoderType<number> = /* @__PURE__ */ intView(4, true, {\n  read: (view, pos) => view.getInt32(pos, false),\n  write: (view, value) => view.setInt32(0, value, false),\n});\n/** Unsigned 16-bit little-endian integer CoderType. */\nexport const U16LE: CoderType<number> = /* @__PURE__ */ intView(2, false, {\n  read: (view, pos) => view.getUint16(pos, true),\n  write: (view, value) => view.setUint16(0, value, true),\n});\n/** Unsigned 16-bit big-endian integer CoderType. */\nexport const U16BE: CoderType<number> = /* @__PURE__ */ intView(2, false, {\n  read: (view, pos) => view.getUint16(pos, false),\n  write: (view, value) => view.setUint16(0, value, false),\n});\n/** Signed 16-bit little-endian integer CoderType. */\nexport const I16LE: CoderType<number> = /* @__PURE__ */ intView(2, true, {\n  read: (view, pos) => view.getInt16(pos, true),\n  write: (view, value) => view.setInt16(0, value, true),\n});\n/** Signed 16-bit big-endian integer CoderType. */\nexport const I16BE: CoderType<number> = /* @__PURE__ */ intView(2, true, {\n  read: (view, pos) => view.getInt16(pos, false),\n  write: (view, value) => view.setInt16(0, value, false),\n});\n/** Unsigned 8-bit integer CoderType. */\nexport const U8: CoderType<number> = /* @__PURE__ */ intView(1, false, {\n  read: (view, pos) => view.getUint8(pos),\n  write: (view, value) => view.setUint8(0, value),\n});\n/** Signed 8-bit integer CoderType. */\nexport const I8: CoderType<number> = /* @__PURE__ */ intView(1, true, {\n  read: (view, pos) => view.getInt8(pos),\n  write: (view, value) => view.setInt8(0, value),\n});\n\n// Floats\nconst f32 = (le?: boolean) =>\n  view(4, {\n    read: (view, pos) => view.getFloat32(pos, le),\n    write: (view, value) => view.setFloat32(0, value, le),\n    validate: (value) => {\n      if (Math.fround(value) !== value && !Number.isNaN(value))\n        throw new Error(`f32: wrong value=${value}`);\n    },\n  });\nconst f64 = (le?: boolean) =>\n  view(8, {\n    read: (view, pos) => view.getFloat64(pos, le),\n    write: (view, value) => view.setFloat64(0, value, le),\n  });\n\n/** 32-bit big-endian floating point CoderType (\"binary32\", IEEE 754-2008). */\nexport const F32BE: CoderType<number> = /* @__PURE__ */ f32(false);\n/** 32-bit little-endian floating point  CoderType (\"binary32\", IEEE 754-2008). */\nexport const F32LE: CoderType<number> = /* @__PURE__ */ f32(true);\n/** A 64-bit big-endian floating point type (\"binary64\", IEEE 754-2008). Any JS number can be encoded. */\nexport const F64BE: CoderType<number> = /* @__PURE__ */ f64(false);\n/** A 64-bit little-endian floating point type (\"binary64\", IEEE 754-2008). Any JS number can be encoded. */\nexport const F64LE: CoderType<number> = /* @__PURE__ */ f64(true);\n\n/** Boolean CoderType. */\nexport const bool: CoderType<boolean> = /* @__PURE__ */ wrap({\n  size: 1,\n  encodeStream: (w: Writer, value: boolean) => w.byte(value ? 1 : 0),\n  decodeStream: (r: Reader): boolean => {\n    const value = r.byte();\n    if (value !== 0 && value !== 1) throw r.err(`bool: invalid value ${value}`);\n    return value === 1;\n  },\n  validate: (value) => {\n    if (typeof value !== 'boolean') throw new Error(`bool: invalid value ${value}`);\n    return value;\n  },\n});\n\n/**\n * Bytes CoderType with a specified length and endianness.\n * The bytes can have:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - CoderType, number, Uint8Array (terminator) or null\n * @param le - Whether to use little-endian byte order.\n * @returns CoderType representing the bytes.\n * @example\n * // Dynamic size bytes (prefixed with P.U16BE number of bytes length)\n * const dynamicBytes = P.bytes(P.U16BE, false);\n * const fixedBytes = P.bytes(32, false); // Fixed size bytes\n * const unknownBytes = P.bytes(null, false); // Unknown size bytes, will parse until end of buffer\n * const zeroTerminatedBytes = P.bytes(new Uint8Array([0]), false); // Zero-terminated bytes\n */\nconst createBytes = (len: Length, le = false): CoderType<Bytes> => {\n  if (typeof le !== 'boolean') throw new Error(`bytes/le: expected boolean, got ${typeof le}`);\n  const _length = lengthCoder(len);\n  const _isb = isBytes(len);\n  return wrap({\n    size: typeof len === 'number' ? len : undefined,\n    encodeStream: (w: Writer, value: Bytes) => {\n      if (!_isb) _length.encodeStream(w, value.length);\n      w.bytes(le ? swapEndianness(value) : value);\n      if (_isb) w.bytes(len);\n    },\n    decodeStream: (r: Reader): Bytes => {\n      let bytes: Bytes;\n      if (_isb) {\n        const tPos = r.find(len);\n        if (!tPos) throw r.err(`bytes: cannot find terminator`);\n        bytes = r.bytes(tPos - r.pos);\n        r.bytes(len.length);\n      } else {\n        bytes = r.bytes(len === null ? r.leftBytes : _length.decodeStream(r));\n      }\n      return le ? swapEndianness(bytes) : bytes;\n    },\n    validate: (value) => {\n      if (!isBytes(value)) throw new Error(`bytes: invalid value ${value}`);\n      return value;\n    },\n  });\n};\n\nexport { createBytes as bytes, createHex as hex };\n\n/**\n * Prefix-encoded value using a length prefix and an inner CoderType.\n * The prefix can have:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param inner - CoderType for the actual value to be prefix-encoded.\n * @returns CoderType representing the prefix-encoded value.\n * @example\n * const dynamicPrefix = P.prefix(P.U16BE, P.bytes(null)); // Dynamic size prefix (prefixed with P.U16BE number of bytes length)\n * const fixedPrefix = P.prefix(10, P.bytes(null)); // Fixed size prefix (always 10 bytes)\n */\nexport function prefix<T>(len: Length, inner: CoderType<T>): CoderType<T> {\n  if (!isCoder(inner)) throw new Error(`prefix: invalid inner value ${inner}`);\n  return apply(createBytes(len), reverse(inner)) as CoderType<T>;\n}\n\n/**\n * String CoderType with a specified length and endianness.\n * The string can be:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param le - Whether to use little-endian byte order.\n * @returns CoderType representing the string.\n * @example\n * const dynamicString = P.string(P.U16BE, false); // Dynamic size string (prefixed with P.U16BE number of string length)\n * const fixedString = P.string(10, false); // Fixed size string\n * const unknownString = P.string(null, false); // Unknown size string, will parse until end of buffer\n * const nullTerminatedString = P.cstring; // NUL-terminated string\n * const _cstring = P.string(new Uint8Array([0])); // Same thing\n */\nexport const string = (len: Length, le = false): CoderType<string> =>\n  validate(apply(createBytes(len, le), utf8), (value) => {\n    // TextEncoder/TextDecoder will fail on non-string, but we create more readable errors earlier\n    if (typeof value !== 'string') throw new Error(`expected string, got ${typeof value}`);\n    return value;\n  });\n\n/** NUL-terminated string CoderType. */\nexport const cstring: CoderType<string> = /* @__PURE__ */ string(NULL);\n\ntype HexOpts = { isLE?: boolean; with0x?: boolean };\n/**\n * Hexadecimal string CoderType with a specified length, endianness, and optional 0x prefix.\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param le - Whether to use little-endian byte order.\n * @param withZero - Whether to include the 0x prefix.\n * @returns CoderType representing the hexadecimal string.\n * @example\n * const dynamicHex = P.hex(P.U16BE, {isLE: false, with0x: true}); // Hex string with 0x prefix and U16BE length\n * const fixedHex = P.hex(32, {isLE: false, with0x: false}); // Fixed-length 32-byte hex string without 0x prefix\n */\nconst createHex = (\n  len: Length,\n  options: HexOpts = { isLE: false, with0x: false }\n): CoderType<string> => {\n  let inner = apply(createBytes(len, options.isLE), baseHex);\n  const prefix = options.with0x;\n  if (typeof prefix !== 'boolean')\n    throw new Error(`hex/with0x: expected boolean, got ${typeof prefix}`);\n  if (prefix) {\n    inner = apply(inner, {\n      encode: (value) => `0x${value}`,\n      decode: (value) => {\n        if (!value.startsWith('0x'))\n          throw new Error('hex(with0x=true).encode input should start with 0x');\n        return value.slice(2);\n      },\n    });\n  }\n  return inner;\n};\n\n/**\n * Applies a base coder to a CoderType.\n * @param inner - The inner CoderType.\n * @param b - The base coder to apply.\n * @returns CoderType representing the transformed value.\n * @example\n * import { hex } from '@scure/base';\n * const hex = P.apply(P.bytes(32), hex); // will decode bytes into a hex string\n */\nexport function apply<T, F>(inner: CoderType<T>, base: BaseCoder<T, F>): CoderType<F> {\n  if (!isCoder(inner)) throw new Error(`apply: invalid inner value ${inner}`);\n  if (!isBaseCoder(base)) throw new Error(`apply: invalid base value ${inner}`);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w: Writer, value: F) => {\n      let innerValue;\n      try {\n        innerValue = base.decode(value);\n      } catch (e) {\n        throw w.err('' + e);\n      }\n      return inner.encodeStream(w, innerValue);\n    },\n    decodeStream: (r: Reader): F => {\n      const innerValue = inner.decodeStream(r);\n      try {\n        return base.encode(innerValue);\n      } catch (e) {\n        throw r.err('' + e);\n      }\n    },\n  });\n}\n\n/**\n * Lazy CoderType that is evaluated at runtime.\n * @param fn - A function that returns the CoderType.\n * @returns CoderType representing the lazy value.\n * @example\n * type Tree = { name: string; children: Tree[] };\n * const tree = P.struct({\n *   name: P.cstring,\n *   children: P.array(\n *     P.U16BE,\n *     P.lazy((): P.CoderType<Tree> => tree)\n *   ),\n * });\n */\nexport function lazy<T>(fn: () => CoderType<T>): CoderType<T> {\n  if (typeof fn !== 'function') throw new Error(`lazy: expected function, got ${typeof fn}`);\n  return wrap({\n    encodeStream: (w: Writer, value: T) => fn().encodeStream(w, value),\n    decodeStream: (r: Reader): T => fn().decodeStream(r),\n  });\n}\n\n/**\n * Flag CoderType that encodes/decodes a boolean value based on the presence of a marker.\n * @param flagValue - Marker value.\n * @param xor - Whether to invert the flag behavior.\n * @returns CoderType representing the flag value.\n * @example\n * const flag = P.flag(new Uint8Array([0x01, 0x02])); // Encodes true as u8a([0x01, 0x02]), false as u8a([])\n * const flagXor = P.flag(new Uint8Array([0x01, 0x02]), true); // Encodes true as u8a([]), false as u8a([0x01, 0x02])\n * // Conditional encoding with flagged\n * const s = P.struct({ f: P.flag(new Uint8Array([0x0, 0x1])), f2: P.flagged('f', P.U32BE) });\n */\nexport const flag = (flagValue: Bytes, xor = false): CoderType<boolean | undefined> => {\n  if (!isBytes(flagValue))\n    throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof flagValue}`);\n  if (typeof xor !== 'boolean') throw new Error(`flag/xor: expected boolean, got ${typeof xor}`);\n  return wrap({\n    size: flagValue.length,\n    encodeStream: (w: Writer, value: boolean | undefined) => {\n      if (!!value !== xor) w.bytes(flagValue);\n    },\n    decodeStream: (r: Reader): boolean | undefined => {\n      let hasFlag = r.leftBytes >= flagValue.length;\n      if (hasFlag) {\n        hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n        // Found flag, advance cursor position\n        if (hasFlag) r.bytes(flagValue.length);\n      }\n      return hasFlag !== xor; // hasFlag ^ xor\n    },\n    validate: (value) => {\n      if (value !== undefined && typeof value !== 'boolean')\n        throw new Error(`flag: expected boolean value or undefined, got ${typeof value}`);\n      return value;\n    },\n  });\n};\n\n/**\n * Conditional CoderType that encodes/decodes a value only if a flag is present.\n * @param path - Path to the flag value or a CoderType for the flag.\n * @param inner - Inner CoderType for the value.\n * @param def - Optional default value to use if the flag is not present.\n * @returns CoderType representing the conditional value.\n * @example\n * const s = P.struct({\n *   f: P.flag(new Uint8Array([0x0, 0x1])),\n *   f2: P.flagged('f', P.U32BE)\n * });\n *\n * @example\n * const s2 = P.struct({\n *   f: P.flag(new Uint8Array([0x0, 0x1])),\n *   f2: P.flagged('f', P.U32BE, 123)\n * });\n */\nexport function flagged<T>(\n  path: string | CoderType<boolean>,\n  inner: CoderType<T>,\n  def?: T\n): CoderType<Option<T>> {\n  if (!isCoder(inner)) throw new Error(`flagged: invalid inner value ${inner}`);\n  if (typeof path !== 'string' && !isCoder(inner)) throw new Error(`flagged: wrong path=${path}`);\n  return wrap({\n    encodeStream: (w: Writer, value: Option<T>) => {\n      if (typeof path === 'string') {\n        if (Path.resolve((w as _Writer).stack, path)) inner.encodeStream(w, value);\n        else if (def) inner.encodeStream(w, def);\n      } else {\n        path.encodeStream(w, !!value);\n        if (!!value) inner.encodeStream(w, value);\n        else if (def) inner.encodeStream(w, def);\n      }\n    },\n    decodeStream: (r: Reader): Option<T> => {\n      let hasFlag = false;\n      if (typeof path === 'string') hasFlag = !!Path.resolve((r as _Reader).stack, path);\n      else hasFlag = path.decodeStream(r);\n      // If there is a flag -- decode and return value\n      if (hasFlag) return inner.decodeStream(r);\n      else if (def) inner.decodeStream(r);\n      return;\n    },\n  });\n}\n/**\n * Optional CoderType that encodes/decodes a value based on a flag.\n * @param flag - CoderType for the flag value.\n * @param inner - Inner CoderType for the value.\n * @param def - Optional default value to use if the flag is not present.\n * @returns CoderType representing the optional value.\n * @example\n * // Will decode into P.U32BE only if flag present\n * const optional = P.optional(P.flag(new Uint8Array([0x0, 0x1])), P.U32BE);\n *\n * @example\n * // If no flag present, will decode into default value\n * const optionalWithDefault = P.optional(P.flag(new Uint8Array([0x0, 0x1])), P.U32BE, 123);\n */\nexport function optional<T>(\n  flag: CoderType<boolean>,\n  inner: CoderType<T>,\n  def?: T\n): CoderType<Option<T>> {\n  if (!isCoder(flag) || !isCoder(inner))\n    throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n  return wrap({\n    size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n    encodeStream: (w: Writer, value: Option<T>) => {\n      flag.encodeStream(w, !!value);\n      if (value) inner.encodeStream(w, value);\n      else if (def !== undefined) inner.encodeStream(w, def);\n    },\n    decodeStream: (r: Reader): Option<T> => {\n      if (flag.decodeStream(r)) return inner.decodeStream(r);\n      else if (def !== undefined) inner.decodeStream(r);\n      return;\n    },\n  });\n}\n/**\n * Magic value CoderType that encodes/decodes a constant value.\n * This can be used to check for a specific magic value or sequence of bytes at the beginning of a data structure.\n * @param inner - Inner CoderType for the value.\n * @param constant - Constant value.\n * @param check - Whether to check the decoded value against the constant.\n * @returns CoderType representing the magic value.\n * @example\n * // Always encodes constant as bytes using inner CoderType, throws if encoded value is not present\n * const magicU8 = P.magic(P.U8, 0x42);\n */\nexport function magic<T>(inner: CoderType<T>, constant: T, check = true): CoderType<undefined> {\n  if (!isCoder(inner)) throw new Error(`magic: invalid inner value ${inner}`);\n  if (typeof check !== 'boolean') throw new Error(`magic: expected boolean, got ${typeof check}`);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w: Writer, _value: undefined) => inner.encodeStream(w, constant),\n    decodeStream: (r: Reader): undefined => {\n      const value = inner.decodeStream(r);\n      if (\n        (check && typeof value !== 'object' && value !== constant) ||\n        (isBytes(constant) && !equalBytes(constant, value as any))\n      ) {\n        throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n      }\n      return;\n    },\n    validate: (value) => {\n      if (value !== undefined) throw new Error(`magic: wrong value=${typeof value}`);\n      return value;\n    },\n  });\n}\n/**\n * Magic bytes CoderType that encodes/decodes a constant byte array or string.\n * @param constant - Constant byte array or string.\n * @returns CoderType representing the magic bytes.\n * @example\n * // Always encodes undefined into byte representation of string 'MAGIC'\n * const magicBytes = P.magicBytes('MAGIC');\n */\nexport const magicBytes = (constant: Bytes | string): CoderType<undefined> => {\n  const c = typeof constant === 'string' ? utf8.decode(constant) : constant;\n  return magic(createBytes(c.length), c);\n};\n\n/**\n * Creates a CoderType for a constant value. The function enforces this value during encoding,\n * ensuring it matches the provided constant. During decoding, it always returns the constant value.\n * The actual value is not written to or read from any byte stream; it's used only for validation.\n *\n * @param c - Constant value.\n * @returns CoderType representing the constant value.\n * @example\n * // Always return 123 on decode, throws on encoding anything other than 123\n * const constantU8 = P.constant(123);\n */\nexport function constant<T>(c: T): CoderType<T> {\n  return wrap({\n    encodeStream: (_w: Writer, value: T) => {\n      if (value !== c) throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n    },\n    decodeStream: (_r: Reader): T => c,\n  });\n}\n\nfunction sizeof(fields: CoderType<any>[]): Option<number> {\n  let size: Option<number> = 0;\n  for (const f of fields) {\n    if (f.size === undefined) return;\n    if (!isNum(f.size)) throw new Error(`sizeof: wrong element size=${size}`);\n    size += f.size;\n  }\n  return size;\n}\n/**\n * Structure of composable primitives (C/Rust struct)\n * @param fields - Object mapping field names to CoderTypes.\n * @returns CoderType representing the structure.\n * @example\n * // Define a structure with a 32-bit big-endian unsigned integer, a string, and a nested structure\n * const myStruct = P.struct({\n *   id: P.U32BE,\n *   name: P.string(P.U8),\n *   nested: P.struct({\n *     flag: P.bool,\n *     value: P.I16LE\n *   })\n * });\n */\nexport function struct<T extends Record<string, any>>(\n  fields: StructRecord<T>\n): CoderType<StructInput<T>> {\n  if (!isPlainObject(fields)) throw new Error(`struct: expected plain object, got ${fields}`);\n  for (const name in fields) {\n    if (!isCoder(fields[name])) throw new Error(`struct: field ${name} is not CoderType`);\n  }\n  return wrap({\n    size: sizeof(Object.values(fields)),\n    encodeStream: (w: Writer, value: StructInput<T>) => {\n      (w as _Writer).pushObj(value, (fieldFn) => {\n        for (const name in fields)\n          fieldFn(name, () => fields[name].encodeStream(w, (value as T)[name]));\n      });\n    },\n    decodeStream: (r: Reader): StructInput<T> => {\n      const res: Partial<T> = {};\n      (r as _Reader).pushObj(res, (fieldFn) => {\n        for (const name in fields) fieldFn(name, () => (res[name] = fields[name].decodeStream(r)));\n      });\n      return res as T;\n    },\n    validate: (value) => {\n      if (typeof value !== 'object' || value === null)\n        throw new Error(`struct: invalid value ${value}`);\n      return value;\n    },\n  });\n}\n/**\n * Tuple (unnamed structure) of CoderTypes. Same as struct but with unnamed fields.\n * @param fields - Array of CoderTypes.\n * @returns CoderType representing the tuple.\n * @example\n * const myTuple = P.tuple([P.U8, P.U16LE, P.string(P.U8)]);\n */\nexport function tuple<\n  T extends ArrLike<CoderType<any>>,\n  O = Writable<{ [K in keyof T]: UnwrapCoder<T[K]> }>,\n>(fields: T): CoderType<O> {\n  if (!Array.isArray(fields))\n    throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n  for (let i = 0; i < fields.length; i++) {\n    if (!isCoder(fields[i])) throw new Error(`tuple: field ${i} is not CoderType`);\n  }\n  return wrap({\n    size: sizeof(fields),\n    encodeStream: (w: Writer, value: O) => {\n      // TODO: fix types\n      if (!Array.isArray(value)) throw w.err(`tuple: invalid value ${value}`);\n      (w as _Writer).pushObj(value, (fieldFn) => {\n        for (let i = 0; i < fields.length; i++)\n          fieldFn(`${i}`, () => fields[i].encodeStream(w, value[i]));\n      });\n    },\n    decodeStream: (r: Reader): O => {\n      const res: any = [];\n      (r as _Reader).pushObj(res, (fieldFn) => {\n        for (let i = 0; i < fields.length; i++)\n          fieldFn(`${i}`, () => res.push(fields[i].decodeStream(r)));\n      });\n      return res;\n    },\n    validate: (value) => {\n      if (!Array.isArray(value)) throw new Error(`tuple: invalid value ${value}`);\n      if (value.length !== fields.length)\n        throw new Error(`tuple: wrong length=${value.length}, expected ${fields.length}`);\n      return value;\n    },\n  });\n}\n\n/**\n * Array of items (inner type) with a specified length.\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param inner - CoderType for encoding/decoding each array item.\n * @returns CoderType representing the array.\n * @example\n * const a1 = P.array(P.U16BE, child); // Dynamic size array (prefixed with P.U16BE number of array length)\n * const a2 = P.array(4, child); // Fixed size array\n * const a3 = P.array(null, child); // Unknown size array, will parse until end of buffer\n * const a4 = P.array(new Uint8Array([0]), child); // zero-terminated array (NOTE: terminator can be any buffer)\n */\nexport function array<T>(len: Length, inner: CoderType<T>): CoderType<T[]> {\n  if (!isCoder(inner)) throw new Error(`array: invalid inner value ${inner}`);\n  // By construction length is inside array (otherwise there will be various incorrect stack states)\n  // But forcing users always write '..' seems like bad idea. Also, breaking change.\n  const _length = lengthCoder(typeof len === 'string' ? `../${len}` : len);\n  return wrap({\n    size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n    encodeStream: (w: Writer, value: T[]) => {\n      const _w = w as _Writer;\n      _w.pushObj(value, (fieldFn) => {\n        if (!isBytes(len)) _length.encodeStream(w, value.length);\n        for (let i = 0; i < value.length; i++) {\n          fieldFn(`${i}`, () => {\n            const elm = value[i];\n            const startPos = (w as _Writer).pos;\n            inner.encodeStream(w, elm);\n            if (isBytes(len)) {\n              // Terminator is bigger than elm size, so skip\n              if (len.length > _w.pos - startPos) return;\n              const data = _w.finish(false).subarray(startPos, _w.pos);\n              // There is still possible case when multiple elements create terminator,\n              // but it is hard to catch here, will be very slow\n              if (equalBytes(data.subarray(0, len.length), len))\n                throw _w.err(\n                  `array: inner element encoding same as separator. elm=${elm} data=${data}`\n                );\n            }\n          });\n        }\n      });\n      if (isBytes(len)) w.bytes(len);\n    },\n    decodeStream: (r: Reader): T[] => {\n      const res: T[] = [];\n      (r as _Reader).pushObj(res, (fieldFn) => {\n        if (len === null) {\n          for (let i = 0; !r.isEnd(); i++) {\n            fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n            if (inner.size && r.leftBytes < inner.size) break;\n          }\n        } else if (isBytes(len)) {\n          for (let i = 0; ; i++) {\n            if (equalBytes(r.bytes(len.length, true), len)) {\n              // Advance cursor position if terminator found\n              r.bytes(len.length);\n              break;\n            }\n            fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n          }\n        } else {\n          let length: number;\n          fieldFn('arrayLen', () => (length = _length.decodeStream(r)));\n          for (let i = 0; i < length!; i++) fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n        }\n      });\n      return res;\n    },\n    validate: (value) => {\n      if (!Array.isArray(value)) throw new Error(`array: invalid value ${value}`);\n      return value;\n    },\n  });\n}\n/**\n * Mapping between encoded values and string representations.\n * @param inner - CoderType for encoded values.\n * @param variants - Object mapping string representations to encoded values.\n * @returns CoderType representing the mapping.\n * @example\n * // Map between numbers and strings\n * const numberMap = P.map(P.U8, {\n *   'one': 1,\n *   'two': 2,\n *   'three': 3\n * });\n *\n * // Map between byte arrays and strings\n * const byteMap = P.map(P.bytes(2, false), {\n *   'ab': Uint8Array.from([0x61, 0x62]),\n *   'cd': Uint8Array.from([0x63, 0x64])\n * });\n */\nexport function map<T>(inner: CoderType<T>, variants: Record<string, T>): CoderType<string> {\n  if (!isCoder(inner)) throw new Error(`map: invalid inner value ${inner}`);\n  if (!isPlainObject(variants)) throw new Error(`map: variants should be plain object`);\n  const variantNames: Map<T, string> = new Map();\n  for (const k in variants) variantNames.set(variants[k], k);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w: Writer, value: string) => inner.encodeStream(w, variants[value]),\n    decodeStream: (r: Reader): string => {\n      const variant = inner.decodeStream(r);\n      const name = variantNames.get(variant);\n      if (name === undefined)\n        throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n      return name;\n    },\n    validate: (value) => {\n      if (typeof value !== 'string') throw new Error(`map: invalid value ${value}`);\n      if (!(value in variants)) throw new Error(`Map: unknown variant: ${value}`);\n      return value;\n    },\n  });\n}\n/**\n * Tagged union of CoderTypes, where the tag value determines which CoderType to use.\n * The decoded value will have the structure `{ TAG: number, data: ... }`.\n * @param tag - CoderType for the tag value.\n * @param variants - Object mapping tag values to CoderTypes.\n * @returns CoderType representing the tagged union.\n * @example\n * // Tagged union of array, string, and number\n * // Depending on the value of the first byte, it will be decoded as an array, string, or number.\n * const taggedUnion = P.tag(P.U8, {\n *   0x01: P.array(P.U16LE, P.U8),\n *   0x02: P.string(P.U8),\n *   0x03: P.U32BE\n * });\n *\n * const encoded = taggedUnion.encode({ TAG: 0x01, data: 'hello' }); // Encodes the string 'hello' with tag 0x01\n * const decoded = taggedUnion.decode(encoded); // Decodes the encoded value back to { TAG: 0x01, data: 'hello' }\n */\nexport function tag<\n  T extends Values<{\n    [P in keyof Variants]: { TAG: P; data: UnwrapCoder<Variants[P]> };\n  }>,\n  TagValue extends string | number,\n  Variants extends Record<TagValue, CoderType<any>>,\n>(tag: CoderType<TagValue>, variants: Variants): CoderType<T> {\n  if (!isCoder(tag)) throw new Error(`tag: invalid tag value ${tag}`);\n  if (!isPlainObject(variants)) throw new Error(`tag: variants should be plain object`);\n  for (const name in variants) {\n    if (!isCoder(variants[name])) throw new Error(`tag: variant ${name} is not CoderType`);\n  }\n  return wrap({\n    size: tag.size,\n    encodeStream: (w: Writer, value: T) => {\n      const { TAG, data } = value;\n      const dataType = variants[TAG];\n      tag.encodeStream(w, TAG as any);\n      dataType.encodeStream(w, data);\n    },\n    decodeStream: (r: Reader): T => {\n      const TAG = tag.decodeStream(r);\n      const dataType = variants[TAG];\n      if (!dataType) throw r.err(`Tag: invalid tag ${TAG}`);\n      return { TAG, data: dataType.decodeStream(r) } as any;\n    },\n    validate: (value) => {\n      const { TAG } = value;\n      const dataType = variants[TAG];\n      if (!dataType) throw new Error(`Tag: invalid tag ${TAG.toString()}`);\n      return value;\n    },\n  });\n}\n\n/**\n * Mapping between encoded values, string representations, and CoderTypes using a tag CoderType.\n * @param tagCoder - CoderType for the tag value.\n * @param variants - Object mapping string representations to [tag value, CoderType] pairs.\n *  * @returns CoderType representing the mapping.\n * @example\n * const cborValue: P.CoderType<CborValue> = P.mappedTag(P.bits(3), {\n *   uint: [0, cborUint], // An unsigned integer in the range 0..264-1 inclusive.\n *   negint: [1, cborNegint], // A negative integer in the range -264..-1 inclusive\n *   bytes: [2, P.lazy(() => cborLength(P.bytes, cborValue))], // A byte string.\n *   string: [3, P.lazy(() => cborLength(P.string, cborValue))], // A text string (utf8)\n *   array: [4, cborArrLength(P.lazy(() => cborValue))], // An array of data items\n *   map: [5, P.lazy(() => cborArrLength(P.tuple([cborValue, cborValue])))], // A map of pairs of data items\n *   tag: [6, P.tuple([cborUint, P.lazy(() => cborValue)] as const)], // A tagged data item (\"tag\") whose tag number\n *   simple: [7, cborSimple], // Floating-point numbers and simple values, as well as the \"break\" stop code\n * });\n */\nexport function mappedTag<\n  T extends Values<{\n    [P in keyof Variants]: { TAG: P; data: UnwrapCoder<Variants[P][1]> };\n  }>,\n  TagValue extends string | number,\n  Variants extends Record<string, [TagValue, CoderType<any>]>,\n>(tagCoder: CoderType<TagValue>, variants: Variants): CoderType<T> {\n  if (!isCoder(tagCoder)) throw new Error(`mappedTag: invalid tag value ${tag}`);\n  if (!isPlainObject(variants)) throw new Error(`mappedTag: variants should be plain object`);\n  const mapValue: Record<string, TagValue> = {};\n  const tagValue: Record<string, CoderType<any>> = {};\n  for (const key in variants) {\n    const v = variants[key];\n    mapValue[key] = v[0];\n    tagValue[key] = v[1];\n  }\n  return tag(map(tagCoder, mapValue), tagValue) as any as CoderType<T>;\n}\n\n/**\n * Bitset of boolean values with optional padding.\n * @param names - An array of string names for the bitset values.\n * @param pad - Whether to pad the bitset to a multiple of 8 bits.\n * @returns CoderType representing the bitset.\n * @template Names\n * @example\n * const myBitset = P.bitset(['flag1', 'flag2', 'flag3', 'flag4'], true);\n */\nexport function bitset<Names extends readonly string[]>(\n  names: Names,\n  pad = false\n): CoderType<Record<Names[number], boolean>> {\n  if (typeof pad !== 'boolean') throw new Error(`bitset/pad: expected boolean, got ${typeof pad}`);\n  if (!Array.isArray(names)) throw new Error('bitset/names: expected array');\n  for (const name of names) {\n    if (typeof name !== 'string') throw new Error('bitset/names: expected array of strings');\n  }\n  return wrap({\n    encodeStream: (w: Writer, value: Record<Names[number], boolean>) => {\n      for (let i = 0; i < names.length; i++) w.bits(+(value as any)[names[i]], 1);\n      if (pad && names.length % 8) w.bits(0, 8 - (names.length % 8));\n    },\n    decodeStream: (r: Reader): Record<Names[number], boolean> => {\n      const out: Record<string, boolean> = {};\n      for (let i = 0; i < names.length; i++) out[names[i]] = !!r.bits(1);\n      if (pad && names.length % 8) r.bits(8 - (names.length % 8));\n      return out;\n    },\n    validate: (value) => {\n      if (!isPlainObject(value)) throw new Error(`bitset: invalid value ${value}`);\n      for (const v of Object.values(value)) {\n        if (typeof v !== 'boolean') throw new Error('expected boolean');\n      }\n      return value;\n    },\n  });\n}\n/** Padding function which always returns zero */\nexport const ZeroPad: PadFn = (_) => 0;\n\nfunction padLength(blockSize: number, len: number): number {\n  if (len % blockSize === 0) return 0;\n  return blockSize - (len % blockSize);\n}\n/**\n * Pads a CoderType with a specified block size and padding function on the left side.\n * @param blockSize - Block size for padding (positive safe integer).\n * @param inner - Inner CoderType to pad.\n * @param padFn - Padding function to use. If not provided, zero padding is used.\n * @returns CoderType representing the padded value.\n * @example\n * // Pad a U32BE with a block size of 4 and zero padding\n * const paddedU32BE = P.padLeft(4, P.U32BE);\n *\n * // Pad a string with a block size of 16 and custom padding\n * const paddedString = P.padLeft(16, P.string(P.U8), (i) => i + 1);\n */\nexport function padLeft<T>(\n  blockSize: number,\n  inner: CoderType<T>,\n  padFn: Option<PadFn>\n): CoderType<T> {\n  if (!isNum(blockSize) || blockSize <= 0) throw new Error(`padLeft: wrong blockSize=${blockSize}`);\n  if (!isCoder(inner)) throw new Error(`padLeft: invalid inner value ${inner}`);\n  if (padFn !== undefined && typeof padFn !== 'function')\n    throw new Error(`padLeft: wrong padFn=${typeof padFn}`);\n  const _padFn = padFn || ZeroPad;\n  if (!inner.size) throw new Error('padLeft cannot have dynamic size');\n  return wrap({\n    size: inner.size + padLength(blockSize, inner.size),\n    encodeStream: (w: Writer, value: T) => {\n      const padBytes = padLength(blockSize, inner.size!);\n      for (let i = 0; i < padBytes; i++) w.byte(_padFn(i));\n      inner.encodeStream(w, value);\n    },\n    decodeStream: (r: Reader): T => {\n      r.bytes(padLength(blockSize, inner.size!));\n      return inner.decodeStream(r);\n    },\n  });\n}\n/**\n * Pads a CoderType with a specified block size and padding function on the right side.\n * @param blockSize - Block size for padding (positive safe integer).\n * @param inner - Inner CoderType to pad.\n * @param padFn - Padding function to use. If not provided, zero padding is used.\n * @returns CoderType representing the padded value.\n * @example\n * // Pad a U16BE with a block size of 2 and zero padding\n * const paddedU16BE = P.padRight(2, P.U16BE);\n *\n * // Pad a bytes with a block size of 8 and custom padding\n * const paddedBytes = P.padRight(8, P.bytes(null), (i) => i + 1);\n */\nexport function padRight<T>(\n  blockSize: number,\n  inner: CoderType<T>,\n  padFn: Option<PadFn>\n): CoderType<T> {\n  if (!isCoder(inner)) throw new Error(`padRight: invalid inner value ${inner}`);\n  if (!isNum(blockSize) || blockSize <= 0) throw new Error(`padLeft: wrong blockSize=${blockSize}`);\n  if (padFn !== undefined && typeof padFn !== 'function')\n    throw new Error(`padRight: wrong padFn=${typeof padFn}`);\n  const _padFn = padFn || ZeroPad;\n  return wrap({\n    size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n    encodeStream: (w: Writer, value: T) => {\n      const _w = w as _Writer;\n      const pos = _w.pos;\n      inner.encodeStream(w, value);\n      const padBytes = padLength(blockSize, _w.pos - pos);\n      for (let i = 0; i < padBytes; i++) w.byte(_padFn(i));\n    },\n    decodeStream: (r: Reader): T => {\n      const start = r.pos;\n      const res = inner.decodeStream(r);\n      r.bytes(padLength(blockSize, r.pos - start));\n      return res;\n    },\n  });\n}\n1;\n/**\n * Pointer to a value using a pointer CoderType and an inner CoderType.\n * Pointers are scoped, and the next pointer in the dereference chain is offset by the previous one.\n * By default (if no 'allowMultipleReads' in ReaderOpts is set) is safe, since\n * same region of memory cannot be read multiple times.\n * @param ptr - CoderType for the pointer value.\n * @param inner - CoderType for encoding/decoding the pointed value.\n * @param sized - Whether the pointer should have a fixed size.\n * @returns CoderType representing the pointer to the value.\n * @example\n * const pointerToU8 = P.pointer(P.U16BE, P.U8); // Pointer to a single U8 value\n */\nexport function pointer<T>(\n  ptr: CoderType<number>,\n  inner: CoderType<T>,\n  sized = false\n): CoderType<T> {\n  if (!isCoder(ptr)) throw new Error(`pointer: invalid ptr value ${ptr}`);\n  if (!isCoder(inner)) throw new Error(`pointer: invalid inner value ${inner}`);\n  if (typeof sized !== 'boolean')\n    throw new Error(`pointer/sized: expected boolean, got ${typeof sized}`);\n  if (!ptr.size) throw new Error('unsized pointer');\n  return wrap({\n    size: sized ? ptr.size : undefined,\n    encodeStream: (w: Writer, value: T) => {\n      const _w = w as _Writer;\n      const start = _w.pos;\n      ptr.encodeStream(w, 0);\n      _w.ptrs.push({ pos: start, ptr, buffer: inner.encode(value) });\n    },\n    decodeStream: (r: Reader): T => {\n      const ptrVal = ptr.decodeStream(r);\n      (r as _Reader)._enablePointers();\n      return inner.decodeStream(r.offsetReader(ptrVal));\n    },\n  });\n}\n\n// Internal methods for test purposes only\nexport const _TEST: {\n  _bitset: {\n    BITS: number;\n    FULL_MASK: number;\n    len: (len: number) => number;\n    create: (len: number) => Uint32Array;\n    clean: (bs: Uint32Array) => Uint32Array;\n    debug: (bs: Uint32Array) => string[];\n    checkLen: (bs: Uint32Array, len: number) => void;\n    chunkLen: (bsLen: number, pos: number, len: number) => void;\n    set: (bs: Uint32Array, chunk: number, value: number, allowRewrite?: boolean) => boolean;\n    pos: (\n      pos: number,\n      i: number\n    ) => {\n      chunk: number;\n      mask: number;\n    };\n    indices: (bs: Uint32Array, len: number, invert?: boolean) => number[];\n    range: (arr: number[]) => {\n      pos: number;\n      length: number;\n    }[];\n    rangeDebug: (bs: Uint32Array, len: number, invert?: boolean) => string;\n    setRange: (\n      bs: Uint32Array,\n      bsLen: number,\n      pos: number,\n      len: number,\n      allowRewrite?: boolean\n    ) => boolean;\n  };\n  _Reader: typeof _Reader;\n  _Writer: typeof _Writer;\n  Path: {\n    /**\n     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)\n     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).\n     * Also, this makes impossible:\n     * - pushing field when stack is empty\n     * - pushing field inside of field (real bug)\n     * NOTE: we don't want to do '.pop' on error!\n     */\n    pushObj: (stack: PathStack, obj: StructOut, objFn: _PathObjFn) => void;\n    path: (stack: PathStack) => string;\n    err(name: string, stack: PathStack, msg: string | Error): Error;\n    resolve: (stack: PathStack, path: string) => StructOut | undefined;\n  };\n} = { _bitset: Bitset, _Reader, _Writer, Path };\n", "import { schnorr, secp256k1 as secp } from '@noble/curves/secp256k1.js';\nimport { ripemd160 } from '@noble/hashes/legacy.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { utils as packedUtils, U32LE } from 'micro-packed';\n\nexport type Hex = string | Uint8Array;\nexport type Bytes = Uint8Array;\nconst Point = secp.ProjectivePoint;\nconst CURVE_ORDER = secp.CURVE.n;\n\nconst isBytes: (a: unknown) => a is Uint8Array = packedUtils.isBytes;\nconst concatBytes: (...arrays: Uint8Array[]) => Uint8Array = packedUtils.concatBytes;\nconst equalBytes: (a: Uint8Array, b: Uint8Array) => boolean = packedUtils.equalBytes;\nexport { concatBytes, equalBytes, isBytes, sha256 };\n\nexport const hash160 = (msg: Uint8Array): Uint8Array => ripemd160(sha256(msg));\nexport const sha256x2 = (...msgs: Uint8Array[]): Uint8Array => sha256(sha256(concatBytes(...msgs)));\nexport const randomPrivateKeyBytes: () => Uint8Array = schnorr.utils.randomPrivateKey;\nexport const pubSchnorr = schnorr.getPublicKey as (priv: string | Uint8Array) => Uint8Array;\nexport const pubECDSA: (privateKey: string | Uint8Array, isCompressed?: boolean) => Uint8Array =\n  secp.getPublicKey;\n\n// low-r signature grinding. Used to reduce tx size by 1 byte.\n// noble/secp256k1 does not support the feature: it is not used outside of BTC.\n// We implement it manually, because in BTC it's common.\n// Not best way, but closest to bitcoin implementation (easier to check)\nconst hasLowR = (sig: { r: bigint; s: bigint }) => sig.r < CURVE_ORDER / 2n;\nexport function signECDSA(hash: Bytes, privateKey: Bytes, lowR = false): Bytes {\n  let sig = secp.sign(hash, privateKey);\n  if (lowR && !hasLowR(sig)) {\n    const extraEntropy = new Uint8Array(32);\n    let counter = 0;\n    while (!hasLowR(sig)) {\n      extraEntropy.set(U32LE.encode(counter++));\n      sig = secp.sign(hash, privateKey, { extraEntropy });\n      if (counter > 4294967295) throw new Error('lowR counter overflow: report the error');\n    }\n  }\n  return sig.toDERRawBytes();\n}\n\nexport const signSchnorr: typeof schnorr.sign = schnorr.sign;\nexport const tagSchnorr: typeof schnorr.utils.taggedHash = schnorr.utils.taggedHash;\n\nexport enum PubT {\n  ecdsa,\n  schnorr,\n}\nexport function validatePubkey(pub: Bytes, type: PubT): Bytes {\n  const len = pub.length;\n  if (type === PubT.ecdsa) {\n    if (len === 32) throw new Error('Expected non-Schnorr key');\n    Point.fromHex(pub); // does assertValidity\n    return pub;\n  } else if (type === PubT.schnorr) {\n    if (len !== 32) throw new Error('Expected 32-byte Schnorr key');\n    schnorr.utils.lift_x(schnorr.utils.bytesToNumberBE(pub));\n    return pub;\n  } else {\n    throw new Error('Unknown key type');\n  }\n}\n\nexport function tapTweak(a: Bytes, b: Bytes): bigint {\n  const u = schnorr.utils;\n  const t = u.taggedHash('TapTweak', a, b);\n  const tn = u.bytesToNumberBE(t);\n  if (tn >= CURVE_ORDER) throw new Error('tweak higher than curve order');\n  return tn;\n}\n\nexport function taprootTweakPrivKey(privKey: Bytes, merkleRoot: Bytes = Uint8Array.of()): Bytes {\n  const u = schnorr.utils;\n  const seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)\n  const P = Point.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)\n  // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n  const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n  const xP = u.pointToBytes(P);\n  // t = int_from_bytes(tagged_hash(\"TapTweak\", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check\n  const t = tapTweak(xP, merkleRoot);\n  // bytes_from_int((seckey + t) % SECP256K1_ORDER)\n  return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\n\nexport function taprootTweakPubkey(pubKey: Bytes, h: Bytes): [Bytes, number] {\n  const u = schnorr.utils;\n  const t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash(\"TapTweak\", pubkey + h))\n  const P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))\n  const Q = P.add(Point.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))\n  const parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1\n  return [u.pointToBytes(Q), parity]; // bytes_from_int(x(Q))\n}\n\n// Another stupid decision, where lack of standard affects security.\n// Multisig needs to be generated with some key.\n// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))\n// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;\n// but it's too complex to prove.\n// Also used by bitcoin-core and bitcoinjs-lib\nexport const TAPROOT_UNSPENDABLE_KEY: Bytes = sha256(Point.BASE.toRawBytes(false));\n\nexport type BTC_NETWORK = {\n  bech32: string;\n  pubKeyHash: number;\n  scriptHash: number;\n  wif: number;\n};\nexport const NETWORK: BTC_NETWORK = {\n  bech32: 'bc',\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80,\n};\n\nexport const TEST_NETWORK: BTC_NETWORK = {\n  bech32: 'tb',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n\n// Exported for tests, internal method\nexport function compareBytes(a: Bytes, b: Bytes): number {\n  if (!isBytes(a) || !isBytes(b)) throw new Error(`cmp: wrong type a=${typeof a} b=${typeof b}`);\n  // -1 -> a<b, 0 -> a==b, 1 -> a>b\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) if (a[i] != b[i]) return Math.sign(a[i] - b[i]);\n  return Math.sign(a.length - b.length);\n}\n", "import * as P from 'micro-packed';\nimport { isBytes } from './utils.ts';\n\nexport const MAX_SCRIPT_BYTE_LENGTH = 520;\n\n// prettier-ignore\nexport enum OP {\n  OP_0 = 0x00, PUSHDATA1 = 0x4c, PUSHDATA2, PUSHDATA4, '1NEGATE',\n  RESERVED = 0x50,\n  OP_1, OP_2, OP_3, OP_4, OP_5, OP_6, OP_7, OP_8,\n  OP_9, OP_10, OP_11, OP_12, OP_13, OP_14, OP_15, OP_16,\n  // Control\n  NOP, VER, IF, NOTIF, VERIF, VERNOTIF, ELSE, ENDIF, VERIFY, RETURN,\n  // Stack\n  TOALTSTACK, FROMALTSTACK, '2DROP', '2DUP', '3DUP', '2OVER', '2ROT', '2SWAP',\n  IFDUP, DEPTH, DROP, DUP, NIP, OVER, PICK, ROLL, ROT, SWAP, TUCK,\n  // Splice\n  CAT, SUBSTR, LEFT, RIGHT, SIZE,\n  // Boolean logic\n  INVERT, AND, OR, XOR, EQUAL, EQUALVERIFY, RESERVED1, RESERVED2,\n  // Numbers\n  '1ADD', '1SUB', '2MUL', '2DIV',\n  NEGATE, ABS, NOT, '0NOTEQUAL',\n  ADD, SUB, MUL, DIV, MOD, LSHIFT, RSHIFT, BOOLAND, BOOLOR,\n  NUMEQUAL, NUMEQUALVERIFY, NUMNOTEQUAL, LESSTHAN, GREATERTHAN,\n  LESSTHANOREQUAL, GREATERTHANOREQUAL, MIN, MAX, WITHIN,\n  // Crypto\n  RIPEMD160, SHA1, SHA256, HASH160, HASH256, CODESEPARATOR,\n  CHECKSIG, CHECKSIGVERIFY, CHECKMULTISIG, CHECKMULTISIGVERIFY,\n  // Expansion\n  NOP1, CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY, NOP4, NOP5, NOP6, NOP7, NOP8, NOP9, NOP10,\n  // BIP 342\n  CHECKSIGADD,\n  // Invalid\n  INVALID = 0xff,\n}\n\nexport type ScriptOP = keyof typeof OP | Uint8Array | number;\nexport type ScriptType = ScriptOP[];\n\n// We can encode almost any number as ScriptNum, however, parsing will be a problem\n// since we can't know if buffer is a number or something else.\nexport function ScriptNum(bytesLimit = 6, forceMinimal = false): P.CoderType<bigint> {\n  return P.wrap({\n    encodeStream: (w: P.Writer, value: bigint) => {\n      if (value === 0n) return;\n      const neg = value < 0;\n      const val = BigInt(value);\n      const nums = [];\n      for (let abs = neg ? -val : val; abs; abs >>= 8n) nums.push(Number(abs & 0xffn));\n      if (nums[nums.length - 1] >= 0x80) nums.push(neg ? 0x80 : 0);\n      else if (neg) nums[nums.length - 1] |= 0x80;\n      w.bytes(new Uint8Array(nums));\n    },\n    decodeStream: (r: P.Reader): bigint => {\n      const len = r.leftBytes;\n      if (len > bytesLimit)\n        throw new Error(`ScriptNum: number (${len}) bigger than limit=${bytesLimit}`);\n      if (len === 0) return 0n;\n      if (forceMinimal) {\n        const data = r.bytes(len, true);\n        // MSB is zero (without sign bit) -> not minimally encoded\n        if ((data[data.length - 1] & 0x7f) === 0) {\n          // exception\n          if (len <= 1 || (data[data.length - 2] & 0x80) === 0)\n            throw new Error('Non-minimally encoded ScriptNum');\n        }\n      }\n      let last = 0;\n      let res = 0n;\n      for (let i = 0; i < len; ++i) {\n        last = r.byte();\n        res |= BigInt(last) << (8n * BigInt(i));\n      }\n      if (last >= 0x80) {\n        res &= (2n ** BigInt(len * 8) - 1n) >> 1n;\n        res = -res;\n      }\n      return res;\n    },\n  });\n}\n\nexport function OpToNum(op: ScriptOP, bytesLimit = 4, forceMinimal = true): number | undefined {\n  if (typeof op === 'number') return op;\n  if (isBytes(op)) {\n    try {\n      const val = ScriptNum(bytesLimit, forceMinimal).decode(op);\n      if (val > Number.MAX_SAFE_INTEGER) return;\n      return Number(val);\n    } catch (e) {\n      return;\n    }\n  }\n  return;\n}\n\n// Converts script bytes to parsed script\n// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae\n// =>\n// OP_2\n//   030000000000000000000000000000000000000000000000000000000000000001\n//   030000000000000000000000000000000000000000000000000000000000000002\n//   030000000000000000000000000000000000000000000000000000000000000003\n//   OP_3\n//   CHECKMULTISIG\nexport const Script: P.CoderType<ScriptType> = P.wrap({\n  encodeStream: (w: P.Writer, value: ScriptType) => {\n    for (let o of value) {\n      if (typeof o === 'string') {\n        if (OP[o] === undefined) throw new Error(`Unknown opcode=${o}`);\n        w.byte(OP[o]);\n        continue;\n      } else if (typeof o === 'number') {\n        if (o === 0x00) {\n          w.byte(0x00);\n          continue;\n        } else if (1 <= o && o <= 16) {\n          w.byte(OP.OP_1 - 1 + o);\n          continue;\n        }\n      }\n      // Encode big numbers\n      if (typeof o === 'number') o = ScriptNum().encode(BigInt(o));\n      if (!isBytes(o)) throw new Error(`Wrong Script OP=${o} (${typeof o})`);\n      // Bytes\n      const len = o.length;\n      if (len < OP.PUSHDATA1) w.byte(len);\n      else if (len <= 0xff) {\n        w.byte(OP.PUSHDATA1);\n        w.byte(len);\n      } else if (len <= 0xffff) {\n        w.byte(OP.PUSHDATA2);\n        w.bytes(P.U16LE.encode(len));\n      } else {\n        w.byte(OP.PUSHDATA4);\n        w.bytes(P.U32LE.encode(len));\n      }\n      w.bytes(o);\n    }\n  },\n  decodeStream: (r: P.Reader): ScriptType => {\n    const out: ScriptType = [];\n    while (!r.isEnd()) {\n      const cur = r.byte();\n      // if 0 < cur < 78\n      if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {\n        let len;\n        if (cur < OP.PUSHDATA1) len = cur;\n        else if (cur === OP.PUSHDATA1) len = P.U8.decodeStream(r);\n        else if (cur === OP.PUSHDATA2) len = P.U16LE.decodeStream(r);\n        else if (cur === OP.PUSHDATA4) len = P.U32LE.decodeStream(r);\n        else throw new Error('Should be not possible');\n        out.push(r.bytes(len));\n      } else if (cur === 0x00) {\n        out.push(0);\n      } else if (OP.OP_1 <= cur && cur <= OP.OP_16) {\n        out.push(cur - (OP.OP_1 - 1));\n      } else {\n        const op = OP[cur] as keyof typeof OP;\n        if (op === undefined) throw new Error(`Unknown opcode=${cur.toString(16)}`);\n        out.push(op);\n      }\n    }\n    return out;\n  },\n});\n\n// BTC specific variable length integer encoding\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nconst CSLimits: Record<number, [number, number, bigint, bigint]> = {\n  0xfd: [0xfd, 2, 253n, 65535n],\n  0xfe: [0xfe, 4, 65536n, 4294967295n],\n  0xff: [0xff, 8, 4294967296n, 18446744073709551615n],\n};\nexport const CompactSize: P.CoderType<bigint> = P.wrap({\n  encodeStream: (w: P.Writer, value: bigint) => {\n    if (typeof value === 'number') value = BigInt(value);\n    if (0n <= value && value <= 252n) return w.byte(Number(value));\n    for (const [flag, bytes, start, stop] of Object.values(CSLimits)) {\n      if (start > value || value > stop) continue;\n      w.byte(flag);\n      for (let i = 0; i < bytes; i++) w.byte(Number((value >> (8n * BigInt(i))) & 0xffn));\n      return;\n    }\n    throw w.err(`VarInt too big: ${value}`);\n  },\n  decodeStream: (r: P.Reader): bigint => {\n    const b0 = r.byte();\n    if (b0 <= 0xfc) return BigInt(b0);\n    const [_, bytes, start] = CSLimits[b0];\n    let num = 0n;\n    for (let i = 0; i < bytes; i++) num |= BigInt(r.byte()) << (8n * BigInt(i));\n    if (num < start) throw r.err(`Wrong CompactSize(${8 * bytes})`);\n    return num;\n  },\n});\n\n// Same thing, but in number instead of bigint. Checks for safe integer inside\nexport const CompactSizeLen: P.CoderType<number> = P.apply(CompactSize, P.coders.numberBigint);\n\n// ui8a of size <CompactSize>\nexport const VarBytes: P.CoderType<Uint8Array> = P.bytes(CompactSize);\n\n// SegWit v0 stack of witness buffers\nexport const RawWitness: P.CoderType<Uint8Array[]> = P.array(CompactSizeLen, VarBytes);\n\n// Array of size <CompactSize>\nexport const BTCArray = <T>(t: P.CoderType<T>): P.CoderType<T[]> => P.array(CompactSize, t);\n\nexport const RawInput = P.struct({\n  txid: P.bytes(32, true), // hash(prev_tx),\n  index: P.U32LE, // output number of previous tx\n  finalScriptSig: VarBytes, // btc merges input and output script, executes it. If ok = tx passes\n  sequence: P.U32LE, // ?\n});\n\nexport const RawOutput = P.struct({ amount: P.U64LE, script: VarBytes });\n\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\nconst _RawTx = P.struct({\n  version: P.I32LE,\n  segwitFlag: P.flag(new Uint8Array([0x00, 0x01])),\n  inputs: BTCArray(RawInput),\n  outputs: BTCArray(RawOutput),\n  witnesses: P.flagged('segwitFlag', P.array('inputs/length', RawWitness)),\n  // < 500000000\tBlock number at which this transaction is unlocked\n  // >= 500000000\tUNIX timestamp at which this transaction is unlocked\n  // Handled as part of PSBTv2\n  lockTime: P.U32LE,\n});\n\nfunction validateRawTx(tx: P.UnwrapCoder<typeof _RawTx>) {\n  if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length)\n    throw new Error('Segwit flag with empty witnesses array');\n  return tx;\n}\nexport const RawTx: typeof _RawTx = P.validate(_RawTx, validateRawTx);\n// Pre-SegWit serialization format (for PSBTv0)\nexport const RawOldTx = P.struct({\n  version: P.I32LE,\n  inputs: BTCArray(RawInput),\n  outputs: BTCArray(RawOutput),\n  lockTime: P.U32LE,\n});\n", "import { hex } from '@scure/base';\nimport * as P from 'micro-packed';\nimport {\n  CompactSize,\n  CompactSizeLen,\n  RawOldTx,\n  RawOutput,\n  RawTx,\n  RawWitness,\n  VarBytes,\n} from './script.ts';\nimport { type Bytes, compareBytes, equalBytes, PubT, validatePubkey } from './utils.ts';\n\n// PSBT BIP174, BIP370, BIP371\n\n// Can be 33 or 64 bytes\nconst PubKeyECDSA: P.CoderType<Uint8Array> = P.validate(P.bytes(null), (pub) =>\n  validatePubkey(pub, PubT.ecdsa)\n);\nconst PubKeySchnorr: P.CoderType<Uint8Array> = P.validate(P.bytes(32), (pub) =>\n  validatePubkey(pub, PubT.schnorr)\n);\nconst SignatureSchnorr: P.CoderType<Uint8Array> = P.validate(P.bytes(null), (sig) => {\n  if (sig.length !== 64 && sig.length !== 65)\n    throw new Error('Schnorr signature should be 64 or 65 bytes long');\n  return sig;\n});\n\nconst BIP32Der = P.struct({\n  fingerprint: P.U32BE,\n  path: P.array(null, P.U32LE),\n});\nconst TaprootBIP32Der = P.struct({\n  hashes: P.array(CompactSizeLen, P.bytes(32)),\n  der: BIP32Der,\n});\n// The 78 byte serialized extended public key as defined by BIP 32.\nconst GlobalXPUB = P.bytes(78);\nconst tapScriptSigKey = P.struct({ pubKey: PubKeySchnorr, leafHash: P.bytes(32) });\n\n// Complex structure for PSBT fields\n// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\nconst _TaprootControlBlock = P.struct({\n  version: P.U8, // With parity :(\n  internalKey: P.bytes(32),\n  merklePath: P.array(null, P.bytes(32)),\n});\nexport const TaprootControlBlock = P.validate(_TaprootControlBlock, (cb) => {\n  if (cb.merklePath.length > 128)\n    throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');\n  return cb;\n});\n\n// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*\nconst tapTree = P.array(\n  null,\n  P.struct({\n    depth: P.U8,\n    version: P.U8,\n    script: VarBytes,\n  })\n);\n\nconst BytesInf: P.CoderType<P.Bytes> = P.bytes(null); // Bytes will conflict with Bytes type\nconst Bytes20: P.CoderType<P.Bytes> = P.bytes(20);\nconst Bytes32: P.CoderType<P.Bytes> = P.bytes(32);\n// versionsRequiringExclusing = !versionsAllowsInclusion (as set)\n// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}\n// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize\n\n// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)\n// prettier-ignore\nexport const PSBTGlobal = {\n  unsignedTx:       [0x00, false,      RawOldTx,          [0], [0],    false],\n  xpub:             [0x01, GlobalXPUB, BIP32Der,       [],  [0, 2], false],\n  txVersion:        [0x02, false,      P.U32LE,        [2], [2],    false],\n  fallbackLocktime: [0x03, false,      P.U32LE,        [],  [2],    false],\n  inputCount:       [0x04, false,      CompactSizeLen, [2], [2],    false],\n  outputCount:      [0x05, false,      CompactSizeLen, [2], [2],    false],\n  txModifiable:     [0x06, false,      P.U8,           [],  [2],    false],   // TODO: bitfield\n  version:          [0xfb, false,      P.U32LE,        [],  [0, 2], false],\n  proprietary:      [0xfc, BytesInf,   BytesInf,       [],  [0, 2], false],\n} as const;\n// prettier-ignore\nexport const PSBTInput = {\n  nonWitnessUtxo:         [0x00, false,               RawTx,            [],  [0, 2], false],\n  witnessUtxo:            [0x01, false,               RawOutput,        [],  [0, 2], false],\n  partialSig:             [0x02, PubKeyECDSA,         BytesInf,         [],  [0, 2], false],\n  sighashType:            [0x03, false,               P.U32LE,          [],  [0, 2], false],\n  redeemScript:           [0x04, false,               BytesInf,         [],  [0, 2], false],\n  witnessScript:          [0x05, false,               BytesInf,         [],  [0, 2], false],\n  bip32Derivation:        [0x06, PubKeyECDSA,         BIP32Der,         [],  [0, 2], false],\n  finalScriptSig:         [0x07, false,               BytesInf,         [],  [0, 2], false],\n  finalScriptWitness:     [0x08, false,               RawWitness,       [],  [0, 2], false],\n  porCommitment:          [0x09, false,               BytesInf,         [],  [0, 2], false],\n  ripemd160:              [0x0a, Bytes20,             BytesInf,         [],  [0, 2], false],\n  sha256:                 [0x0b, Bytes32,             BytesInf,         [],  [0, 2], false],\n  hash160:                [0x0c, Bytes20,             BytesInf,         [],  [0, 2], false],\n  hash256:                [0x0d, Bytes32,             BytesInf,         [],  [0, 2], false],\n  txid:                   [0x0e, false,               Bytes32,          [2], [2],    true],\n  index:                  [0x0f, false,               P.U32LE,          [2], [2],    true],\n  sequence:               [0x10, false,               P.U32LE,          [],  [2],    true],\n  requiredTimeLocktime:   [0x11, false,               P.U32LE,          [],  [2],    false],\n  requiredHeightLocktime: [0x12, false,               P.U32LE,          [],  [2],    false],\n  tapKeySig:              [0x13, false,               SignatureSchnorr, [],  [0, 2], false],\n  tapScriptSig:           [0x14, tapScriptSigKey,     SignatureSchnorr, [],  [0, 2], false],\n  tapLeafScript:          [0x15, TaprootControlBlock, BytesInf,         [],  [0, 2], false],\n  tapBip32Derivation:     [0x16, Bytes32,             TaprootBIP32Der,  [],  [0, 2], false],\n  tapInternalKey:         [0x17, false,               PubKeySchnorr,    [],  [0, 2], false],\n  tapMerkleRoot:          [0x18, false,               Bytes32,          [],  [0, 2], false],\n  proprietary:            [0xfc, BytesInf,            BytesInf,         [],  [0, 2], false],\n} as const;\n// All other keys removed when finalizing\nexport const PSBTInputFinalKeys: (keyof TransactionInput)[] = [\n  'txid',\n  'sequence',\n  'index',\n  'witnessUtxo',\n  'nonWitnessUtxo',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'unknown',\n];\n\n// Can be modified even on signed input\nexport const PSBTInputUnsignedKeys: (keyof TransactionInput)[] = [\n  'partialSig',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'tapKeySig',\n  'tapScriptSig',\n];\n\n// prettier-ignore\nexport const PSBTOutput = {\n  redeemScript:       [0x00, false,         BytesInf,        [],  [0, 2], false],\n  witnessScript:      [0x01, false,         BytesInf,        [],  [0, 2], false],\n  bip32Derivation:    [0x02, PubKeyECDSA,   BIP32Der,        [],  [0, 2], false],\n  amount:             [0x03, false,         P.I64LE,         [2], [2],    true],\n  script:             [0x04, false,         BytesInf,        [2], [2],    true],\n  tapInternalKey:     [0x05, false,         PubKeySchnorr,   [],  [0, 2], false],\n  tapTree:            [0x06, false,         tapTree,         [],  [0, 2], false],\n  tapBip32Derivation: [0x07, PubKeySchnorr, TaprootBIP32Der, [],  [0, 2], false],\n  proprietary:        [0xfc, BytesInf,      BytesInf,        [],  [0, 2], false],\n} as const;\n\n// Can be modified even on signed input\nexport const PSBTOutputUnsignedKeys: (keyof typeof PSBTOutput)[] = [];\n\nconst PSBTKeyPair = P.array(\n  P.NULL,\n  P.struct({\n    //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)\n    key: P.prefix(CompactSizeLen, P.struct({ type: CompactSizeLen, key: P.bytes(null) })),\n    //  <value> := <valuelen> <valuedata>\n    value: P.bytes(CompactSizeLen),\n  })\n);\n\ntype PSBTKeyCoder = P.CoderType<any> | false;\n\ntype PSBTKeyMapInfo = Readonly<\n  [\n    number,\n    PSBTKeyCoder,\n    any,\n    readonly number[], // versionsRequiringInclusion\n    readonly number[], // versionsAllowsInclusion\n    boolean, // silentIgnore\n  ]\n>;\n\nfunction PSBTKeyInfo(info: PSBTKeyMapInfo) {\n  const [type, kc, vc, reqInc, allowInc, silentIgnore] = info;\n  return { type, kc, vc, reqInc, allowInc, silentIgnore };\n}\n\ntype PSBTKeyMap = Record<string, PSBTKeyMapInfo>;\n\nconst PSBTUnknownKey: P.CoderType<\n  P.StructInput<{\n    type: number;\n    key: Uint8Array;\n  }>\n> = P.struct({ type: CompactSizeLen, key: P.bytes(null) });\ntype PSBTUnknownFields = { unknown?: [P.UnwrapCoder<typeof PSBTUnknownKey>, Bytes][] };\nexport type PSBTKeyMapKeys<T extends PSBTKeyMap> = {\n  -readonly [K in keyof T]?: T[K][1] extends false\n    ? P.UnwrapCoder<T[K][2]>\n    : [P.UnwrapCoder<T[K][1]>, P.UnwrapCoder<T[K][2]>][];\n} & PSBTUnknownFields;\n// Key cannot be 'unknown', value coder cannot be array for elements with empty key\nfunction PSBTKeyMap<T extends PSBTKeyMap>(psbtEnum: T): P.CoderType<PSBTKeyMapKeys<T>> {\n  // -> Record<type, [keyName, ...coders]>\n  const byType: Record<number, [string, PSBTKeyCoder, P.CoderType<any>]> = {};\n  for (const k in psbtEnum) {\n    const [num, kc, vc] = psbtEnum[k];\n    byType[num] = [k, kc, vc];\n  }\n  return P.wrap({\n    encodeStream: (w: P.Writer, value: PSBTKeyMapKeys<T>) => {\n      let out: P.UnwrapCoder<typeof PSBTKeyPair> = [];\n      // Because we use order of psbtEnum, keymap is sorted here\n      for (const name in psbtEnum) {\n        const val = value[name];\n        if (val === undefined) continue;\n        const [type, kc, vc] = psbtEnum[name];\n        if (!kc) {\n          out.push({ key: { type, key: P.EMPTY }, value: vc.encode(val) });\n        } else {\n          // Low level interface, returns keys as is (with duplicates). Useful for debug\n          const kv: [Bytes, Bytes][] = val!.map(\n            ([k, v]: [P.UnwrapCoder<typeof kc>, P.UnwrapCoder<typeof vc>]) => [\n              kc.encode(k),\n              vc.encode(v),\n            ]\n          );\n          // sort by keys\n          kv.sort((a, b) => compareBytes(a[0], b[0]));\n          for (const [key, value] of kv) out.push({ key: { key, type }, value });\n        }\n      }\n      if (value.unknown) {\n        value.unknown.sort((a, b) => compareBytes(a[0].key, b[0].key));\n        for (const [k, v] of value.unknown) out.push({ key: k, value: v });\n      }\n      PSBTKeyPair.encodeStream(w, out);\n    },\n    decodeStream: (r: P.Reader): PSBTKeyMapKeys<T> => {\n      const raw = PSBTKeyPair.decodeStream(r);\n      const out: any = {};\n      const noKey: Record<string, true> = {};\n      for (const elm of raw) {\n        let name = 'unknown';\n        let key: any = elm.key.key;\n        let value = elm.value;\n        if (byType[elm.key.type]) {\n          const [_name, kc, vc] = byType[elm.key.type];\n          name = _name;\n          if (!kc && key.length) {\n            throw new Error(\n              `PSBT: Non-empty key for ${name} (key=${hex.encode(key)} value=${hex.encode(value)}`\n            );\n          }\n          key = kc ? kc.decode(key) : undefined;\n          value = vc.decode(value);\n          if (!kc) {\n            if (out[name]) throw new Error(`PSBT: Same keys: ${name} (key=${key} value=${value})`);\n            out[name] = value;\n            noKey[name] = true;\n            continue;\n          }\n        } else {\n          // For unknown: add key type inside key\n          key = { type: elm.key.type, key: elm.key.key };\n        }\n        // Only keyed elements at this point\n        if (noKey[name])\n          throw new Error(`PSBT: Key type with empty key and no key=${name} val=${value}`);\n        if (!out[name]) out[name] = [];\n        out[name].push([key, value]);\n      }\n      return out;\n    },\n  });\n}\n\nexport const PSBTInputCoder = P.validate(PSBTKeyMap(PSBTInput), (i) => {\n  if (i.finalScriptWitness && !i.finalScriptWitness.length)\n    throw new Error('validateInput: empty finalScriptWitness');\n  //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');\n  if (i.partialSig && !i.partialSig.length) throw new Error('Empty partialSig');\n  if (i.partialSig) for (const [k] of i.partialSig) validatePubkey(k, PubT.ecdsa);\n  if (i.bip32Derivation) for (const [k] of i.bip32Derivation) validatePubkey(k, PubT.ecdsa);\n  // Locktime = unsigned little endian integer greater than or equal to 500000000 representing\n  if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000)\n    throw new Error(`validateInput: wrong timeLocktime=${i.requiredTimeLocktime}`);\n  // unsigned little endian integer greater than 0 and less than 500000000\n  if (\n    i.requiredHeightLocktime !== undefined &&\n    (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000)\n  )\n    throw new Error(`validateInput: wrong heighLocktime=${i.requiredHeightLocktime}`);\n  if (i.tapLeafScript) {\n    // tap leaf version appears here twice: in control block and at the end of script\n    for (const [k, v] of i.tapLeafScript) {\n      if ((k.version & 0b1111_1110) !== v[v.length - 1])\n        throw new Error('validateInput: tapLeafScript version mimatch');\n      if (v[v.length - 1] & 1)\n        throw new Error('validateInput: tapLeafScript version has parity bit!');\n    }\n  }\n  return i;\n});\n\nexport type ExtendType<T, E> = {\n  [K in keyof T]: K extends keyof E ? E[K] | T[K] : T[K];\n};\nexport type RequireType<T, K extends keyof T> = T & {\n  [P in K]-?: T[P];\n};\n\nexport type TransactionInput = P.UnwrapCoder<typeof PSBTInputCoder>;\nexport type TransactionInputUpdate = ExtendType<\n  TransactionInput,\n  {\n    nonWitnessUtxo?: string | Bytes;\n    txid?: string;\n  }\n>;\n\nexport const PSBTOutputCoder = P.validate(PSBTKeyMap(PSBTOutput), (o) => {\n  if (o.bip32Derivation) for (const [k] of o.bip32Derivation) validatePubkey(k, PubT.ecdsa);\n  return o;\n});\n\nexport type TransactionOutput = P.UnwrapCoder<typeof PSBTOutputCoder>;\nexport type TransactionOutputUpdate = ExtendType<TransactionOutput, { script?: string }>;\nexport type TransactionOutputRequired = {\n  script: Bytes;\n  amount: bigint;\n};\n\nconst PSBTGlobalCoder = P.validate(PSBTKeyMap(PSBTGlobal), (g) => {\n  const version = g.version || 0;\n  if (version === 0) {\n    if (!g.unsignedTx) throw new Error('PSBTv0: missing unsignedTx');\n    for (const inp of g.unsignedTx.inputs)\n      if (inp.finalScriptSig && inp.finalScriptSig.length)\n        throw new Error('PSBTv0: input scriptSig found in unsignedTx');\n  }\n  return g;\n});\n\nexport const _RawPSBTV0 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/unsignedTx/inputs/length', PSBTInputCoder),\n  outputs: P.array(null, PSBTOutputCoder),\n});\n\nexport const _RawPSBTV2 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/inputCount', PSBTInputCoder),\n  outputs: P.array('global/outputCount', PSBTOutputCoder),\n});\n\nexport type PSBTRaw = typeof _RawPSBTV0 | typeof _RawPSBTV2;\n\nexport const _DebugPSBT = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  items: P.array(\n    null,\n    P.apply(\n      P.array(P.NULL, P.tuple([P.hex(CompactSizeLen), P.bytes(CompactSize)])),\n      P.coders.dict()\n    )\n  ),\n});\n\nfunction validatePSBTFields<T extends PSBTKeyMap>(\n  version: number,\n  info: T,\n  lst: PSBTKeyMapKeys<T>\n) {\n  for (const k in lst) {\n    if (k === 'unknown') continue;\n    if (!info[k]) continue;\n    const { allowInc } = PSBTKeyInfo(info[k]);\n    if (!allowInc.includes(version)) throw new Error(`PSBTv${version}: field ${k} is not allowed`);\n  }\n  for (const k in info) {\n    const { reqInc } = PSBTKeyInfo(info[k]);\n    if (reqInc.includes(version) && lst[k] === undefined)\n      throw new Error(`PSBTv${version}: missing required field ${k}`);\n  }\n}\n\nexport function cleanPSBTFields<T extends PSBTKeyMap>(\n  version: number,\n  info: T,\n  lst: PSBTKeyMapKeys<T>\n): PSBTKeyMapKeys<T> {\n  const out: PSBTKeyMapKeys<T> = {};\n  for (const _k in lst) {\n    const k = _k as string & keyof PSBTKeyMapKeys<T>;\n    if (k !== 'unknown') {\n      if (!info[k]) continue;\n      const { allowInc, silentIgnore } = PSBTKeyInfo(info[k]);\n      if (!allowInc.includes(version)) {\n        if (silentIgnore) continue;\n        throw new Error(\n          `Failed to serialize in PSBTv${version}: ${k} but versions allows inclusion=${allowInc}`\n        );\n      }\n    }\n    out[k] = lst[k];\n  }\n  return out;\n}\n\nfunction validatePSBT(tx: P.UnwrapCoder<PSBTRaw>) {\n  const version = (tx && tx.global && tx.global.version) || 0;\n  validatePSBTFields(version, PSBTGlobal, tx.global);\n  for (const i of tx.inputs) validatePSBTFields(version, PSBTInput, i);\n  for (const o of tx.outputs) validatePSBTFields(version, PSBTOutput, o);\n  // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)\n  const inputCount = !version ? tx.global.unsignedTx!.inputs.length : tx.global.inputCount!;\n  if (tx.inputs.length < inputCount) throw new Error('Not enough inputs');\n  const inputsLeft = tx.inputs.slice(inputCount);\n  if (inputsLeft.length > 1 || (inputsLeft.length && Object.keys(inputsLeft[0]).length))\n    throw new Error(`Unexpected inputs left in tx=${inputsLeft}`);\n  // Same for inputs\n  const outputCount = !version ? tx.global.unsignedTx!.outputs.length : tx.global.outputCount!;\n  if (tx.outputs.length < outputCount) throw new Error('Not outputs inputs');\n  const outputsLeft = tx.outputs.slice(outputCount);\n  if (outputsLeft.length > 1 || (outputsLeft.length && Object.keys(outputsLeft[0]).length))\n    throw new Error(`Unexpected outputs left in tx=${outputsLeft}`);\n  return tx;\n}\n\nexport function mergeKeyMap<T extends PSBTKeyMap>(\n  psbtEnum: T,\n  val: PSBTKeyMapKeys<T>,\n  cur?: PSBTKeyMapKeys<T>,\n  allowedFields?: (keyof PSBTKeyMapKeys<T>)[],\n  allowUnknown?: boolean\n): PSBTKeyMapKeys<T> {\n  const res: PSBTKeyMapKeys<T> = { ...cur, ...val };\n  // All arguments can be provided as hex\n  for (const k in psbtEnum) {\n    const key = k as keyof typeof psbtEnum;\n    const [_, kC, vC] = psbtEnum[key];\n    type _KV = [P.UnwrapCoder<typeof kC>, P.UnwrapCoder<typeof vC>];\n    const cannotChange = allowedFields && !allowedFields.includes(k);\n    if (val[k] === undefined && k in val) {\n      if (cannotChange) throw new Error(`Cannot remove signed field=${k}`);\n      delete res[k];\n    } else if (kC) {\n      const oldKV = (cur && cur[k] ? cur[k] : []) as _KV[];\n      let newKV = val[key] as _KV[];\n      if (newKV) {\n        if (!Array.isArray(newKV)) throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n        // Decode hex in k-v\n        newKV = newKV.map((val: _KV): _KV => {\n          if (val.length !== 2) throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n          return [\n            typeof val[0] === 'string' ? kC.decode(hex.decode(val[0])) : val[0],\n            typeof val[1] === 'string' ? vC.decode(hex.decode(val[1])) : val[1],\n          ];\n        });\n        const map: Record<string, _KV> = {};\n        const add = (kStr: string, k: _KV[0], v: _KV[1]) => {\n          if (map[kStr] === undefined) {\n            map[kStr] = [k, v];\n            return;\n          }\n          const oldVal = hex.encode(vC.encode(map[kStr][1]));\n          const newVal = hex.encode(vC.encode(v));\n          if (oldVal !== newVal)\n            throw new Error(\n              `keyMap(${key as string}): same key=${kStr} oldVal=${oldVal} newVal=${newVal}`\n            );\n        };\n        for (const [k, v] of oldKV) {\n          const kStr = hex.encode(kC.encode(k));\n          add(kStr, k, v);\n        }\n        for (const [k, v] of newKV) {\n          const kStr = hex.encode(kC.encode(k));\n          // undefined removes previous value\n          if (v === undefined) {\n            if (cannotChange) throw new Error(`Cannot remove signed field=${key as string}/${k}`);\n            delete map[kStr];\n          } else add(kStr, k, v);\n        }\n        (res as any)[key] = Object.values(map) as _KV[];\n      }\n    } else if (typeof res[k] === 'string') {\n      res[k] = vC.decode(hex.decode(res[k] as string));\n    } else if (cannotChange && k in val && cur && cur[k] !== undefined) {\n      if (!equalBytes(vC.encode(val[k]), vC.encode(cur[k])))\n        throw new Error(`Cannot change signed field=${k}`);\n    }\n  }\n  // Remove unknown keys except the \"unknown\" array if allowUnknown is true\n  for (const k in res) {\n    if (!psbtEnum[k]) {\n      if (allowUnknown && k === 'unknown') continue;\n      delete res[k];\n    }\n  }\n  return res;\n}\n\nexport const RawPSBTV0 = P.validate(_RawPSBTV0, validatePSBT);\nexport const RawPSBTV2 = P.validate(_RawPSBTV2, validatePSBT);\n", "import { bech32, bech32m, type Coder, createBase58check, hex } from '@scure/base';\nimport * as P from 'micro-packed';\nimport { TaprootControlBlock, type TransactionInput } from './psbt.ts';\nimport { OpToNum, Script, type ScriptType, VarBytes } from './script.ts';\nimport * as u from './utils.ts';\nimport { type BTC_NETWORK, type Bytes, NETWORK } from './utils.ts';\n\n// We need following items:\n// - encode/decode output script\n// - generate input script\n// - generate address/output/redeem from user input\n// P2ret represents generic interface for all p2* methods\nexport type P2Ret = {\n  type: string;\n  script: Bytes;\n  address?: string;\n  redeemScript?: Bytes;\n  witnessScript?: Bytes;\n  hash?: Bytes;\n};\n\n// Pay to Anchor (P2A)\ntype OutP2AType = { type: 'p2a'; script: Bytes };\nconst OutP2A: Coder<OptScript, OutP2AType | undefined> = {\n  encode(from: ScriptType): OutP2AType | undefined {\n    if (from.length !== 2 || from[0] !== 1 || !u.isBytes(from[1]) || hex.encode(from[1]) !== '4e73')\n      return;\n    return { type: 'p2a', script: Script.encode(from) };\n  },\n  decode: (to: OutP2AType): OptScript => {\n    if (to.type !== 'p2a') return;\n    return [1, hex.decode('4e73')];\n  },\n};\n\n// Public Key (P2PK)\ntype OutPKType = { type: 'pk'; pubkey: Bytes };\nexport type OptScript = ScriptType | undefined;\n\nfunction isValidPubkey(pub: Bytes, type: u.PubT): boolean {\n  try {\n    u.validatePubkey(pub, type);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst OutPK: Coder<OptScript, OutPKType | undefined> = {\n  encode(from: ScriptType): OutPKType | undefined {\n    if (\n      from.length !== 2 ||\n      !u.isBytes(from[0]) ||\n      !isValidPubkey(from[0], u.PubT.ecdsa) ||\n      from[1] !== 'CHECKSIG'\n    )\n      return;\n    return { type: 'pk', pubkey: from[0] };\n  },\n  decode: (to: OutPKType): OptScript => (to.type === 'pk' ? [to.pubkey, 'CHECKSIG'] : undefined),\n};\n\n// Public Key Hash (P2PKH)\ntype OutPKHType = { type: 'pkh'; hash: Bytes };\nconst OutPKH: Coder<OptScript, OutPKHType | undefined> = {\n  encode(from: ScriptType): OutPKHType | undefined {\n    if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !u.isBytes(from[2]))\n      return;\n    if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG') return;\n    return { type: 'pkh', hash: from[2] };\n  },\n  decode: (to: OutPKHType): OptScript =>\n    to.type === 'pkh' ? ['DUP', 'HASH160', to.hash, 'EQUALVERIFY', 'CHECKSIG'] : undefined,\n};\n// Script Hash (P2SH)\ntype OutSHType = { type: 'sh'; hash: Bytes };\nconst OutSH: Coder<OptScript, OutSHType | undefined> = {\n  encode(from: ScriptType): OutSHType | undefined {\n    if (from.length !== 3 || from[0] !== 'HASH160' || !u.isBytes(from[1]) || from[2] !== 'EQUAL')\n      return;\n    return { type: 'sh', hash: from[1] };\n  },\n  decode: (to: OutSHType): OptScript =>\n    to.type === 'sh' ? ['HASH160', to.hash, 'EQUAL'] : undefined,\n};\n\n// Witness Script Hash (P2WSH)\ntype OutWSHType = { type: 'wsh'; hash: Bytes };\nconst OutWSH: Coder<OptScript, OutWSHType | undefined> = {\n  encode(from: ScriptType): OutWSHType | undefined {\n    if (from.length !== 2 || from[0] !== 0 || !u.isBytes(from[1])) return;\n    if (from[1].length !== 32) return;\n    return { type: 'wsh', hash: from[1] };\n  },\n  decode: (to: OutWSHType): OptScript => (to.type === 'wsh' ? [0, to.hash] : undefined),\n};\n\n// Witness Public Key Hash (P2WPKH)\ntype OutWPKHType = { type: 'wpkh'; hash: Bytes };\nconst OutWPKH: Coder<OptScript, OutWPKHType | undefined> = {\n  encode(from: ScriptType): OutWPKHType | undefined {\n    if (from.length !== 2 || from[0] !== 0 || !u.isBytes(from[1])) return;\n    if (from[1].length !== 20) return;\n    return { type: 'wpkh', hash: from[1] };\n  },\n  decode: (to: OutWPKHType): OptScript => (to.type === 'wpkh' ? [0, to.hash] : undefined),\n};\n\n// Multisig (P2MS)\ntype OutMSType = { type: 'ms'; pubkeys: Bytes[]; m: number };\nconst OutMS: Coder<OptScript, OutMSType | undefined> = {\n  encode(from: ScriptType): OutMSType | undefined {\n    const last = from.length - 1;\n    if (from[last] !== 'CHECKMULTISIG') return;\n    const m = from[0];\n    const n = from[last - 1];\n    if (typeof m !== 'number' || typeof n !== 'number') return;\n    const pubkeys = from.slice(1, -2);\n    if (n !== pubkeys.length) return;\n    for (const pub of pubkeys) if (!u.isBytes(pub)) return;\n    return { type: 'ms', m, pubkeys: pubkeys as Bytes[] }; // we don't need n, since it is the same as pubkeys\n  },\n  // checkmultisig(n, ..pubkeys, m)\n  decode: (to: OutMSType): OptScript =>\n    to.type === 'ms' ? [to.m, ...to.pubkeys, to.pubkeys.length, 'CHECKMULTISIG'] : undefined,\n};\n// Taproot (P2TR)\ntype OutTRType = { type: 'tr'; pubkey: Bytes };\nconst OutTR: Coder<OptScript, OutTRType | undefined> = {\n  encode(from: ScriptType): OutTRType | undefined {\n    if (from.length !== 2 || from[0] !== 1 || !u.isBytes(from[1])) return;\n    return { type: 'tr', pubkey: from[1] };\n  },\n  decode: (to: OutTRType): OptScript => (to.type === 'tr' ? [1, to.pubkey] : undefined),\n};\n\n// Taproot N-of-N multisig (P2TR_NS)\ntype OutTRNSType = { type: 'tr_ns'; pubkeys: Bytes[] };\nconst OutTRNS: Coder<OptScript, OutTRNSType | undefined> = {\n  encode(from: ScriptType): OutTRNSType | undefined {\n    const last = from.length - 1;\n    if (from[last] !== 'CHECKSIG') return;\n    const pubkeys = [];\n    // On error return, since it can be different script\n    for (let i = 0; i < last; i++) {\n      const elm = from[i];\n      if (i & 1) {\n        if (elm !== 'CHECKSIGVERIFY' || i === last - 1) return;\n        continue;\n      }\n      if (!u.isBytes(elm)) return;\n      pubkeys.push(elm);\n    }\n    return { type: 'tr_ns', pubkeys };\n  },\n  decode: (to: OutTRNSType): OptScript => {\n    if (to.type !== 'tr_ns') return;\n    const out: ScriptType = [];\n    for (let i = 0; i < to.pubkeys.length - 1; i++) out.push(to.pubkeys[i], 'CHECKSIGVERIFY');\n    out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');\n    return out;\n  },\n};\n\n// Taproot M-of-N Multisig (P2TR_MS)\ntype OutTRMSType = { type: 'tr_ms'; pubkeys: Bytes[]; m: number };\nconst OutTRMS: Coder<OptScript, OutTRMSType | undefined> = {\n  encode(from: ScriptType): OutTRMSType | undefined {\n    const last = from.length - 1;\n    if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG') return;\n    const pubkeys = [];\n    const m = OpToNum(from[last - 1]);\n    if (typeof m !== 'number') return;\n    for (let i = 0; i < last - 1; i++) {\n      const elm = from[i];\n      if (i & 1) {\n        if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD'))\n          throw new Error('OutScript.encode/tr_ms: wrong element');\n        continue;\n      }\n      if (!u.isBytes(elm)) throw new Error('OutScript.encode/tr_ms: wrong key element');\n      pubkeys.push(elm);\n    }\n    return { type: 'tr_ms', pubkeys, m };\n  },\n  decode: (to: OutTRMSType): OptScript => {\n    if (to.type !== 'tr_ms') return;\n    const out: ScriptType = [to.pubkeys[0], 'CHECKSIG'];\n    for (let i = 1; i < to.pubkeys.length; i++) out.push(to.pubkeys[i], 'CHECKSIGADD');\n    out.push(to.m, 'NUMEQUAL');\n    return out;\n  },\n};\n\n// Unknown output type\ntype OutUnknownType = { type: 'unknown'; script: Bytes };\nconst OutUnknown: Coder<OptScript, OutUnknownType | undefined> = {\n  encode(from: ScriptType): OutUnknownType | undefined {\n    return { type: 'unknown', script: Script.encode(from) };\n  },\n  decode: (to: OutUnknownType): OptScript =>\n    to.type === 'unknown' ? Script.decode(to.script) : undefined,\n};\n// /Payments\n\nconst OutScripts = [\n  OutP2A,\n  OutPK,\n  OutPKH,\n  OutSH,\n  OutWSH,\n  OutWPKH,\n  OutMS,\n  OutTR,\n  OutTRNS,\n  OutTRMS,\n  OutUnknown,\n];\n// TODO: we can support user supplied output scripts now\n// - addOutScript\n// - removeOutScript\n// - We can do that as log we modify array in-place\n// - Actually is very hard, since there is sign/finalize logic\nconst _OutScript = P.apply(Script, P.coders.match(OutScripts));\n\n/*\n * UNSAFE: Custom scripts: mostly ordinals, be very careful when crafting new scripts\n * Only taproot supported for now.\n * NOTE: we can use same to move finalization logic from Transaction, but it will significantly change audited code.\n */\n\ntype FinalizeSignature = [{ pubKey: Bytes; leafHash: Bytes }, Bytes];\ntype CustomScriptOut = { type: string } & Record<string, any>;\nexport type CustomScript = Coder<OptScript, CustomScriptOut | undefined> & {\n  finalizeTaproot?: (\n    script: Bytes,\n    parsed: CustomScriptOut,\n    signatures: FinalizeSignature[]\n  ) => Bytes[] | undefined;\n};\n\n// We can validate this once, because of packed & coders\nexport const OutScript: P.CoderType<\n  NonNullable<\n    | OutP2AType\n    | OutPKType\n    | OutPKHType\n    | OutSHType\n    | OutWSHType\n    | OutWPKHType\n    | OutMSType\n    | OutTRType\n    | OutTRNSType\n    | OutTRMSType\n    | OutUnknownType\n    | undefined\n  >\n> = P.validate(_OutScript, (i) => {\n  if (i.type === 'pk' && !isValidPubkey(i.pubkey, u.PubT.ecdsa))\n    throw new Error('OutScript/pk: wrong key');\n  if (\n    (i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') &&\n    (!u.isBytes(i.hash) || i.hash.length !== 20)\n  )\n    throw new Error(`OutScript/${i.type}: wrong hash`);\n  if (i.type === 'wsh' && (!u.isBytes(i.hash) || i.hash.length !== 32))\n    throw new Error(`OutScript/wsh: wrong hash`);\n  if (i.type === 'tr' && (!u.isBytes(i.pubkey) || !isValidPubkey(i.pubkey, u.PubT.schnorr)))\n    throw new Error('OutScript/tr: wrong taproot public key');\n  if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms')\n    if (!Array.isArray(i.pubkeys)) throw new Error('OutScript/multisig: wrong pubkeys array');\n  if (i.type === 'ms') {\n    const n = i.pubkeys.length;\n    for (const p of i.pubkeys)\n      if (!isValidPubkey(p, u.PubT.ecdsa)) throw new Error('OutScript/multisig: wrong pubkey');\n    if (i.m <= 0 || n > 16 || i.m > n) throw new Error('OutScript/multisig: invalid params');\n  }\n  if (i.type === 'tr_ns' || i.type === 'tr_ms') {\n    for (const p of i.pubkeys)\n      if (!isValidPubkey(p, u.PubT.schnorr)) throw new Error(`OutScript/${i.type}: wrong pubkey`);\n  }\n  if (i.type === 'tr_ms') {\n    const n = i.pubkeys.length;\n    if (i.m <= 0 || n > 999 || i.m > n) throw new Error('OutScript/tr_ms: invalid params');\n  }\n  return i;\n});\nexport type OutScriptType = typeof OutScript;\n\n// Basic sanity check for scripts\nfunction checkWSH(s: OutWSHType, witnessScript: Bytes) {\n  if (!u.equalBytes(s.hash, u.sha256(witnessScript)))\n    throw new Error('checkScript: wsh wrong witnessScript hash');\n  const w = OutScript.decode(witnessScript);\n  if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms')\n    throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2SH`);\n  if (w.type === 'wpkh' || w.type === 'sh')\n    throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2WSH`);\n}\n\nexport function checkScript(script?: Bytes, redeemScript?: Bytes, witnessScript?: Bytes): void {\n  if (script) {\n    const s = OutScript.decode(script);\n    // ms||pk maybe work, but there will be no address, hard to spend\n    if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk')\n      throw new Error(`checkScript: non-wrapped ${s.type}`);\n    if (s.type === 'sh' && redeemScript) {\n      if (!u.equalBytes(s.hash, u.hash160(redeemScript)))\n        throw new Error('checkScript: sh wrong redeemScript hash');\n      const r = OutScript.decode(redeemScript);\n      if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms')\n        throw new Error(`checkScript: P2${r.type} cannot be wrapped in P2SH`);\n      // Not sure if this unspendable, but we cannot represent this via PSBT\n      if (r.type === 'sh') throw new Error('checkScript: P2SH cannot be wrapped in P2SH');\n    }\n    if (s.type === 'wsh' && witnessScript) checkWSH(s, witnessScript);\n  }\n  if (redeemScript) {\n    const r = OutScript.decode(redeemScript);\n    if (r.type === 'wsh' && witnessScript) checkWSH(r, witnessScript);\n  }\n}\n\nfunction uniqPubkey(pubkeys: Bytes[]) {\n  const map: Record<string, boolean> = {};\n  for (const pub of pubkeys) {\n    const key = hex.encode(pub);\n    if (map[key]) throw new Error(`Multisig: non-uniq pubkey: ${pubkeys.map(hex.encode)}`);\n    map[key] = true;\n  }\n}\n// We want narrow types inside p2* methods, but always want to type-check if they compatible with P2Ret here!\n// Also we use satisfies for additional check (ts 4.9+)\ntype Extends<T, U> = T extends U ? T : never;\n\nexport type P2PK = { type: 'pk'; script: Bytes };\nexport const p2pk = (pubkey: Bytes, _network: BTC_NETWORK = NETWORK): Extends<P2PK, P2Ret> => {\n  // network is unused\n  if (!isValidPubkey(pubkey, u.PubT.ecdsa)) throw new Error('P2PK: invalid publicKey');\n  return { type: 'pk', script: OutScript.encode({ type: 'pk', pubkey }) } as const satisfies P2Ret;\n};\n\nexport type P2PKH = { type: 'pkh'; script: Bytes; address: string; hash: Bytes };\nexport const p2pkh = (publicKey: Bytes, network: BTC_NETWORK = NETWORK): Extends<P2PKH, P2Ret> => {\n  if (!isValidPubkey(publicKey, u.PubT.ecdsa)) throw new Error('P2PKH: invalid publicKey');\n  const hash = u.hash160(publicKey);\n  return {\n    type: 'pkh',\n    script: OutScript.encode({ type: 'pkh', hash }),\n    address: Address(network).encode({ type: 'pkh', hash }),\n    hash,\n  } as const satisfies P2Ret;\n};\n\nexport type P2SHBase = {\n  type: 'sh';\n  redeemScript: Bytes;\n  script: Bytes;\n  address: string;\n  hash: Bytes;\n};\nexport type P2SHWithWitness = P2SHBase & { witnessScript: Bytes };\nexport type P2SHWithoutWitness = Omit<P2SHBase, 'witnessScript'>;\nexport type P2SHReturn<T extends P2Ret> = T extends { witnessScript: Bytes }\n  ? P2SHWithWitness\n  : P2SHWithoutWitness;\nexport const p2sh = <T extends P2Ret>(\n  child: T,\n  network: BTC_NETWORK = NETWORK\n): Extends<P2SHReturn<T>, P2Ret> => {\n  // It is already tested inside noble-hashes and checkScript\n  const cs = child.script;\n  if (!u.isBytes(cs)) throw new Error(`Wrong script: ${typeof child.script}, expected Uint8Array`);\n  const hash = u.hash160(cs);\n  const script = OutScript.encode({ type: 'sh', hash });\n  checkScript(script, cs, child.witnessScript);\n  if (child.witnessScript) {\n    return {\n      type: 'sh',\n      redeemScript: cs,\n      script: OutScript.encode({ type: 'sh', hash }),\n      address: Address(network).encode({ type: 'sh', hash }),\n      hash,\n      witnessScript: child.witnessScript,\n    } as Extends<P2SHReturn<T>, P2Ret> satisfies P2Ret;\n  } else {\n    return {\n      type: 'sh',\n      redeemScript: cs,\n      script: OutScript.encode({ type: 'sh', hash }),\n      address: Address(network).encode({ type: 'sh', hash }),\n      hash,\n    } as Extends<P2SHReturn<T>, P2Ret> satisfies P2Ret;\n  }\n};\n\nexport type P2WSH = {\n  type: 'wsh';\n  witnessScript: Bytes;\n  script: Bytes;\n  address: string;\n  hash: Bytes;\n};\nexport const p2wsh = (child: P2Ret, network: BTC_NETWORK = NETWORK): Extends<P2WSH, P2Ret> => {\n  const cs = child.script;\n  if (!u.isBytes(cs)) throw new Error(`Wrong script: ${typeof cs}, expected Uint8Array`);\n  const hash = u.sha256(cs);\n  const script = OutScript.encode({ type: 'wsh', hash });\n  checkScript(script, undefined, cs);\n  return {\n    type: 'wsh',\n    witnessScript: cs,\n    script: OutScript.encode({ type: 'wsh', hash }),\n    address: Address(network).encode({ type: 'wsh', hash }),\n    hash,\n  } as const satisfies P2Ret;\n};\n\nexport type P2WPKH = { type: 'wpkh'; script: Bytes; address: string; hash: Bytes };\nexport const p2wpkh = (\n  publicKey: Bytes,\n  network: BTC_NETWORK = NETWORK\n): Extends<P2WPKH, P2Ret> => {\n  if (!isValidPubkey(publicKey, u.PubT.ecdsa)) throw new Error('P2WPKH: invalid publicKey');\n  if (publicKey.length === 65) throw new Error('P2WPKH: uncompressed public key');\n  const hash = u.hash160(publicKey);\n  return {\n    type: 'wpkh',\n    script: OutScript.encode({ type: 'wpkh', hash }),\n    address: Address(network).encode({ type: 'wpkh', hash }),\n    hash,\n  } as const satisfies P2Ret;\n};\n\nexport type P2MS = { type: 'ms'; script: Bytes };\nexport const p2ms = (\n  m: number,\n  pubkeys: Bytes[],\n  allowSamePubkeys = false\n): Extends<P2MS, P2Ret> => {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'ms',\n    script: OutScript.encode({ type: 'ms', pubkeys, m }),\n  } as const satisfies P2Ret;\n};\n\nexport type HashedTree =\n  | { type: 'leaf'; version?: number; script: Bytes; hash: Bytes }\n  | { type: 'branch'; left: HashedTree; right: HashedTree; hash: Bytes };\nfunction checkTaprootScript(\n  script: Bytes,\n  internalPubKey: Bytes,\n  allowUnknownOutputs = false,\n  customScripts?: CustomScript[]\n) {\n  const out = OutScript.decode(script);\n  if (out.type === 'unknown') {\n    // NOTE: this check should be before allowUnknownOutputs, otherwise it will\n    // disable custom. All custom scripts for taproot should have prefix 'tr_'\n    if (customScripts) {\n      const cs = P.apply(Script, P.coders.match(customScripts));\n      const c = cs.decode(script);\n      if (c !== undefined) {\n        if (typeof c.type !== 'string' || !c.type.startsWith('tr_'))\n          throw new Error(`P2TR: invalid custom type=${c.type}`);\n        return;\n      }\n    }\n    if (allowUnknownOutputs) return;\n  }\n  if (!['tr_ns', 'tr_ms'].includes(out.type))\n    throw new Error(`P2TR: invalid leaf script=${out.type}`);\n  const outms = out as OutTRNSType | OutTRMSType;\n  if (!allowUnknownOutputs && outms.pubkeys) {\n    for (const p of outms.pubkeys) {\n      if (u.equalBytes(p, u.TAPROOT_UNSPENDABLE_KEY))\n        throw new Error('Unspendable taproot key in leaf script');\n      // It's likely a mistake at this point:\n      // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)\n      // but will take more space and fees.\n      // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:\n      // User creates 2 of 3 multisig of keys [A, B, C],\n      // but key A always can spend whole output without signatures from other keys.\n      // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)\n      if (u.equalBytes(p, internalPubKey)) {\n        throw new Error(\n          'Using P2TR with leaf script with same key as internal key is not supported'\n        );\n      }\n    }\n  }\n}\n\nexport type P2TR = {\n  type: 'tr';\n  script: Bytes;\n  address: string;\n  tweakedPubkey: Bytes;\n  tapInternalKey: Bytes;\n};\nexport type P2TR_TREE = P2TR & {\n  tapMerkleRoot: Bytes;\n  tapLeafScript: TransactionInput['tapLeafScript'];\n  leaves: TaprootLeaf[];\n};\n\nexport type TaprootNode = {\n  script: Bytes | string;\n  leafVersion?: number;\n  weight?: number;\n} & Partial<P2TR_TREE>;\nexport type TaprootScriptTree = TaprootNode | TaprootScriptTree[];\nexport type TaprootScriptList = TaprootNode[];\ntype _TaprootTreeInternal = {\n  weight?: number;\n  childs?: [_TaprootTreeInternal[], _TaprootTreeInternal[]];\n};\n\n// Helper for generating binary tree from list, with weights\nexport function taprootListToTree(taprootList: TaprootScriptList): TaprootScriptTree {\n  // Clone input in order to not corrupt it\n  const lst = Array.from(taprootList) as _TaprootTreeInternal[];\n  // We have at least 2 elements => can create branch\n  while (lst.length >= 2) {\n    // Sort: elements with smallest weight are in the end of queue\n    lst.sort((a, b) => (b.weight || 1) - (a.weight || 1));\n    const b = lst.pop()!;\n    const a = lst.pop()!;\n    const weight = (a?.weight || 1) + (b?.weight || 1);\n    lst.push({\n      weight,\n      // Unwrap children array\n      // TODO: Very hard to remove any here\n      childs: [a?.childs || (a as any[]), b?.childs || (b as any)],\n    });\n  }\n  // At this point there is always 1 element in lst\n  const last = lst[0];\n  return (last?.childs || last) as TaprootScriptTree;\n}\n\nexport type TaprootLeaf = {\n  type: 'leaf';\n  version?: number;\n  script: Bytes;\n  hash: Bytes;\n  path: Bytes[];\n};\n\nexport type HashedTreeWithPath =\n  | TaprootLeaf\n  | {\n      type: 'branch';\n      left: HashedTreeWithPath;\n      right: HashedTreeWithPath;\n      hash: Bytes;\n      path: Bytes[];\n    };\n\nfunction taprootAddPath(tree: HashedTree, path: Bytes[] = []): HashedTreeWithPath {\n  if (!tree) throw new Error(`taprootAddPath: empty tree`);\n  if (tree.type === 'leaf') return { ...tree, path };\n  if (tree.type !== 'branch') throw new Error(`taprootAddPath: wrong type=${tree}`);\n  return {\n    ...tree,\n    path,\n    // Left element has right hash in path and otherwise\n    left: taprootAddPath(tree.left, [tree.right.hash, ...path]),\n    right: taprootAddPath(tree.right, [tree.left.hash, ...path]),\n  };\n}\nfunction taprootWalkTree(tree: HashedTreeWithPath): TaprootLeaf[] {\n  if (!tree) throw new Error(`taprootAddPath: empty tree`);\n  if (tree.type === 'leaf') return [tree];\n  if (tree.type !== 'branch') throw new Error(`taprootWalkTree: wrong type=${tree}`);\n  return [...taprootWalkTree(tree.left), ...taprootWalkTree(tree.right)];\n}\n\nfunction taprootHashTree(\n  tree: TaprootScriptTree,\n  internalPubKey: Bytes,\n  allowUnknownOutputs = false,\n  customScripts?: CustomScript[]\n): HashedTree {\n  if (!tree) throw new Error('taprootHashTree: empty tree');\n  if (Array.isArray(tree) && tree.length === 1) tree = tree[0];\n  // Terminal node (leaf)\n  if (!Array.isArray(tree)) {\n    const { leafVersion: version, script: leafScript } = tree;\n    // Earliest tree walk where we can validate tapScripts\n    if (tree.tapLeafScript || (tree.tapMerkleRoot && !u.equalBytes(tree.tapMerkleRoot, P.EMPTY)))\n      throw new Error('P2TR: tapRoot leafScript cannot have tree');\n    const script = typeof leafScript === 'string' ? hex.decode(leafScript) : leafScript;\n    if (!u.isBytes(script)) throw new Error(`checkScript: wrong script type=${script}`);\n    checkTaprootScript(script, internalPubKey, allowUnknownOutputs, customScripts);\n    return {\n      type: 'leaf',\n      version,\n      script,\n      hash: tapLeafHash(script, version),\n    };\n  }\n  // If tree / branch is not binary tree, convert it\n  if (tree.length !== 2) tree = taprootListToTree(tree as TaprootNode[]) as TaprootNode[];\n  if (tree.length !== 2) throw new Error('hashTree: non binary tree!');\n  // branch\n  // Both nodes should exist\n  const left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs, customScripts);\n  const right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs, customScripts);\n  // We cannot swap left/right here, since it will change structure of tree\n  let [lH, rH] = [left.hash, right.hash];\n  if (u.compareBytes(rH, lH) === -1) [lH, rH] = [rH, lH];\n  return { type: 'branch', left, right, hash: u.tagSchnorr('TapBranch', lH, rH) };\n}\n\nexport const TAP_LEAF_VERSION = 0xc0;\nexport const tapLeafHash = (script: Bytes, version: number = TAP_LEAF_VERSION): Bytes =>\n  u.tagSchnorr('TapLeaf', new Uint8Array([version]), VarBytes.encode(script));\n\n// Works as key OR tree.\n// If we only have tree, need to add unspendable key, otherwise\n// complex multisig wallet can be spent by owner of key only. See TAPROOT_UNSPENDABLE_KEY\nexport type P2TRRet<T> = T extends TaprootScriptTree ? P2TR_TREE : P2TR;\nexport function p2tr(\n  internalPubKey: Bytes | string,\n  tree?: undefined,\n  network?: BTC_NETWORK,\n  allowUnknownOutputs?: boolean,\n  customScripts?: CustomScript[]\n): Extends<P2TR, P2Ret>;\nexport function p2tr(\n  internalPubKey: Bytes | string,\n  tree: TaprootScriptTree,\n  network?: BTC_NETWORK,\n  allowUnknownOutputs?: boolean,\n  customScripts?: CustomScript[]\n): Extends<P2TR_TREE, P2Ret>;\nexport function p2tr(\n  internalPubKey?: Bytes | string,\n  tree?: TaprootScriptTree,\n  network: BTC_NETWORK = NETWORK,\n  allowUnknownOutputs = false,\n  customScripts?: CustomScript[]\n): Extends<P2TR & Partial<P2TR_TREE>, P2Ret> {\n  // Unspendable\n  if (!internalPubKey && !tree) throw new Error('p2tr: should have pubKey or scriptTree (or both)');\n  const pubKey =\n    typeof internalPubKey === 'string'\n      ? hex.decode(internalPubKey)\n      : internalPubKey || u.TAPROOT_UNSPENDABLE_KEY;\n  if (!isValidPubkey(pubKey, u.PubT.schnorr)) throw new Error('p2tr: non-schnorr pubkey');\n  if (tree) {\n    let hashedTree = taprootAddPath(\n      taprootHashTree(tree, pubKey, allowUnknownOutputs, customScripts)\n    );\n    const tapMerkleRoot = hashedTree.hash;\n    const [tweakedPubkey, parity] = u.taprootTweakPubkey(pubKey, tapMerkleRoot);\n    const leaves = taprootWalkTree(hashedTree).map((l) => ({\n      ...l,\n      controlBlock: TaprootControlBlock.encode({\n        version: (l.version || TAP_LEAF_VERSION) + parity,\n        internalKey: pubKey,\n        merklePath: l.path,\n      }),\n    }));\n    return {\n      type: 'tr',\n      script: OutScript.encode({ type: 'tr', pubkey: tweakedPubkey }),\n      address: Address(network).encode({ type: 'tr', pubkey: tweakedPubkey }),\n      // For tests\n      tweakedPubkey,\n      // PSBT stuff\n      tapInternalKey: pubKey,\n      leaves,\n      tapLeafScript: leaves.map((l) => [\n        TaprootControlBlock.decode(l.controlBlock),\n        u.concatBytes(l.script, new Uint8Array([l.version || TAP_LEAF_VERSION])),\n      ]),\n      tapMerkleRoot,\n    } as const satisfies P2TR_TREE;\n  } else {\n    const tweakedPubkey = u.taprootTweakPubkey(pubKey, P.EMPTY)[0];\n    return {\n      type: 'tr',\n      script: OutScript.encode({ type: 'tr', pubkey: tweakedPubkey }),\n      address: Address(network).encode({ type: 'tr', pubkey: tweakedPubkey }),\n      // For tests\n      tweakedPubkey,\n      // PSBT stuff\n      tapInternalKey: pubKey,\n    } as const satisfies P2TR;\n  }\n}\n\n// Returns all combinations of size M from lst\nexport function combinations<T>(m: number, list: T[]): T[][] {\n  const res: T[][] = [];\n  if (!Array.isArray(list)) throw new Error('combinations: lst arg should be array');\n  const n = list.length;\n  if (m > n) throw new Error('combinations: m > lst.length, no combinations possible');\n  /*\n  Basically works as M nested loops like:\n  for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)\n  but since we cannot create nested loops dynamically, we unroll it to a single loop\n  */\n  const idx = Array.from({ length: m }, (_, i) => i);\n  const last = idx.length - 1;\n  main: for (;;) {\n    res.push(idx.map((i) => list[i]));\n    idx[last] += 1;\n    let i = last;\n    // Propagate increment\n    // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow\n    for (; i >= 0 && idx[i] > n - m + i; i--) {\n      idx[i] = 0;\n      // Overflow in idx[0], break\n      if (i === 0) break main;\n      idx[i - 1] += 1;\n    }\n    // Propagate: idx[i+1] = idx[idx]+1\n    for (i += 1; i < idx.length; i++) idx[i] = idx[i - 1] + 1;\n  }\n  return res;\n}\n\n/**\n * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.\n * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.\n * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`\n */\nexport type P2TR_NS = { type: 'tr_ns'; script: Bytes };\nexport const p2tr_ns = (\n  m: number,\n  pubkeys: Bytes[],\n  allowSamePubkeys = false\n): Extends<P2TR_NS, P2Ret>[] => {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return combinations(m, pubkeys).map(\n    (i) =>\n      ({\n        type: 'tr_ns',\n        script: OutScript.encode({ type: 'tr_ns', pubkeys: i }),\n      }) as const\n  ) satisfies P2Ret[];\n};\n// Taproot public key (case of p2tr_ns)\nexport type P2TR_PK = P2TR_NS;\nexport const p2tr_pk = (pubkey: Bytes): Extends<P2TR_PK, P2Ret> =>\n  p2tr_ns(1, [pubkey], undefined)[0] satisfies P2Ret;\n\nexport type P2TR_MS = { type: 'tr_ms'; script: Bytes };\nexport function p2tr_ms(\n  m: number,\n  pubkeys: Bytes[],\n  allowSamePubkeys = false\n): Extends<P2TR_MS, P2Ret> {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'tr_ms',\n    script: OutScript.encode({ type: 'tr_ms', pubkeys, m }),\n  } as const satisfies P2Ret;\n}\n\n// Simple pubkey address, without complex scripts\nexport function getAddress(\n  type: 'pkh' | 'wpkh' | 'tr',\n  privKey: Bytes,\n  network: BTC_NETWORK = NETWORK\n): string | undefined {\n  if (type === 'tr') {\n    return p2tr(u.pubSchnorr(privKey), undefined, network).address;\n  }\n  const pubKey = u.pubECDSA(privKey);\n  if (type === 'pkh') return p2pkh(pubKey, network).address;\n  if (type === 'wpkh') return p2wpkh(pubKey, network).address;\n  throw new Error(`getAddress: unknown type=${type}`);\n}\n\nexport const _sortPubkeys = (pubkeys: Bytes[]): Bytes[] => Array.from(pubkeys).sort(u.compareBytes);\n\nexport function multisig(\n  m: number,\n  pubkeys: Bytes[],\n  sorted = false,\n  witness = false,\n  network: BTC_NETWORK = NETWORK\n): P2Ret {\n  const ms = p2ms(m, sorted ? _sortPubkeys(pubkeys) : pubkeys);\n  return witness ? p2wsh(ms, network) : p2sh(ms, network);\n}\n\nexport function sortedMultisig(\n  m: number,\n  pubkeys: Bytes[],\n  witness = false,\n  network: BTC_NETWORK = NETWORK\n): P2Ret {\n  return multisig(m, pubkeys, true, witness, network);\n}\n\nconst base58check = createBase58check(u.sha256);\n\nfunction validateWitness(version: number, data: Bytes) {\n  if (data.length < 2 || data.length > 40) throw new Error('Witness: invalid length');\n  if (version > 16) throw new Error('Witness: invalid version');\n  if (version === 0 && !(data.length === 20 || data.length === 32))\n    throw new Error('Witness: invalid length for version');\n}\n\nfunction programToWitness(version: number, data: Bytes, network = NETWORK) {\n  validateWitness(version, data);\n  const coder = version === 0 ? bech32 : bech32m;\n  return coder.encode(network.bech32, [version].concat(coder.toWords(data)));\n}\n\nfunction formatKey(hashed: Bytes, prefix: number[]): string {\n  return base58check.encode(u.concatBytes(Uint8Array.from(prefix), hashed));\n}\n\nexport function WIF(network: BTC_NETWORK = NETWORK): Coder<Bytes, string> {\n  return {\n    encode(privKey: Bytes) {\n      const compressed = u.concatBytes(privKey, new Uint8Array([0x01]));\n      return formatKey(compressed.subarray(0, 33), [network.wif]);\n    },\n    decode(wif: string) {\n      let parsed = base58check.decode(wif);\n      if (parsed[0] !== network.wif) throw new Error('Wrong WIF prefix');\n      parsed = parsed.subarray(1);\n      // Check what it is. Compressed flag?\n      if (parsed.length !== 33) throw new Error('Wrong WIF length');\n      if (parsed[32] !== 0x01) throw new Error('Wrong WIF postfix');\n      return parsed.subarray(0, -1);\n    },\n  };\n}\n\n// Returns OutType, which can be used to create outscript\nexport function Address(network: BTC_NETWORK = NETWORK) {\n  return {\n    encode(from: P.UnwrapCoder<OutScriptType>): string {\n      const { type } = from;\n      if (type === 'wpkh') return programToWitness(0, from.hash, network);\n      else if (type === 'wsh') return programToWitness(0, from.hash, network);\n      else if (type === 'tr') return programToWitness(1, from.pubkey, network);\n      else if (type === 'pkh') return formatKey(from.hash, [network.pubKeyHash]);\n      else if (type === 'sh') return formatKey(from.hash, [network.scriptHash]);\n      throw new Error(`Unknown address type=${type}`);\n    },\n    decode(address: string): P.UnwrapCoder<OutScriptType> {\n      if (address.length < 14 || address.length > 74) throw new Error('Invalid address length');\n      // Bech32\n      if (network.bech32 && address.toLowerCase().startsWith(`${network.bech32}1`)) {\n        let res;\n        try {\n          res = bech32.decode(address as `${string}1${string}`);\n          if (res.words[0] !== 0) throw new Error(`bech32: wrong version=${res.words[0]}`);\n        } catch (_) {\n          // Starting from version 1 it is decoded as bech32m\n          res = bech32m.decode(address as `${string}1${string}`);\n          if (res.words[0] === 0) throw new Error(`bech32m: wrong version=${res.words[0]}`);\n        }\n        if (res.prefix !== network.bech32) throw new Error(`wrong bech32 prefix=${res.prefix}`);\n        const [version, ...program] = res.words;\n        const data = bech32.fromWords(program);\n        validateWitness(version, data);\n        if (version === 0 && data.length === 32) return { type: 'wsh', hash: data };\n        else if (version === 0 && data.length === 20) return { type: 'wpkh', hash: data };\n        else if (version === 1 && data.length === 32) return { type: 'tr', pubkey: data };\n        else throw new Error('Unknown witness program');\n      }\n      const data = base58check.decode(address);\n      if (data.length !== 21) throw new Error('Invalid base58 address');\n      // Pay To Public Key Hash\n      if (data[0] === network.pubKeyHash) {\n        return { type: 'pkh', hash: data.slice(1) };\n      } else if (data[0] === network.scriptHash) {\n        return {\n          type: 'sh',\n          hash: data.slice(1),\n        };\n      }\n      throw new Error(`Invalid address prefix=${data[0]}`);\n    },\n  };\n}\n", "import { hex } from '@scure/base';\nimport * as P from 'micro-packed';\nimport { Address, type CustomScript, OutScript, checkScript, tapLeafHash } from './payment.ts';\nimport * as psbt from './psbt.ts';\nimport {\n  CompactSizeLen,\n  RawOldTx,\n  RawOutput,\n  RawTx,\n  RawWitness,\n  Script,\n  VarBytes,\n} from './script.ts';\nimport * as u from './utils.ts';\nimport { type Bytes, NETWORK, concatBytes, equalBytes, isBytes } from './utils.ts';\n\nconst EMPTY32 = new Uint8Array(32);\nconst EMPTY_OUTPUT: P.UnwrapCoder<typeof RawOutput> = {\n  amount: 0xffffffffffffffffn,\n  script: P.EMPTY,\n};\nexport const toVsize = (weight: number): number => Math.ceil(weight / 4);\n\n// @scure/bip32 interface\ninterface HDKey {\n  publicKey: Bytes;\n  privateKey: Bytes;\n  fingerprint: number;\n  derive(path: string): HDKey;\n  deriveChild(index: number): HDKey;\n  sign(hash: Bytes): Bytes;\n}\n\nexport type Signer = Bytes | HDKey;\n\nexport const PRECISION = 8;\nexport const DEFAULT_VERSION = 2;\nexport const DEFAULT_LOCKTIME = 0;\nexport const DEFAULT_SEQUENCE = 4294967295;\nexport const Decimal: P.Coder<bigint, string> = P.coders.decimal(PRECISION);\n\n// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)\nexport const def = <T>(value: T | undefined, def: T): T => (value === undefined ? def : value);\n\nexport function cloneDeep<T>(obj: T): T {\n  if (Array.isArray(obj)) return obj.map((i) => cloneDeep(i)) as unknown as T;\n  // slice of nodejs Buffer doesn't copy\n  else if (isBytes(obj)) return Uint8Array.from(obj) as unknown as T;\n  // immutable\n  else if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof obj)) return obj;\n  // null is object\n  else if (obj === null) return obj;\n  // should be last, so it won't catch other types\n  else if (typeof obj === 'object') {\n    return Object.fromEntries(\n      Object.entries(obj).map(([k, v]) => [k, cloneDeep(v)])\n    ) as unknown as T;\n  }\n  throw new Error(`cloneDeep: unknown type=${obj} (${typeof obj})`);\n}\n\n// Mostly security features, hardened defaults;\n// but you still can parse other people tx with unspendable outputs and stuff if you want\nexport interface TxOpts {\n  version?: number;\n  lockTime?: number;\n  PSBTVersion?: number;\n  // Flags\n  // Allow non-standard transaction version\n  allowUnknownVersion?: boolean;\n  // Allow output scripts to be unknown scripts (probably unspendable)\n  /** @deprecated Use `allowUnknownOutputs` */\n  allowUnknowOutput?: boolean;\n  allowUnknownOutputs?: boolean;\n  // Try to sign/finalize unknown input. All bets are off, but there is chance that it will work\n  /** @deprecated Use `allowUnknownInputs` */\n  allowUnknowInput?: boolean;\n  allowUnknownInputs?: boolean;\n  // Check input/output scripts for sanity\n  disableScriptCheck?: boolean;\n  // There is strange behaviour where tx without outputs encoded with empty output in the end,\n  // tx without outputs in BIP174 doesn't have itb\n  bip174jsCompat?: boolean;\n  // If transaction data comes from untrusted source, then it can be modified in such way that will\n  // result paying higher mining fee\n  allowLegacyWitnessUtxo?: boolean;\n  lowR?: boolean; // Use lowR signatures\n  customScripts?: CustomScript[]; // UNSAFE: Custom payment scripts\n  // Allow to add additional unknown keys/values to the \"unknown\" array member\n  allowUnknown?: boolean;\n}\n\n/**\n * Internal, exported only for backwards-compat. Use `SigHash` instead.\n * @deprecated\n */\nexport enum SignatureHash {\n  DEFAULT,\n  ALL,\n  NONE,\n  SINGLE,\n  ANYONECANPAY = 0x80,\n}\n\nexport enum SigHash {\n  DEFAULT = SignatureHash.DEFAULT,\n  ALL = SignatureHash.ALL,\n  NONE = SignatureHash.NONE,\n  SINGLE = SignatureHash.SINGLE,\n  DEFAULT_ANYONECANPAY = SignatureHash.DEFAULT | SignatureHash.ANYONECANPAY,\n  ALL_ANYONECANPAY = SignatureHash.ALL | SignatureHash.ANYONECANPAY,\n  NONE_ANYONECANPAY = SignatureHash.NONE | SignatureHash.ANYONECANPAY,\n  SINGLE_ANYONECANPAY = SignatureHash.SINGLE | SignatureHash.ANYONECANPAY,\n}\n\nfunction getTaprootKeys(\n  privKey: Bytes,\n  pubKey: Bytes,\n  internalKey: Bytes,\n  merkleRoot: Bytes = P.EMPTY\n) {\n  if (equalBytes(internalKey, pubKey)) {\n    privKey = u.taprootTweakPrivKey(privKey, merkleRoot);\n    pubKey = u.pubSchnorr(privKey);\n  }\n  return { privKey, pubKey };\n}\n\n// User facing API with decoders\nexport type TransactionInputRequired = {\n  txid: Bytes;\n  index: number;\n  sequence: number;\n  finalScriptSig: Bytes;\n};\n\n// Force check amount/script\nfunction outputBeforeSign(i: psbt.TransactionOutput): psbt.TransactionOutputRequired {\n  if (i.script === undefined || i.amount === undefined)\n    throw new Error('Transaction/output: script and amount required');\n  return { script: i.script, amount: i.amount };\n}\n\n// Force check index/txid/sequence\nexport function inputBeforeSign(i: psbt.TransactionInput): TransactionInputRequired {\n  if (i.txid === undefined || i.index === undefined)\n    throw new Error('Transaction/input: txid and index required');\n  return {\n    txid: i.txid,\n    index: i.index,\n    sequence: def(i.sequence, DEFAULT_SEQUENCE),\n    finalScriptSig: def(i.finalScriptSig, P.EMPTY),\n  };\n}\nfunction cleanFinalInput(i: psbt.TransactionInput) {\n  for (const _k in i) {\n    const k = _k as keyof psbt.TransactionInput;\n    if (!psbt.PSBTInputFinalKeys.includes(k)) delete i[k];\n  }\n}\n\n// (TxHash, Idx)\nconst TxHashIdx = P.struct({ txid: P.bytes(32, true), index: P.U32LE });\n\nfunction validateSigHash(s: SigHash) {\n  if (typeof s !== 'number' || typeof SigHash[s] !== 'string')\n    throw new Error(`Invalid SigHash=${s}`);\n  return s;\n}\n\nfunction unpackSighash(hashType: number) {\n  const masked = hashType & 0b0011111;\n  return {\n    isAny: !!(hashType & SignatureHash.ANYONECANPAY),\n    isNone: masked === SignatureHash.NONE,\n    isSingle: masked === SignatureHash.SINGLE,\n  };\n}\n\nfunction validateOpts(opts: TxOpts): Readonly<TxOpts> {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error(`Wrong object type for transaction options: ${opts}`);\n\n  const _opts = {\n    ...opts,\n    // Defaults\n    version: def(opts.version, DEFAULT_VERSION),\n    lockTime: def(opts.lockTime, 0),\n    PSBTVersion: def(opts.PSBTVersion, 0),\n  };\n  if (typeof _opts.allowUnknowInput !== 'undefined')\n    opts.allowUnknownInputs = _opts.allowUnknowInput;\n  if (typeof _opts.allowUnknowOutput !== 'undefined')\n    opts.allowUnknownOutputs = _opts.allowUnknowOutput;\n  if (typeof _opts.lockTime !== 'number') throw new Error('Transaction lock time should be number');\n  P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime\n  // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which\n  // can lead to constructing broken transactions\n  if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2)\n    throw new Error(`Unknown PSBT version ${_opts.PSBTVersion}`);\n  // Flags\n  for (const k of [\n    'allowUnknownVersion',\n    'allowUnknownOutputs',\n    'allowUnknownInputs',\n    'disableScriptCheck',\n    'bip174jsCompat',\n    'allowLegacyWitnessUtxo',\n    'lowR',\n  ] as const) {\n    const v = _opts[k];\n    if (v === undefined) continue; // optional\n    if (typeof v !== 'boolean')\n      throw new Error(`Transation options wrong type: ${k}=${v} (${typeof v})`);\n  }\n  // 0 and -1 happens in tests\n  if (\n    _opts.allowUnknownVersion\n      ? typeof _opts.version === 'number'\n      : ![-1, 0, 1, 2, 3].includes(_opts.version)\n  )\n    throw new Error(`Unknown version: ${_opts.version}`);\n  if (_opts.customScripts !== undefined) {\n    const cs = _opts.customScripts;\n    if (!Array.isArray(cs)) {\n      throw new Error(\n        `wrong custom scripts type (expected array): customScripts=${cs} (${typeof cs})`\n      );\n    }\n    for (const s of cs) {\n      if (typeof s.encode !== 'function' || typeof s.decode !== 'function')\n        throw new Error(`wrong script=${s} (${typeof s})`);\n      if (s.finalizeTaproot !== undefined && typeof s.finalizeTaproot !== 'function')\n        throw new Error(`wrong script=${s} (${typeof s})`);\n    }\n  }\n  return Object.freeze(_opts);\n}\n\n// NOTE: we cannot do this inside PSBTInput coder, because there is no index/txid at this point!\nfunction validateInput(i: psbt.TransactionInput): psbt.TransactionInput {\n  if (i.nonWitnessUtxo && i.index !== undefined) {\n    const last = i.nonWitnessUtxo.outputs.length - 1;\n    if (i.index > last) throw new Error(`validateInput: index(${i.index}) not in nonWitnessUtxo`);\n    const prevOut = i.nonWitnessUtxo.outputs[i.index];\n    if (\n      i.witnessUtxo &&\n      (!equalBytes(i.witnessUtxo.script, prevOut.script) || i.witnessUtxo.amount !== prevOut.amount)\n    )\n      throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');\n    if (i.txid) {\n      const outputs = i.nonWitnessUtxo.outputs;\n      if (outputs.length - 1 < i.index) throw new Error('nonWitnessUtxo: incorect output index');\n      // At this point, we are using previous tx output to create new input.\n      // Script safety checks are unnecessary:\n      // - User has no control over previous tx. If somebody send money in same tx\n      //   as unspendable output, we still want user able to spend money\n      // - We still want some checks to notify user about possible errors early\n      //   in case user wants to use wrong input by mistake\n      // - Worst case: tx will be rejected by nodes. Still better than disallowing user\n      //   to spend real input, no matter how broken it looks\n      const tx = Transaction.fromRaw(RawTx.encode(i.nonWitnessUtxo), {\n        allowUnknownOutputs: true,\n        disableScriptCheck: true,\n        allowUnknownInputs: true,\n      });\n      const txid = hex.encode(i.txid);\n      // PSBTv2 vectors have non-final tx in inputs\n      if (tx.isFinal && tx.id !== txid)\n        throw new Error(`nonWitnessUtxo: wrong txid, exp=${txid} got=${tx.id}`);\n    }\n  }\n  return i;\n}\n\nexport type PSBTInputs = psbt.PSBTKeyMapKeys<typeof psbt.PSBTInput>;\n\n// Normalizes input\nexport function getPrevOut(input: psbt.TransactionInput): P.UnwrapCoder<typeof RawOutput> {\n  if (input.nonWitnessUtxo) {\n    if (input.index === undefined) throw new Error('Unknown input index');\n    return input.nonWitnessUtxo.outputs[input.index];\n  } else if (input.witnessUtxo) return input.witnessUtxo;\n  else throw new Error('Cannot find previous output info');\n}\n\nexport function normalizeInput(\n  i: psbt.TransactionInputUpdate,\n  cur?: psbt.TransactionInput,\n  allowedFields?: (keyof psbt.TransactionInput)[],\n  disableScriptCheck = false,\n  allowUnknown = false\n): psbt.TransactionInput {\n  let { nonWitnessUtxo, txid } = i;\n  // String support for common fields. We usually prefer Uint8Array to avoid errors\n  // like hex looking string accidentally passed, however, in case of nonWitnessUtxo\n  // it is better to expect string, since constructing this complex object will be\n  // difficult for user\n  if (typeof nonWitnessUtxo === 'string') nonWitnessUtxo = hex.decode(nonWitnessUtxo);\n  if (isBytes(nonWitnessUtxo)) nonWitnessUtxo = RawTx.decode(nonWitnessUtxo);\n  if (!('nonWitnessUtxo' in i) && nonWitnessUtxo === undefined)\n    nonWitnessUtxo = cur?.nonWitnessUtxo;\n  if (typeof txid === 'string') txid = hex.decode(txid);\n  // TODO: if we have nonWitnessUtxo, we can extract txId from here\n  if (txid === undefined) txid = cur?.txid;\n  let res: PSBTInputs = { ...cur, ...i, nonWitnessUtxo, txid };\n  if (!('nonWitnessUtxo' in i) && res.nonWitnessUtxo === undefined) delete res.nonWitnessUtxo;\n  if (res.sequence === undefined) res.sequence = DEFAULT_SEQUENCE;\n  if (res.tapMerkleRoot === null) delete res.tapMerkleRoot;\n  res = psbt.mergeKeyMap(psbt.PSBTInput, res, cur, allowedFields, allowUnknown);\n  psbt.PSBTInputCoder.encode(res); // Validates that everything is correct at this point\n\n  let prevOut;\n  if (res.nonWitnessUtxo && res.index !== undefined)\n    prevOut = res.nonWitnessUtxo.outputs[res.index];\n  else if (res.witnessUtxo) prevOut = res.witnessUtxo;\n  if (prevOut && !disableScriptCheck)\n    checkScript(prevOut && prevOut.script, res.redeemScript, res.witnessScript);\n  return res;\n}\n\nexport function getInputType(input: psbt.TransactionInput, allowLegacyWitnessUtxo = false) {\n  let txType = 'legacy';\n  let defaultSighash = SignatureHash.ALL;\n  const prevOut = getPrevOut(input);\n  const first = OutScript.decode(prevOut.script);\n  let type = first.type;\n  let cur = first;\n  const stack = [first];\n  if (first.type === 'tr') {\n    defaultSighash = SignatureHash.DEFAULT;\n    return {\n      txType: 'taproot',\n      type: 'tr',\n      last: first,\n      lastScript: prevOut.script,\n      defaultSighash,\n      sighash: input.sighashType || defaultSighash,\n    };\n  } else {\n    if (first.type === 'wpkh' || first.type === 'wsh') txType = 'segwit';\n    if (first.type === 'sh') {\n      if (!input.redeemScript) throw new Error('inputType: sh without redeemScript');\n      let child = OutScript.decode(input.redeemScript);\n      if (child.type === 'wpkh' || child.type === 'wsh') txType = 'segwit';\n      stack.push(child);\n      cur = child;\n      type += `-${child.type}`;\n    }\n    // wsh can be inside sh\n    if (cur.type === 'wsh') {\n      if (!input.witnessScript) throw new Error('inputType: wsh without witnessScript');\n      let child = OutScript.decode(input.witnessScript);\n      if (child.type === 'wsh') txType = 'segwit';\n      stack.push(child);\n      cur = child;\n      type += `-${child.type}`;\n    }\n    const last = stack[stack.length - 1];\n    if (last.type === 'sh' || last.type === 'wsh')\n      throw new Error('inputType: sh/wsh cannot be terminal type');\n    const lastScript = OutScript.encode(last);\n    const res = {\n      type,\n      txType,\n      last,\n      lastScript,\n      defaultSighash,\n      sighash: input.sighashType || defaultSighash,\n    };\n    if (txType === 'legacy' && !allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {\n      throw new Error(\n        `Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure`\n      );\n    }\n    return res;\n  }\n}\n\nexport class Transaction {\n  private global: psbt.PSBTKeyMapKeys<typeof psbt.PSBTGlobal> = {};\n  private inputs: psbt.TransactionInput[] = []; // use getInput()\n  private outputs: psbt.TransactionOutput[] = []; // use getOutput()\n  readonly opts: ReturnType<typeof validateOpts>;\n  constructor(opts: TxOpts = {}) {\n    const _opts = (this.opts = validateOpts(opts));\n    // Merge with global structure of PSBTv2\n    if (_opts.lockTime !== DEFAULT_LOCKTIME) this.global.fallbackLocktime = _opts.lockTime;\n    this.global.txVersion = _opts.version;\n  }\n\n  // Import\n  static fromRaw(raw: Bytes, opts: TxOpts = {}): Transaction {\n    const parsed = RawTx.decode(raw);\n    const tx = new Transaction({ ...opts, version: parsed.version, lockTime: parsed.lockTime });\n    for (const o of parsed.outputs) tx.addOutput(o);\n    tx.outputs = parsed.outputs;\n    tx.inputs = parsed.inputs;\n    if (parsed.witnesses) {\n      for (let i = 0; i < parsed.witnesses.length; i++)\n        tx.inputs[i].finalScriptWitness = parsed.witnesses[i];\n    }\n    return tx;\n  }\n  // PSBT\n  static fromPSBT(psbt_: Bytes, opts: TxOpts = {}): Transaction {\n    let parsed: P.UnwrapCoder<typeof psbt.RawPSBTV0>;\n    try {\n      parsed = psbt.RawPSBTV0.decode(psbt_);\n    } catch (e0) {\n      try {\n        parsed = psbt.RawPSBTV2.decode(psbt_);\n      } catch (e2) {\n        // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error\n        throw e0;\n      }\n    }\n    const PSBTVersion = parsed.global.version || 0;\n    if (PSBTVersion !== 0 && PSBTVersion !== 2)\n      throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n    const unsigned = parsed.global.unsignedTx;\n    const version = PSBTVersion === 0 ? unsigned?.version : parsed.global.txVersion;\n    const lockTime = PSBTVersion === 0 ? unsigned?.lockTime : parsed.global.fallbackLocktime;\n    const tx = new Transaction({ ...opts, version, lockTime, PSBTVersion });\n    // We need slice here, because otherwise\n    const inputCount = PSBTVersion === 0 ? unsigned?.inputs.length : parsed.global.inputCount;\n    tx.inputs = parsed.inputs.slice(0, inputCount).map((i, j) =>\n      validateInput({\n        finalScriptSig: P.EMPTY,\n        ...parsed.global.unsignedTx?.inputs[j],\n        ...i,\n      })\n    );\n    const outputCount = PSBTVersion === 0 ? unsigned?.outputs.length : parsed.global.outputCount;\n    tx.outputs = parsed.outputs.slice(0, outputCount).map((i, j) => ({\n      ...i,\n      ...parsed.global.unsignedTx?.outputs[j],\n    }));\n    tx.global = { ...parsed.global, txVersion: version }; // just in case proprietary/unknown fields\n    if (lockTime !== DEFAULT_LOCKTIME) tx.global.fallbackLocktime = lockTime;\n    return tx;\n  }\n  toPSBT(PSBTVersion: number | undefined = this.opts.PSBTVersion): Uint8Array {\n    if (PSBTVersion !== 0 && PSBTVersion !== 2)\n      throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n    // if (PSBTVersion === 0 && this.inputs.length === 0) {\n    //   throw new Error(\n    //     'PSBT version=0 export for transaction without inputs disabled, please use version=2. Please check `toPSBT` method for explanation.'\n    //   );\n    // }\n    const inputs = this.inputs.map((i) =>\n      validateInput(psbt.cleanPSBTFields(PSBTVersion, psbt.PSBTInput, i))\n    );\n    for (const inp of inputs) {\n      // Don't serialize empty fields\n      if (inp.partialSig && !inp.partialSig.length) delete inp.partialSig;\n      if (inp.finalScriptSig && !inp.finalScriptSig.length) delete inp.finalScriptSig;\n      if (inp.finalScriptWitness && !inp.finalScriptWitness.length) delete inp.finalScriptWitness;\n    }\n    const outputs = this.outputs.map((i) => psbt.cleanPSBTFields(PSBTVersion, psbt.PSBTOutput, i));\n    const global = { ...this.global };\n    if (PSBTVersion === 0) {\n      /*\n      - Bitcoin raw transaction expects to have at least 1 input because it uses case with zero inputs as marker for SegWit\n      - this means we cannot serialize raw tx with zero inputs since it will be parsed as SegWit tx\n      - Parsing of PSBTv0 depends on unsignedTx (it looks for input count here)\n      - BIP-174 requires old serialization format (without witnesses) inside global, which solves this\n      */\n      global.unsignedTx = RawOldTx.decode(\n        RawOldTx.encode({\n          version: this.version,\n          lockTime: this.lockTime,\n          inputs: this.inputs.map(inputBeforeSign).map((i) => ({\n            ...i,\n            finalScriptSig: P.EMPTY,\n          })),\n          outputs: this.outputs.map(outputBeforeSign),\n        })\n      );\n      delete global.fallbackLocktime;\n      delete global.txVersion;\n    } else {\n      global.version = PSBTVersion;\n      global.txVersion = this.version;\n      global.inputCount = this.inputs.length;\n      global.outputCount = this.outputs.length;\n      if (global.fallbackLocktime && global.fallbackLocktime === DEFAULT_LOCKTIME)\n        delete global.fallbackLocktime;\n    }\n    if (this.opts.bip174jsCompat) {\n      if (!inputs.length) inputs.push({});\n      if (!outputs.length) outputs.push({});\n    }\n    return (PSBTVersion === 0 ? psbt.RawPSBTV0 : psbt.RawPSBTV2).encode({\n      global,\n      inputs,\n      outputs,\n    });\n  }\n\n  // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)\n  get lockTime(): number {\n    let height = DEFAULT_LOCKTIME;\n    let heightCnt = 0;\n    let time = DEFAULT_LOCKTIME;\n    let timeCnt = 0;\n    for (const i of this.inputs) {\n      if (i.requiredHeightLocktime) {\n        height = Math.max(height, i.requiredHeightLocktime);\n        heightCnt++;\n      }\n      if (i.requiredTimeLocktime) {\n        time = Math.max(time, i.requiredTimeLocktime);\n        timeCnt++;\n      }\n    }\n    if (heightCnt && heightCnt >= timeCnt) return height;\n    if (time !== DEFAULT_LOCKTIME) return time;\n    return this.global.fallbackLocktime || DEFAULT_LOCKTIME;\n  }\n\n  get version(): number {\n    // Should be not possible\n    if (this.global.txVersion === undefined) throw new Error('No global.txVersion');\n    return this.global.txVersion;\n  }\n\n  private inputStatus(idx: number) {\n    this.checkInputIdx(idx);\n    const input = this.inputs[idx];\n    // Finalized\n    if (input.finalScriptSig && input.finalScriptSig.length) return 'finalized';\n    if (input.finalScriptWitness && input.finalScriptWitness.length) return 'finalized';\n    // Signed taproot\n    if (input.tapKeySig) return 'signed';\n    if (input.tapScriptSig && input.tapScriptSig.length) return 'signed';\n    // Signed\n    if (input.partialSig && input.partialSig.length) return 'signed';\n    return 'unsigned';\n  }\n  // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range\n  // We will lose some vectors -> smaller test coverage of preimages (very important!)\n  private inputSighash(idx: number) {\n    this.checkInputIdx(idx);\n    const inputSighash = this.inputs[idx].sighashType;\n    const sighash = inputSighash === undefined ? SignatureHash.DEFAULT : inputSighash;\n    // ALL or DEFAULT -- everything signed\n    // NONE           -- all inputs + no outputs\n    // SINGLE         -- all inputs + output with same index\n    // ALL + ANYONE   -- specific input + all outputs\n    // NONE + ANYONE  -- specific input + no outputs\n    // SINGLE         -- specific inputs + output with same index\n    const sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 0b11;\n    const sigInputs = sighash & SignatureHash.ANYONECANPAY;\n    return { sigInputs, sigOutputs };\n  }\n  // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.\n  // Some cache will be nice, but there chance to have bugs with cache invalidation\n  private signStatus() {\n    // if addInput or addOutput is not possible, then all inputs or outputs are signed\n    let addInput = true,\n      addOutput = true;\n    let inputs = [],\n      outputs = [];\n    for (let idx = 0; idx < this.inputs.length; idx++) {\n      const status = this.inputStatus(idx);\n      // Unsigned input doesn't affect anything\n      if (status === 'unsigned') continue;\n      const { sigInputs, sigOutputs } = this.inputSighash(idx);\n      // Input type\n      if (sigInputs === SignatureHash.ANYONECANPAY) inputs.push(idx);\n      else addInput = false;\n      // Output type\n      if (sigOutputs === SignatureHash.ALL) addOutput = false;\n      else if (sigOutputs === SignatureHash.SINGLE) outputs.push(idx);\n      else if (sigOutputs === SignatureHash.NONE) {\n        // Doesn't affect any outputs at all\n      } else throw new Error(`Wrong signature hash output type: ${sigOutputs}`);\n    }\n    return { addInput, addOutput, inputs, outputs };\n  }\n\n  get isFinal(): boolean {\n    for (let idx = 0; idx < this.inputs.length; idx++)\n      if (this.inputStatus(idx) !== 'finalized') return false;\n    return true;\n  }\n\n  // Info utils\n  get hasWitnesses(): boolean {\n    let out = false;\n    for (const i of this.inputs)\n      if (i.finalScriptWitness && i.finalScriptWitness.length) out = true;\n    return out;\n  }\n  // https://en.bitcoin.it/wiki/Weight_units\n  get weight(): number {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    let out = 32;\n    // Outputs\n    const outputs = this.outputs.map(outputBeforeSign);\n    out += 4 * CompactSizeLen.encode(this.outputs.length).length;\n    for (const o of outputs) out += 32 + 4 * VarBytes.encode(o.script).length;\n    // Inputs\n    if (this.hasWitnesses) out += 2;\n    out += 4 * CompactSizeLen.encode(this.inputs.length).length;\n    for (const i of this.inputs) {\n      out += 160 + 4 * VarBytes.encode(i.finalScriptSig || P.EMPTY).length;\n      if (this.hasWitnesses && i.finalScriptWitness)\n        out += RawWitness.encode(i.finalScriptWitness).length;\n    }\n    return out;\n  }\n  get vsize(): number {\n    return toVsize(this.weight);\n  }\n  toBytes(withScriptSig = false, withWitness = false): Uint8Array {\n    return RawTx.encode({\n      version: this.version,\n      lockTime: this.lockTime,\n      inputs: this.inputs.map(inputBeforeSign).map((i) => ({\n        ...i,\n        finalScriptSig: (withScriptSig && i.finalScriptSig) || P.EMPTY,\n      })),\n      outputs: this.outputs.map(outputBeforeSign),\n      witnesses: this.inputs.map((i) => i.finalScriptWitness || []),\n      segwitFlag: withWitness && this.hasWitnesses,\n    });\n  }\n  get unsignedTx(): Bytes {\n    return this.toBytes(false, false);\n  }\n  get hex(): string {\n    return hex.encode(this.toBytes(true, this.hasWitnesses));\n  }\n\n  get hash(): string {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    return hex.encode(u.sha256x2(this.toBytes(true)));\n  }\n  get id(): string {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    return hex.encode(u.sha256x2(this.toBytes(true)).reverse());\n  }\n  // Input stuff\n  private checkInputIdx(idx: number) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length)\n      throw new Error(`Wrong input index=${idx}`);\n  }\n  getInput(idx: number): psbt.TransactionInput {\n    this.checkInputIdx(idx);\n    return cloneDeep(this.inputs[idx]);\n  }\n  get inputsLength(): number {\n    return this.inputs.length;\n  }\n  // Modification\n  addInput(input: psbt.TransactionInputUpdate, _ignoreSignStatus = false): number {\n    if (!_ignoreSignStatus && !this.signStatus().addInput)\n      throw new Error('Tx has signed inputs, cannot add new one');\n    this.inputs.push(normalizeInput(input, undefined, undefined, this.opts.disableScriptCheck));\n    return this.inputs.length - 1;\n  }\n  updateInput(idx: number, input: psbt.TransactionInputUpdate, _ignoreSignStatus = false): void {\n    this.checkInputIdx(idx);\n    let allowedFields = undefined;\n    if (!_ignoreSignStatus) {\n      const status = this.signStatus();\n      if (!status.addInput || status.inputs.includes(idx))\n        allowedFields = psbt.PSBTInputUnsignedKeys;\n    }\n    this.inputs[idx] = normalizeInput(\n      input,\n      this.inputs[idx],\n      allowedFields,\n      this.opts.disableScriptCheck,\n      this.opts.allowUnknown\n    );\n  }\n  // Output stuff\n  private checkOutputIdx(idx: number) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length)\n      throw new Error(`Wrong output index=${idx}`);\n  }\n  getOutput(idx: number): psbt.TransactionOutput {\n    this.checkOutputIdx(idx);\n    return cloneDeep(this.outputs[idx]);\n  }\n  getOutputAddress(idx: number, network: u.BTC_NETWORK = NETWORK): string | undefined {\n    const out = this.getOutput(idx);\n    if (!out.script) return;\n    return Address(network).encode(OutScript.decode(out.script));\n  }\n\n  get outputsLength(): number {\n    return this.outputs.length;\n  }\n  private normalizeOutput(\n    o: psbt.TransactionOutputUpdate,\n    cur?: psbt.TransactionOutput,\n    allowedFields?: (keyof typeof psbt.PSBTOutput)[]\n  ): psbt.TransactionOutput {\n    let { amount, script } = o;\n    if (amount === undefined) amount = cur?.amount;\n    if (typeof amount !== 'bigint')\n      throw new Error(\n        `Wrong amount type, should be of type bigint in sats, but got ${amount} of type ${typeof amount}`\n      );\n    if (typeof script === 'string') script = hex.decode(script);\n    if (script === undefined) script = cur?.script;\n    let res: psbt.PSBTKeyMapKeys<typeof psbt.PSBTOutput> = { ...cur, ...o, amount, script };\n    if (res.amount === undefined) delete res.amount;\n    res = psbt.mergeKeyMap(psbt.PSBTOutput, res, cur, allowedFields, this.opts.allowUnknown);\n    psbt.PSBTOutputCoder.encode(res);\n    if (\n      res.script &&\n      !this.opts.allowUnknownOutputs &&\n      OutScript.decode(res.script).type === 'unknown'\n    ) {\n      throw new Error(\n        'Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure'\n      );\n    }\n    if (!this.opts.disableScriptCheck) checkScript(res.script, res.redeemScript, res.witnessScript);\n    return res;\n  }\n  addOutput(o: psbt.TransactionOutputUpdate, _ignoreSignStatus = false): number {\n    if (!_ignoreSignStatus && !this.signStatus().addOutput)\n      throw new Error('Tx has signed outputs, cannot add new one');\n    this.outputs.push(this.normalizeOutput(o));\n    return this.outputs.length - 1;\n  }\n  updateOutput(idx: number, output: psbt.TransactionOutputUpdate, _ignoreSignStatus = false): void {\n    this.checkOutputIdx(idx);\n    let allowedFields = undefined;\n    if (!_ignoreSignStatus) {\n      const status = this.signStatus();\n      if (!status.addOutput || status.outputs.includes(idx))\n        allowedFields = psbt.PSBTOutputUnsignedKeys;\n    }\n    this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);\n  }\n  addOutputAddress(address: string, amount: bigint, network: u.BTC_NETWORK = NETWORK): number {\n    return this.addOutput({ script: OutScript.encode(Address(network).decode(address)), amount });\n  }\n  // Utils\n  get fee(): bigint {\n    let res = 0n;\n    for (const i of this.inputs) {\n      const prevOut = getPrevOut(i);\n      if (!prevOut) throw new Error('Empty input amount');\n      res += prevOut.amount;\n    }\n    const outputs = this.outputs.map(outputBeforeSign);\n    for (const o of outputs) res -= o.amount;\n    return res;\n  }\n\n  // Signing\n  // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624\n  // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,\n  // but we are trying to be less complicated for audit purpose for now.\n  private preimageLegacy(idx: number, prevOutScript: Bytes, hashType: number) {\n    const { isAny, isNone, isSingle } = unpackSighash(hashType);\n    if (idx < 0 || !Number.isSafeInteger(idx)) throw new Error(`Invalid input idx=${idx}`);\n    if ((isSingle && idx >= this.outputs.length) || idx >= this.inputs.length)\n      return P.U256BE.encode(1n);\n    prevOutScript = Script.encode(\n      Script.decode(prevOutScript).filter((i) => i !== 'CODESEPARATOR')\n    );\n    let inputs: TransactionInputRequired[] = this.inputs\n      .map(inputBeforeSign)\n      .map((input, inputIdx) => ({\n        ...input,\n        finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY,\n      }));\n    if (isAny) inputs = [inputs[idx]];\n    else if (isNone || isSingle) {\n      inputs = inputs.map((input, inputIdx) => ({\n        ...input,\n        sequence: inputIdx === idx ? input.sequence : 0,\n      }));\n    }\n    let outputs = this.outputs.map(outputBeforeSign);\n    if (isNone) outputs = [];\n    else if (isSingle) {\n      outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([outputs[idx]]);\n    }\n    const tmpTx = RawTx.encode({\n      lockTime: this.lockTime,\n      version: this.version,\n      segwitFlag: false,\n      inputs,\n      outputs,\n    });\n    return u.sha256x2(tmpTx, P.I32LE.encode(hashType));\n  }\n  preimageWitnessV0(\n    idx: number,\n    prevOutScript: Bytes,\n    hashType: number,\n    amount: bigint\n  ): Uint8Array {\n    const { isAny, isNone, isSingle } = unpackSighash(hashType);\n    let inputHash = EMPTY32;\n    let sequenceHash = EMPTY32;\n    let outputHash = EMPTY32;\n    const inputs = this.inputs.map(inputBeforeSign);\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (!isAny) inputHash = u.sha256x2(...inputs.map(TxHashIdx.encode));\n    if (!isAny && !isSingle && !isNone)\n      sequenceHash = u.sha256x2(...inputs.map((i) => P.U32LE.encode(i.sequence)));\n    if (!isSingle && !isNone) {\n      outputHash = u.sha256x2(...outputs.map(RawOutput.encode));\n    } else if (isSingle && idx < outputs.length)\n      outputHash = u.sha256x2(RawOutput.encode(outputs[idx]));\n    const input = inputs[idx];\n    return u.sha256x2(\n      P.I32LE.encode(this.version),\n      inputHash,\n      sequenceHash,\n      P.bytes(32, true).encode(input.txid),\n      P.U32LE.encode(input.index),\n      VarBytes.encode(prevOutScript),\n      P.U64LE.encode(amount),\n      P.U32LE.encode(input.sequence),\n      outputHash,\n      P.U32LE.encode(this.lockTime),\n      P.U32LE.encode(hashType)\n    );\n  }\n  preimageWitnessV1(\n    idx: number,\n    prevOutScript: Bytes[],\n    hashType: number,\n    amount: bigint[],\n    codeSeparator = -1,\n    leafScript?: Bytes,\n    leafVer = 0xc0,\n    annex?: Bytes\n  ): Uint8Array {\n    if (!Array.isArray(amount) || this.inputs.length !== amount.length)\n      throw new Error(`Invalid amounts array=${amount}`);\n    if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length)\n      throw new Error(`Invalid prevOutScript array=${prevOutScript}`);\n    const out: Bytes[] = [\n      P.U8.encode(0),\n      P.U8.encode(hashType), // U8 sigHash\n      P.I32LE.encode(this.version),\n      P.U32LE.encode(this.lockTime),\n    ];\n    const outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 0b11;\n    const inType = hashType & SignatureHash.ANYONECANPAY;\n    const inputs = this.inputs.map(inputBeforeSign);\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (inType !== SignatureHash.ANYONECANPAY) {\n      out.push(\n        ...[\n          inputs.map(TxHashIdx.encode),\n          amount.map(P.U64LE.encode),\n          prevOutScript.map(VarBytes.encode),\n          inputs.map((i) => P.U32LE.encode(i.sequence)),\n        ].map((i) => u.sha256(concatBytes(...i)))\n      );\n    }\n    if (outType === SignatureHash.ALL) {\n      out.push(u.sha256(concatBytes(...outputs.map(RawOutput.encode))));\n    }\n    const spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);\n    out.push(new Uint8Array([spendType]));\n    if (inType === SignatureHash.ANYONECANPAY) {\n      const inp = inputs[idx];\n      out.push(\n        TxHashIdx.encode(inp),\n        P.U64LE.encode(amount[idx]),\n        VarBytes.encode(prevOutScript[idx]),\n        P.U32LE.encode(inp.sequence)\n      );\n    } else out.push(P.U32LE.encode(idx));\n    if (spendType & 1) out.push(u.sha256(VarBytes.encode(annex || P.EMPTY)));\n    if (outType === SignatureHash.SINGLE)\n      out.push(idx < outputs.length ? u.sha256(RawOutput.encode(outputs[idx])) : EMPTY32);\n    if (leafScript)\n      out.push(tapLeafHash(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));\n    return u.tagSchnorr('TapSighash', ...out);\n  }\n  // Signer can be privateKey OR instance of bip32 HD stuff\n  signIdx(privateKey: Signer, idx: number, allowedSighash?: SigHash[], _auxRand?: Bytes): boolean {\n    this.checkInputIdx(idx);\n    const input = this.inputs[idx];\n    const inputType = getInputType(input, this.opts.allowLegacyWitnessUtxo);\n    // Handle BIP32 HDKey\n    if (!isBytes(privateKey)) {\n      if (!input.bip32Derivation || !input.bip32Derivation.length)\n        throw new Error('bip32Derivation: empty');\n      const signers = input.bip32Derivation\n        .filter((i) => i[1].fingerprint == (privateKey as HDKey).fingerprint)\n        .map(([pubKey, { path }]) => {\n          let s = privateKey as HDKey;\n          for (const i of path) s = s.deriveChild(i);\n          if (!equalBytes(s.publicKey, pubKey)) throw new Error('bip32Derivation: wrong pubKey');\n          if (!s.privateKey) throw new Error('bip32Derivation: no privateKey');\n          return s;\n        });\n      if (!signers.length)\n        throw new Error(`bip32Derivation: no items with fingerprint=${privateKey.fingerprint}`);\n      let signed = false;\n      for (const s of signers) if (this.signIdx(s.privateKey, idx)) signed = true;\n      return signed;\n    }\n    // Sighash checks\n    // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.\n    if (!allowedSighash) allowedSighash = [inputType.defaultSighash as unknown as SigHash];\n    else allowedSighash.forEach(validateSigHash);\n    const sighash = inputType.sighash;\n    if (!allowedSighash.includes(sighash)) {\n      throw new Error(\n        `Input with not allowed sigHash=${sighash}. Allowed: ${allowedSighash.join(', ')}`\n      );\n    }\n    // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),\n    // however this was because of bug in bitcoin-core, which remains here because of consensus.\n    // If this is absolutely neccessary for your case, please open issue.\n    // We disable it to avoid complicated workflow where SINGLE will block adding new outputs\n    const { sigOutputs } = this.inputSighash(idx);\n    if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {\n      throw new Error(\n        `Input with sighash SINGLE, but there is no output with corresponding index=${idx}`\n      );\n    }\n\n    // Actual signing\n    // Taproot\n    const prevOut = getPrevOut(input);\n    if (inputType.txType === 'taproot') {\n      const prevOuts = this.inputs.map(getPrevOut);\n      const prevOutScript = prevOuts.map((i) => i.script);\n      const amount = prevOuts.map((i) => i.amount);\n      let signed = false;\n      let schnorrPub = u.pubSchnorr(privateKey);\n      let merkleRoot = input.tapMerkleRoot || P.EMPTY;\n      if (input.tapInternalKey) {\n        // internal + tweak = tweaked key\n        // if internal key == current public key, we need to tweak private key,\n        // otherwise sign as is. bitcoinjs implementation always wants tweaked\n        // priv key to be provided\n        const { pubKey, privKey } = getTaprootKeys(\n          privateKey,\n          schnorrPub,\n          input.tapInternalKey,\n          merkleRoot\n        );\n        const [taprootPubKey, _] = u.taprootTweakPubkey(input.tapInternalKey, merkleRoot);\n        if (equalBytes(taprootPubKey, pubKey)) {\n          const hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);\n          const sig = concatBytes(\n            u.signSchnorr(hash, privKey, _auxRand),\n            sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY\n          );\n          this.updateInput(idx, { tapKeySig: sig }, true);\n          signed = true;\n        }\n      }\n      if (input.tapLeafScript) {\n        input.tapScriptSig = input.tapScriptSig || [];\n        for (const [_, _script] of input.tapLeafScript) {\n          const script = _script.subarray(0, -1);\n          const scriptDecoded = Script.decode(script);\n          const ver = _script[_script.length - 1];\n          const hash = tapLeafHash(script, ver);\n          // NOTE: no need to tweak internal key here, since we don't support nested p2tr\n          const pos = scriptDecoded.findIndex((i) => isBytes(i) && equalBytes(i, schnorrPub));\n          // Skip if there is no public key in tapLeafScript\n          if (pos === -1) continue;\n          const msg = this.preimageWitnessV1(\n            idx,\n            prevOutScript,\n            sighash,\n            amount,\n            undefined,\n            script,\n            ver\n          );\n          const sig = concatBytes(\n            u.signSchnorr(msg, privateKey, _auxRand),\n            sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY\n          );\n          this.updateInput(\n            idx,\n            { tapScriptSig: [[{ pubKey: schnorrPub, leafHash: hash }, sig]] },\n            true\n          );\n          signed = true;\n        }\n      }\n      if (!signed) throw new Error('No taproot scripts signed');\n      return true;\n    } else {\n      // only compressed keys are supported for now\n      const pubKey = u.pubECDSA(privateKey);\n      // TODO: replace with explicit checks\n      // Check if script has public key or its has inside\n      let hasPubkey = false;\n      const pubKeyHash = u.hash160(pubKey);\n      for (const i of Script.decode(inputType.lastScript)) {\n        if (isBytes(i) && (equalBytes(i, pubKey) || equalBytes(i, pubKeyHash))) hasPubkey = true;\n      }\n      if (!hasPubkey) throw new Error(`Input script doesn't have pubKey: ${inputType.lastScript}`);\n      let hash;\n      if (inputType.txType === 'legacy') {\n        hash = this.preimageLegacy(idx, inputType.lastScript, sighash);\n      } else if (inputType.txType === 'segwit') {\n        let script = inputType.lastScript;\n        // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok\n        if (inputType.last.type === 'wpkh')\n          script = OutScript.encode({ type: 'pkh', hash: inputType.last.hash });\n        hash = this.preimageWitnessV0(idx, script, sighash, prevOut.amount);\n      } else throw new Error(`Transaction/sign: unknown tx type: ${inputType.txType}`);\n      const sig = u.signECDSA(hash, privateKey, this.opts.lowR);\n      this.updateInput(\n        idx,\n        {\n          partialSig: [[pubKey, concatBytes(sig, new Uint8Array([sighash]))]],\n        },\n        true\n      );\n    }\n    return true;\n  }\n  // This is bad API. Will work if user creates and signs tx, but if\n  // there is some complex workflow with exchanging PSBT and signing them,\n  // then it is better to validate which output user signs. How could a better API look like?\n  // Example: user adds input, sends to another party, then signs received input (mixer etc),\n  // another user can add different input for same key and user will sign it.\n  // Even worse: another user can add bip32 derivation, and spend money from different address.\n  // Better api: signIdx\n  sign(privateKey: Signer, allowedSighash?: number[], _auxRand?: Bytes): number {\n    let num = 0;\n    for (let i = 0; i < this.inputs.length; i++) {\n      try {\n        if (this.signIdx(privateKey, i, allowedSighash, _auxRand)) num++;\n      } catch (e) {}\n    }\n    if (!num) throw new Error('No inputs signed');\n    return num;\n  }\n\n  finalizeIdx(idx: number): void {\n    this.checkInputIdx(idx);\n    if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n    const input = this.inputs[idx];\n    const inputType = getInputType(input, this.opts.allowLegacyWitnessUtxo);\n    // Taproot finalize\n    if (inputType.txType === 'taproot') {\n      if (input.tapKeySig) input.finalScriptWitness = [input.tapKeySig];\n      else if (input.tapLeafScript && input.tapScriptSig) {\n        // Sort leafs by control block length.\n        const leafs = input.tapLeafScript.sort(\n          (a, b) =>\n            psbt.TaprootControlBlock.encode(a[0]).length -\n            psbt.TaprootControlBlock.encode(b[0]).length\n        );\n        for (const [cb, _script] of leafs) {\n          // Last byte is version\n          const script = _script.slice(0, -1);\n          const ver = _script[_script.length - 1];\n          const outScript = OutScript.decode(script);\n          const hash = tapLeafHash(script, ver);\n          const scriptSig = input.tapScriptSig.filter((i) => equalBytes(i[0].leafHash, hash));\n          let signatures: Bytes[] = [];\n          if (outScript.type === 'tr_ms') {\n            const m = outScript.m;\n            const pubkeys = outScript.pubkeys;\n            let added = 0;\n            for (const pub of pubkeys) {\n              const sigIdx = scriptSig.findIndex((i) => equalBytes(i[0].pubKey, pub));\n              // Should have exact amount of signatures (more -- will fail)\n              if (added === m || sigIdx === -1) {\n                signatures.push(P.EMPTY);\n                continue;\n              }\n              signatures.push(scriptSig[sigIdx][1]);\n              added++;\n            }\n            // Should be exact same as m\n            if (added !== m) continue;\n          } else if (outScript.type === 'tr_ns') {\n            for (const pub of outScript.pubkeys) {\n              const sigIdx = scriptSig.findIndex((i) => equalBytes(i[0].pubKey, pub));\n              if (sigIdx === -1) continue;\n              signatures.push(scriptSig[sigIdx][1]);\n            }\n            if (signatures.length !== outScript.pubkeys.length) continue;\n          } else if (outScript.type === 'unknown' && this.opts.allowUnknownInputs) {\n            // Trying our best to sign what we can\n            const scriptDecoded = Script.decode(script);\n            signatures = scriptSig\n              .map(([{ pubKey }, signature]) => {\n                const pos = scriptDecoded.findIndex((i) => isBytes(i) && equalBytes(i, pubKey));\n                if (pos === -1)\n                  throw new Error('finalize/taproot: cannot find position of pubkey in script');\n                return { signature, pos };\n              })\n              // Reverse order (because witness is stack and we take last element first from it)\n              .sort((a, b) => a.pos - b.pos)\n              .map((i) => i.signature);\n            if (!signatures.length) continue;\n          } else {\n            const custom = this.opts.customScripts;\n            if (custom) {\n              for (const c of custom) {\n                if (!c.finalizeTaproot) continue;\n                const scriptDecoded = Script.decode(script);\n                const csEncoded = c.encode(scriptDecoded);\n                if (csEncoded === undefined) continue;\n                const finalized = c.finalizeTaproot(script, csEncoded, scriptSig);\n                if (!finalized) continue;\n                input.finalScriptWitness = finalized.concat(psbt.TaprootControlBlock.encode(cb));\n                input.finalScriptSig = P.EMPTY;\n                cleanFinalInput(input);\n                return;\n              }\n            }\n            throw new Error('Finalize: Unknown tapLeafScript');\n          }\n          // Witness is stack, so last element will be used first\n          input.finalScriptWitness = signatures\n            .reverse()\n            .concat([script, psbt.TaprootControlBlock.encode(cb)]);\n          break;\n        }\n        if (!input.finalScriptWitness) throw new Error('finalize/taproot: empty witness');\n      } else throw new Error('finalize/taproot: unknown input');\n      input.finalScriptSig = P.EMPTY;\n      cleanFinalInput(input);\n      return;\n    }\n    if (!input.partialSig || !input.partialSig.length) throw new Error('Not enough partial sign');\n\n    let inputScript: Bytes = P.EMPTY;\n    let witness: Bytes[] = [];\n    // TODO: move input scripts closer to payments/output scripts\n    // Multisig\n    if (inputType.last.type === 'ms') {\n      const m = inputType.last.m;\n      const pubkeys = inputType.last.pubkeys;\n      let signatures = [];\n      // partial: [pubkey, sign]\n      for (const pub of pubkeys) {\n        const sign = input.partialSig.find((s) => equalBytes(pub, s[0]));\n        if (!sign) continue;\n        signatures.push(sign[1]);\n      }\n      signatures = signatures.slice(0, m);\n      if (signatures.length !== m) {\n        throw new Error(\n          `Multisig: wrong signatures count, m=${m} n=${pubkeys.length} signatures=${signatures.length}`\n        );\n      }\n      inputScript = Script.encode([0, ...signatures]);\n    } else if (inputType.last.type === 'pk') {\n      inputScript = Script.encode([input.partialSig[0][1]]);\n    } else if (inputType.last.type === 'pkh') {\n      inputScript = Script.encode([input.partialSig[0][1], input.partialSig[0][0]]);\n    } else if (inputType.last.type === 'wpkh') {\n      inputScript = P.EMPTY;\n      witness = [input.partialSig[0][1], input.partialSig[0][0]];\n    } else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs)\n      throw new Error('Unknown inputs not allowed');\n\n    // Create final scripts (generic part)\n    let finalScriptSig: Bytes | undefined, finalScriptWitness: Bytes[] | undefined;\n    if (inputType.type.includes('wsh-')) {\n      // P2WSH\n      if (inputScript.length && inputType.lastScript.length) {\n        witness = Script.decode(inputScript).map((i) => {\n          if (i === 0) return P.EMPTY;\n          if (isBytes(i)) return i;\n          throw new Error(`Wrong witness op=${i}`);\n        });\n      }\n      witness = witness.concat(inputType.lastScript);\n    }\n    if (inputType.txType === 'segwit') finalScriptWitness = witness;\n    if (inputType.type.startsWith('sh-wsh-')) {\n      finalScriptSig = Script.encode([Script.encode([0, u.sha256(inputType.lastScript)])]);\n    } else if (inputType.type.startsWith('sh-')) {\n      finalScriptSig = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n    } else if (inputType.type.startsWith('wsh-')) {\n    } else if (inputType.txType !== 'segwit') finalScriptSig = inputScript;\n\n    if (!finalScriptSig && !finalScriptWitness) throw new Error('Unknown error finalizing input');\n    if (finalScriptSig) input.finalScriptSig = finalScriptSig;\n    if (finalScriptWitness) input.finalScriptWitness = finalScriptWitness;\n    cleanFinalInput(input);\n  }\n  finalize(): void {\n    for (let i = 0; i < this.inputs.length; i++) this.finalizeIdx(i);\n  }\n  extract(): Uint8Array {\n    if (!this.isFinal) throw new Error('Transaction has unfinalized inputs');\n    if (!this.outputs.length) throw new Error('Transaction has no outputs');\n    if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n    return this.toBytes(true, true);\n  }\n  combine(other: Transaction): this {\n    for (const k of ['PSBTVersion', 'version', 'lockTime'] as const) {\n      if (this.opts[k] !== other.opts[k]) {\n        throw new Error(\n          `Transaction/combine: different ${k} this=${this.opts[k]} other=${other.opts[k]}`\n        );\n      }\n    }\n    for (const k of ['inputs', 'outputs'] as const) {\n      if (this[k].length !== other[k].length) {\n        throw new Error(\n          `Transaction/combine: different ${k} length this=${this[k].length} other=${other[k].length}`\n        );\n      }\n    }\n    const thisUnsigned = this.global.unsignedTx ? RawOldTx.encode(this.global.unsignedTx) : P.EMPTY;\n    const otherUnsigned = other.global.unsignedTx\n      ? RawOldTx.encode(other.global.unsignedTx)\n      : P.EMPTY;\n    if (!equalBytes(thisUnsigned, otherUnsigned))\n      throw new Error(`Transaction/combine: different unsigned tx`);\n    this.global = psbt.mergeKeyMap(\n      psbt.PSBTGlobal,\n      this.global,\n      other.global,\n      undefined,\n      this.opts.allowUnknown\n    );\n    for (let i = 0; i < this.inputs.length; i++) this.updateInput(i, other.inputs[i], true);\n    for (let i = 0; i < this.outputs.length; i++) this.updateOutput(i, other.outputs[i], true);\n    return this;\n  }\n  clone(): Transaction {\n    // deepClone probably faster, but this enforces that encoding is valid\n    return Transaction.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);\n  }\n}\n\nexport function PSBTCombine(psbts: Bytes[]): Bytes {\n  if (!psbts || !Array.isArray(psbts) || !psbts.length)\n    throw new Error('PSBTCombine: wrong PSBT list');\n  const tx = Transaction.fromPSBT(psbts[0]);\n  for (let i = 1; i < psbts.length; i++) tx.combine(Transaction.fromPSBT(psbts[i]));\n  return tx.toPSBT();\n}\n\n// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?\nconst HARDENED_OFFSET: number = 0x80000000;\nexport function bip32Path(path: string): number[] {\n  const out: number[] = [];\n  if (!/^[mM]'?/.test(path)) throw new Error('Path must start with \"m\" or \"M\"');\n  if (/^[mM]'?$/.test(path)) return out;\n  const parts = path.replace(/^[mM]'?\\//, '').split('/');\n  for (const c of parts) {\n    const m = /^(\\d+)('?)$/.exec(c);\n    if (!m || m.length !== 3) throw new Error(`Invalid child index: ${c}`);\n    let idx = +m[1];\n    if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) throw new Error('Invalid index');\n    // hardened key\n    if (m[2] === \"'\") idx += HARDENED_OFFSET;\n    out.push(idx);\n  }\n  return out;\n}\n", "import { hex } from '@scure/base';\nimport * as P from 'micro-packed';\nimport { Address, type CustomScript, OutScript, checkScript, tapLeafHash } from './payment.ts';\nimport * as psbt from './psbt.ts';\nimport { CompactSizeLen, RawWitness, Script, VarBytes } from './script.ts';\nimport {\n  SignatureHash,\n  Transaction,\n  type TxOpts,\n  getInputType,\n  getPrevOut,\n  inputBeforeSign,\n  normalizeInput,\n  toVsize,\n} from './transaction.ts';\nimport {\n  type Bytes,\n  NETWORK,\n  PubT,\n  TAPROOT_UNSPENDABLE_KEY,\n  compareBytes,\n  equalBytes,\n  isBytes,\n  sha256,\n  validatePubkey,\n} from './utils.ts';\n\n// UTXO Select\nexport type Output = { address: string; amount: bigint } | { script: Uint8Array; amount: bigint };\nexport type Accumulated =\n  | {\n      indices: number[];\n      fee: bigint | undefined;\n      weight: number;\n      total: bigint;\n    }\n  | undefined;\ntype TapLeafScript = psbt.TransactionInput['tapLeafScript'];\ntype TB = Parameters<typeof psbt.TaprootControlBlock.encode>[0];\nconst encodeTapBlock = (item: TB) => psbt.TaprootControlBlock.encode(item);\n\nfunction iterLeafs(tapLeafScript: TapLeafScript, sigSize: number, customScripts?: CustomScript[]) {\n  if (!tapLeafScript || !tapLeafScript.length) throw new Error('no leafs');\n  const empty = () => new Uint8Array(sigSize);\n  // If user want to select specific leaf, which can signed,\n  // it is possible to remove all other leafs manually.\n  // Sort leafs by control block length.\n  const leafs = tapLeafScript.sort(\n    (a, b) => encodeTapBlock(a[0]).length - encodeTapBlock(b[0]).length\n  );\n  for (const [cb, _script] of leafs) {\n    // Last byte is version\n    const script = _script.slice(0, -1);\n    const ver = _script[_script.length - 1];\n    const outs = OutScript.decode(script);\n\n    let signatures: Bytes[] = [];\n    if (outs.type === 'tr_ms') {\n      const m = outs.m;\n      const n = outs.pubkeys.length - m;\n      for (let i = 0; i < m; i++) signatures.push(empty());\n      for (let i = 0; i < n; i++) signatures.push(P.EMPTY);\n    } else if (outs.type === 'tr_ns') {\n      for (const _pub of outs.pubkeys) signatures.push(empty());\n    } else {\n      if (!customScripts) throw new Error('Finalize: Unknown tapLeafScript');\n      const leafHash = tapLeafHash(script, ver);\n      for (const c of customScripts) {\n        if (!c.finalizeTaproot) continue;\n        const scriptDecoded = Script.decode(script);\n        const csEncoded = c.encode(scriptDecoded);\n        if (csEncoded === undefined) continue;\n        const pubKeys = scriptDecoded.filter((i) => {\n          if (!isBytes(i)) return false;\n          try {\n            validatePubkey(i, PubT.schnorr);\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }) as Bytes[];\n        const finalized = c.finalizeTaproot(\n          script,\n          csEncoded,\n          pubKeys.map((pubKey) => [{ pubKey, leafHash }, empty()])\n        );\n        if (!finalized) continue;\n        return finalized.concat(encodeTapBlock(cb));\n      }\n    }\n    // Witness is stack, so last element will be used first\n    return signatures.reverse().concat([script, encodeTapBlock(cb)]);\n  }\n  throw new Error('there was no witness');\n}\n\nfunction estimateInput(\n  inputType: ReturnType<typeof getInputType>,\n  input: psbt.TransactionInput,\n  opts: TxOpts\n) {\n  let script: Bytes = P.EMPTY;\n  let witness: Bytes[] | undefined;\n\n  // schnorr sig is always 64 bytes. except for cases when sighash is not default!\n  if (inputType.txType === 'taproot') {\n    const SCHNORR_SIG_SIZE = inputType.sighash !== SignatureHash.DEFAULT ? 65 : 64;\n    if (input.tapInternalKey && !equalBytes(input.tapInternalKey, TAPROOT_UNSPENDABLE_KEY)) {\n      witness = [new Uint8Array(SCHNORR_SIG_SIZE)];\n    } else if (input.tapLeafScript) {\n      witness = iterLeafs(input.tapLeafScript, SCHNORR_SIG_SIZE, opts.customScripts);\n    } else throw new Error('estimateInput/taproot: unknown input');\n  } else {\n    // It is possible to grind signatures until it has minimal size (but changing fee value +N satoshi),\n    // which will make estimations exact. But will be very hard for multi sig (need to make sure all signatures has small size).\n    const empty = () => new Uint8Array(72); // max size of sigs\n    const emptyPub = () => new Uint8Array(33); // size of pubkey\n    let inputScript = P.EMPTY;\n    let inputWitness: Uint8Array[] = [];\n    const ltype = inputType.last.type;\n    if (ltype === 'ms') {\n      const m = inputType.last.m;\n      const sig: (number | Uint8Array)[] = [0];\n      for (let i = 0; i < m; i++) sig.push(empty());\n      inputScript = Script.encode(sig);\n    } else if (ltype === 'pk') {\n      // 71 sig + 1 sighash\n      inputScript = Script.encode([empty()]);\n    } else if (ltype === 'pkh') {\n      inputScript = Script.encode([empty(), emptyPub()]);\n    } else if (ltype === 'wpkh') {\n      inputScript = P.EMPTY;\n      inputWitness = [empty(), emptyPub()];\n    } else if (ltype === 'unknown' && !opts.allowUnknownInputs)\n      throw new Error('Unknown inputs are not allowed');\n    if (inputType.type.includes('wsh-')) {\n      // P2WSH\n      if (inputScript.length && inputType.lastScript.length) {\n        inputWitness = Script.decode(inputScript).map((i) => {\n          if (i === 0) return P.EMPTY;\n          if (isBytes(i)) return i;\n          throw new Error(`Wrong witness op=${i}`);\n        });\n      }\n      inputWitness = inputWitness.concat(inputType.lastScript);\n    }\n    if (inputType.txType === 'segwit') witness = inputWitness;\n    if (inputType.type.startsWith('sh-wsh-')) {\n      script = Script.encode([Script.encode([0, new Uint8Array(sha256.outputLen)])]);\n    } else if (inputType.type.startsWith('sh-')) {\n      script = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n    } else if (inputType.type.startsWith('wsh-')) {\n    } else if (inputType.txType !== 'segwit') script = inputScript;\n  }\n  let weight = 160 + 4 * VarBytes.encode(script).length;\n  let hasWitnesses = false;\n  if (witness) {\n    weight += RawWitness.encode(witness).length;\n    hasWitnesses = true;\n  }\n  return { weight, hasWitnesses };\n}\n\n// Exported for tests, internal method\nexport const _cmpBig = (a: bigint, b: bigint): 0 | 1 | -1 => {\n  const n = a - b;\n  if (n < 0n) return -1;\n  else if (n > 0n) return 1;\n  return 0;\n};\n\nexport type EstimatorOpts = TxOpts & {\n  // NOTE: fees less than 1 satoshi per vbyte is not supported. Please create issue if you have valid use case for that.\n  feePerByte: bigint; // satoshi per vbyte\n  changeAddress: string; // address where change will be sent\n  // Optional\n  alwaysChange?: boolean; // always create change, even if less than dust threshold\n  bip69?: boolean; // https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki\n  network?: typeof NETWORK;\n  dust?: number; // how much vbytes considered dust?\n  dustRelayFeeRate?: bigint; // fee per dust byte (DUST_RELAY_TX_FEE)\n  createTx?: boolean; // Create tx inside selection\n  requiredInputs?: psbt.TransactionInputUpdate[]; // these inputs always will be used\n  allowSameUtxo?: boolean; // allow using UTXO multiple times (for test purposes)\n};\n\nfunction getScript(o: Output, opts: TxOpts = {}, network = NETWORK) {\n  let script;\n  if ('script' in o && isBytes(o.script)) {\n    script = o.script;\n  }\n  if ('address' in o) {\n    if (typeof o.address !== 'string')\n      throw new Error(`Estimator: wrong output address=${o.address}`);\n    script = OutScript.encode(Address(network).decode(o.address));\n  }\n  if (!script) throw new Error('Estimator: wrong output script');\n  if (typeof o.amount !== 'bigint')\n    throw new Error(\n      `Estimator: wrong output amount=${\n        o.amount\n      }, should be of type bigint but got ${typeof o.amount}.`\n    );\n  if (script && !opts.allowUnknownOutputs && OutScript.decode(script).type === 'unknown') {\n    throw new Error(\n      'Estimator: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure'\n    );\n  }\n  if (!opts.disableScriptCheck) checkScript(script);\n  return script;\n}\n\n// exact is meaningless without additional accum (will often fail if not possible to find right utxo)\n// -> we support only exact+accum or accum\ntype SortStrategy = 'Newest' | 'Oldest' | 'Smallest' | 'Biggest';\ntype ExactStrategy = `exact${SortStrategy}`;\ntype AccumStrategy = `accum${SortStrategy}`;\n\nexport type SelectionStrategy =\n  | 'all'\n  | 'default'\n  | AccumStrategy\n  | `${ExactStrategy}/${AccumStrategy}`;\n\n// class, because we need to re-use normalized inputs, instead of parsing each time\n// internal stuff, exported for tests only\nexport class _Estimator {\n  private baseWeight: number;\n  private changeWeight: number;\n  private amount: bigint;\n  private requiredIndices: number[] = [];\n  private normalizedInputs: {\n    inputType: ReturnType<typeof getInputType>;\n    normalized: ReturnType<typeof normalizeInput>;\n    amount: bigint;\n    value: bigint;\n    estimate: { weight: number; hasWitnesses: boolean };\n  }[];\n  // Dust used in accumExact + change address algo\n  // - change address: can be smaller for segwit\n  // - accumExact: ???\n  private dust: bigint; // total dust limit (3||opts.dustRelayFeeRate * 182||opts.dust). Default: 546\n  private outputs: Output[];\n  private opts: EstimatorOpts;\n  constructor(inputs: psbt.TransactionInputUpdate[], outputs: Output[], opts: EstimatorOpts) {\n    this.outputs = outputs;\n    this.opts = opts;\n    if (typeof opts.feePerByte !== 'bigint')\n      throw new Error(\n        `Estimator: wrong feePerByte=${\n          opts.feePerByte\n        }, should be of type bigint but got ${typeof opts.feePerByte}.`\n      );\n    // Dust stuff\n    // TODO: think about this more:\n    // - current dust filters tx which cannot be relayed by core\n    // - but actual dust meaning is 'can be this amount spent?'\n    // - dust contains full tx size. but we can use other inputs to pay for outputDust (and parially inputsDust)?\n    // - not sure if we can spent anything with feePerByte: 3. It will be relayed, but will it be mined?\n    // - for now it works exactly as bitcoin-core. But will create change/outputs which cannot be spent (reasonable).\n    // Number of bytes needed to create and spend a UTXO.\n    // https://github.com/bitcoin/bitcoin/blob/27a770b34b8f1dbb84760f442edb3e23a0c2420b/src/policy/policy.cpp#L28-L41\n    const inputsDust = 32 + 4 + 1 + 107 + 4; // NOTE: can be smaller for segwit tx?\n    const outputDust = 34; // NOTE: 'nSize = GetSerializeSize(txout)'\n    const dustBytes = opts.dust === undefined ? BigInt(inputsDust + outputDust) : opts.dust;\n    if (typeof dustBytes !== 'bigint') {\n      throw new Error(\n        `Estimator: wrong dust=${opts.dust}, should be of type bigint but got ${typeof opts.dust}.`\n      );\n    }\n    // 3 sat/vb is the default minimum fee rate used to calculate dust thresholds by bitcoin core.\n    // 3000 sat/kvb -> 3 sat/vb.\n    // https://github.com/bitcoin/bitcoin/blob/27a770b34b8f1dbb84760f442edb3e23a0c2420b/src/policy/policy.h#L55\n    const dustFee = opts.dustRelayFeeRate === undefined ? 3n : opts.dustRelayFeeRate;\n    if (typeof dustFee !== 'bigint') {\n      throw new Error(\n        `Estimator: wrong dustRelayFeeRate=${opts.dustRelayFeeRate}, should be of type bigint but got ${typeof opts.dustRelayFeeRate}.`\n      );\n    }\n    // Dust uses feePerbyte by default, but we allow separate dust fee if needed\n    this.dust = dustBytes * dustFee;\n    if (opts.requiredInputs !== undefined && !Array.isArray(opts.requiredInputs))\n      throw new Error(`Estimator: wrong required inputs=${opts.requiredInputs}`);\n    const network = opts.network || NETWORK;\n    let amount = 0n;\n    // Base weight: tx with outputs, no inputs\n    let baseWeight = 32;\n    for (const o of outputs) {\n      const script = getScript(o, opts, opts.network);\n      baseWeight += 32 + 4 * VarBytes.encode(script).length;\n      amount += o.amount;\n    }\n    if (typeof opts.changeAddress !== 'string')\n      throw new Error(`Estimator: wrong change address=${opts.changeAddress}`);\n    let changeWeight =\n      baseWeight +\n      32 +\n      4 * VarBytes.encode(OutScript.encode(Address(network).decode(opts.changeAddress))).length;\n    baseWeight += 4 * CompactSizeLen.encode(outputs.length).length;\n    // If there a lot of outputs change can change fee\n    changeWeight += 4 * CompactSizeLen.encode(outputs.length + 1).length;\n    this.baseWeight = baseWeight;\n    this.changeWeight = changeWeight;\n    this.amount = amount;\n    const allInputs = Array.from(inputs);\n    if (opts.requiredInputs) {\n      for (let i = 0; i < opts.requiredInputs.length; i++)\n        this.requiredIndices.push(allInputs.push(opts.requiredInputs[i]) - 1);\n    }\n    const inputKeys = new Set();\n    this.normalizedInputs = allInputs.map((i) => {\n      const normalized = normalizeInput(\n        i,\n        undefined,\n        undefined,\n        opts.disableScriptCheck,\n        opts.allowUnknown\n      );\n      inputBeforeSign(normalized); // check fields\n      const key = `${hex.encode(normalized.txid!)}:${normalized.index}`;\n      if (!opts.allowSameUtxo && inputKeys.has(key))\n        throw new Error(`Estimator: same input passed multiple times: ${key}`);\n      inputKeys.add(key);\n      const inputType = getInputType(normalized, opts.allowLegacyWitnessUtxo);\n      const prev = getPrevOut(normalized);\n      const estimate = estimateInput(inputType, normalized, this.opts);\n      const value = prev.amount - opts.feePerByte * BigInt(toVsize(estimate.weight)); // value = amount-fee\n      return { inputType, normalized, amount: prev.amount, value, estimate };\n    });\n  }\n  private checkInputIdx(idx: number) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.normalizedInputs.length)\n      throw new Error(`Wrong input index=${idx}`);\n    return idx;\n  }\n  private sortIndices(indices: number[]) {\n    return indices.slice().sort((a, b) => {\n      const ai = this.normalizedInputs[this.checkInputIdx(a)];\n      const bi = this.normalizedInputs[this.checkInputIdx(b)];\n      const out = compareBytes(ai.normalized.txid!, bi.normalized.txid!);\n      if (out !== 0) return out;\n      return ai.normalized.index! - bi.normalized.index!;\n    });\n  }\n  private sortOutputs(outputs: Output[]) {\n    const scripts = outputs.map((o) => getScript(o, this.opts, this.opts.network));\n    const indices = outputs.map((_, j) => j);\n    return indices.sort((a, b) => {\n      const aa = outputs[a].amount;\n      const ba = outputs[b].amount;\n      const out = _cmpBig(aa, ba);\n      if (out !== 0) return out;\n      return compareBytes(scripts[a], scripts[b]);\n    });\n  }\n  private getSatoshi(weigth: number) {\n    return this.opts.feePerByte * BigInt(toVsize(weigth));\n  }\n\n  // Sort by value instead of amount\n  get biggest(): number[] {\n    return this.normalizedInputs\n      .map((_i, j) => j)\n      .sort((a, b) => _cmpBig(this.normalizedInputs[b].value, this.normalizedInputs[a].value));\n  }\n  get smallest(): number[] {\n    return this.biggest.reverse();\n  }\n  // These assume that UTXO array has historical order.\n  // Otherwise, we have no way to know which tx is oldest\n  // Explorers usually give UTXO in this order.\n  get oldest(): number[] {\n    return this.normalizedInputs.map((_i, j) => j);\n  }\n  get newest(): number[] {\n    return this.oldest.reverse();\n  }\n  // exact - like blackjack from coinselect.\n  // exact(biggest) will select one big utxo which is closer to targetValue+dust, if possible.\n  // If not, it will accumulate largest utxo until value is close to targetValue+dust.\n  accumulate(indices: number[], exact = false, skipNegative = true, all = false): Accumulated {\n    // TODO: how to handle change addresses?\n    // - cost of input\n    // - cost of change output (if input requires change)\n    // - cost of output spending\n    // Dust threshold should be significantly bigger, no point in\n    // creating an output, which cannot be spent.\n    // coinselect doesn't consider cost of output address for dust.\n    // Changing that can actually reduce privacy\n    let weight = this.opts.alwaysChange ? this.changeWeight : this.baseWeight;\n    let hasWitnesses = false;\n    let num = 0;\n    let inputsAmount = 0n;\n    const targetAmount = this.amount;\n    const res: Set<number> = new Set();\n    let fee;\n    for (const idx of this.requiredIndices) {\n      this.checkInputIdx(idx);\n      if (res.has(idx)) throw new Error('required input encountered multiple times'); // should not happen\n      const { estimate, amount } = this.normalizedInputs[idx];\n      let newWeight = weight + estimate.weight;\n      if (!hasWitnesses && estimate.hasWitnesses) newWeight += 2; // enable witness if needed\n      const totalWeight = newWeight + 4 * CompactSizeLen.encode(num).length; // number of outputs can change weight\n      fee = this.getSatoshi(totalWeight);\n      weight = newWeight;\n      if (estimate.hasWitnesses) hasWitnesses = true;\n      num++;\n      inputsAmount += amount;\n      res.add(idx);\n      // inputsAmount is enough to cover cost of tx\n      if (!all && targetAmount + fee <= inputsAmount && num >= this.requiredIndices.length)\n        return { indices: Array.from(res), fee, weight: totalWeight, total: inputsAmount };\n    }\n    for (const idx of indices) {\n      this.checkInputIdx(idx);\n      if (res.has(idx)) continue; // skip required inputs\n      const { estimate, amount, value } = this.normalizedInputs[idx];\n      let newWeight = weight + estimate.weight;\n      if (!hasWitnesses && estimate.hasWitnesses) newWeight += 2; // enable witness if needed\n      const totalWeight = newWeight + 4 * CompactSizeLen.encode(num).length; // number of outputs can change weight\n      fee = this.getSatoshi(totalWeight);\n      // Best case scenario exact(biggest) -> we find biggest output, less than target+threshold\n      if (exact && amount + inputsAmount > targetAmount + fee + this.dust) continue; // skip if added value is bigger than dust\n      // Negative: cost of using input is more than value provided (negative)\n      // By default 'blackjack' mode in coinselect doesn't use that, which means\n      // it will use negative output if sorted by 'smallest'\n      if (skipNegative && value <= 0n) continue;\n      weight = newWeight;\n      if (estimate.hasWitnesses) hasWitnesses = true;\n      num++;\n      inputsAmount += amount;\n      res.add(idx);\n      // inputsAmount is enough to cover cost of tx\n      if (!all && targetAmount + fee <= inputsAmount)\n        return { indices: Array.from(res), fee, weight: totalWeight, total: inputsAmount };\n    }\n    if (all) {\n      const newWeight = weight + 4 * CompactSizeLen.encode(num).length;\n      return { indices: Array.from(res), fee, weight: newWeight, total: inputsAmount };\n    }\n    return undefined;\n  }\n\n  // Works like coinselect default method\n  default(): Accumulated {\n    const { biggest } = this;\n    const exact = this.accumulate(biggest, true, false);\n    if (exact) return exact;\n    return this.accumulate(biggest);\n  }\n\n  private select(strategy: SelectionStrategy) {\n    if (strategy === 'all') {\n      return this.accumulate(\n        this.normalizedInputs.map((_, j) => j),\n        false,\n        true,\n        true\n      );\n    }\n    if (strategy === 'default') return this.default();\n    const data: Record<SortStrategy, () => number[]> = {\n      Oldest: () => this.oldest,\n      Newest: () => this.newest,\n      Smallest: () => this.smallest,\n      Biggest: () => this.biggest,\n    };\n    if (strategy.startsWith('exact')) {\n      const [exactData, left] = strategy.slice(5).split('/') as [SortStrategy, SelectionStrategy];\n      if (!data[exactData]) throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n      strategy = left;\n      const exact = this.accumulate(data[exactData](), true, true);\n      if (exact) return exact;\n    }\n    if (strategy.startsWith('accum')) {\n      const accumData = strategy.slice(5) as SortStrategy;\n      if (!data[accumData]) throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n      return this.accumulate(data[accumData]());\n    }\n    throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n  }\n\n  result(strategy: SelectionStrategy) {\n    const s = this.select(strategy);\n    if (!s) return;\n    const { indices, weight, total } = s;\n    let needChange = this.opts.alwaysChange;\n    const changeWeight = this.opts.alwaysChange\n      ? weight\n      : weight + (this.changeWeight - this.baseWeight);\n\n    const changeFee = this.getSatoshi(changeWeight);\n    let fee = s.fee;\n    const change = total - this.amount - changeFee;\n    if (change > this.dust) needChange = true;\n    let inputs = indices;\n    let outputs = Array.from(this.outputs);\n    if (needChange) {\n      fee = changeFee;\n      // this shouldn't happen!\n      if (change < 0n) throw new Error(`Estimator.result: negative change=${change}`);\n      outputs.push({ address: this.opts.changeAddress, amount: change });\n    }\n    if (this.opts.bip69) {\n      inputs = this.sortIndices(inputs);\n      outputs = this.sortOutputs(outputs).map((i) => outputs[i]);\n    }\n    const res = {\n      inputs: inputs.map((i) => this.normalizedInputs[i].normalized),\n      outputs,\n      fee,\n      weight: this.opts.alwaysChange ? s.weight : changeWeight,\n      change: !!needChange,\n    };\n    let tx;\n    if (this.opts.createTx) {\n      const { inputs, outputs } = res;\n      tx = new Transaction(this.opts);\n      for (const i of inputs) tx.addInput(i);\n      for (const o of outputs)\n        tx.addOutput({ ...o, script: getScript(o, this.opts, this.opts.network) });\n    }\n    return Object.assign(res, { tx });\n    // return { ...res, tx: tx };\n  }\n}\n\nexport function selectUTXO(\n  inputs: psbt.TransactionInputUpdate[],\n  outputs: Output[],\n  strategy: SelectionStrategy,\n  opts: EstimatorOpts\n) {\n  // Defaults: do we want bip69 by default?\n  const _opts = { createTx: true, bip69: true, ...opts };\n  const est = new _Estimator(inputs, outputs, _opts);\n  return est.result(strategy);\n}\n", "/**\n * @module BIP32 hierarchical deterministic (HD) wallets over secp256k1.\n * @example\n * ```js\n * import { HDKey } from \"@scure/bip32\";\n * const hdkey1 = HDKey.fromMasterSeed(seed);\n * const hdkey2 = HDKey.fromExtendedKey(base58key);\n * const hdkey3 = HDKey.fromJSON({ xpriv: string });\n *\n * // props\n * [hdkey1.depth, hdkey1.index, hdkey1.chainCode];\n * console.log(hdkey2.privateKey, hdkey2.publicKey);\n * console.log(hdkey3.derive(\"m/0/2147483647'/1\"));\n * const sig = hdkey3.sign(hash);\n * hdkey3.verify(hash, sig);\n * ```\n */\n/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { mod } from '@noble/curves/abstract/modular';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/legacy';\nimport { sha256, sha512 } from '@noble/hashes/sha2';\nimport {\n  abytes,\n  bytesToHex,\n  concatBytes,\n  createView,\n  hexToBytes,\n  utf8ToBytes,\n} from '@noble/hashes/utils';\nimport { createBase58check } from '@scure/base';\n\nconst Point = secp.ProjectivePoint;\nconst base58check = createBase58check(sha256);\n\nfunction bytesToNumber(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  const h = bytes.length === 0 ? '0' : bytesToHex(bytes);\n  return BigInt('0x' + h);\n}\n\nfunction numberToBytes(num: bigint): Uint8Array {\n  if (typeof num !== 'bigint') throw new Error('bigint expected');\n  return hexToBytes(num.toString(16).padStart(64, '0'));\n}\n\nconst MASTER_SECRET = utf8ToBytes('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS: Versions = { private: 0x0488ade4, public: 0x0488b21e };\nexport const HARDENED_OFFSET: number = 0x80000000;\n\nexport interface Versions {\n  private: number;\n  public: number;\n}\n\nconst hash160 = (data: Uint8Array) => ripemd160(sha256(data));\nconst fromU32 = (data: Uint8Array) => createView(data).getUint32(0, false);\nconst toU32 = (n: number) => {\n  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n    throw new Error('invalid number, should be from 0 to 2**32-1, got ' + n);\n  }\n  const buf = new Uint8Array(4);\n  createView(buf).setUint32(0, n, false);\n  return buf;\n};\n\ninterface HDKeyOpt {\n  versions?: Versions;\n  depth?: number;\n  index?: number;\n  parentFingerprint?: number;\n  chainCode?: Uint8Array;\n  publicKey?: Uint8Array;\n  privateKey?: Uint8Array | bigint;\n}\n\nexport class HDKey {\n  get fingerprint(): number {\n    if (!this.pubHash) {\n      throw new Error('No publicKey set!');\n    }\n    return fromU32(this.pubHash);\n  }\n  get identifier(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get pubKeyHash(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get privateKey(): Uint8Array | null {\n    return this.privKeyBytes || null;\n  }\n  get publicKey(): Uint8Array | null {\n    return this.pubKey || null;\n  }\n  get privateExtendedKey(): string {\n    const priv = this.privateKey;\n    if (!priv) {\n      throw new Error('No private key');\n    }\n    return base58check.encode(\n      this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv))\n    );\n  }\n  get publicExtendedKey(): string {\n    if (!this.pubKey) {\n      throw new Error('No public key');\n    }\n    return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n  }\n\n  public static fromMasterSeed(seed: Uint8Array, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    abytes(seed);\n    if (8 * seed.length < 128 || 8 * seed.length > 512) {\n      throw new Error(\n        'HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got ' +\n          seed.length\n      );\n    }\n    const I = hmac(sha512, MASTER_SECRET, seed);\n    return new HDKey({\n      versions,\n      chainCode: I.slice(32),\n      privateKey: I.slice(0, 32),\n    });\n  }\n\n  public static fromExtendedKey(base58key: string, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    const keyBuffer: Uint8Array = base58check.decode(base58key);\n    const keyView = createView(keyBuffer);\n    const version = keyView.getUint32(0, false);\n    const opt = {\n      versions,\n      depth: keyBuffer[4],\n      parentFingerprint: keyView.getUint32(5, false),\n      index: keyView.getUint32(9, false),\n      chainCode: keyBuffer.slice(13, 45),\n    };\n    const key = keyBuffer.slice(45);\n    const isPriv = key[0] === 0;\n    if (version !== versions[isPriv ? 'private' : 'public']) {\n      throw new Error('Version mismatch');\n    }\n    if (isPriv) {\n      return new HDKey({ ...opt, privateKey: key.slice(1) });\n    } else {\n      return new HDKey({ ...opt, publicKey: key });\n    }\n  }\n\n  public static fromJSON(json: { xpriv: string }): HDKey {\n    return HDKey.fromExtendedKey(json.xpriv);\n  }\n  public readonly versions: Versions;\n  public readonly depth: number = 0;\n  public readonly index: number = 0;\n  public readonly chainCode: Uint8Array | null = null;\n  public readonly parentFingerprint: number = 0;\n  private privKey?: bigint;\n  private privKeyBytes?: Uint8Array;\n  private pubKey?: Uint8Array;\n  private pubHash: Uint8Array | undefined;\n\n  constructor(opt: HDKeyOpt) {\n    if (!opt || typeof opt !== 'object') {\n      throw new Error('HDKey.constructor must not be called directly');\n    }\n    this.versions = opt.versions || BITCOIN_VERSIONS;\n    this.depth = opt.depth || 0;\n    this.chainCode = opt.chainCode || null;\n    this.index = opt.index || 0;\n    this.parentFingerprint = opt.parentFingerprint || 0;\n    if (!this.depth) {\n      if (this.parentFingerprint || this.index) {\n        throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n      }\n    }\n    if (opt.publicKey && opt.privateKey) {\n      throw new Error('HDKey: publicKey and privateKey at same time.');\n    }\n    if (opt.privateKey) {\n      if (!secp.utils.isValidPrivateKey(opt.privateKey)) {\n        throw new Error('Invalid private key');\n      }\n      this.privKey =\n        typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n      this.privKeyBytes = numberToBytes(this.privKey);\n      this.pubKey = secp.getPublicKey(opt.privateKey, true);\n    } else if (opt.publicKey) {\n      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n    } else {\n      throw new Error('HDKey: no public or private key provided');\n    }\n    this.pubHash = hash160(this.pubKey);\n  }\n\n  public derive(path: string): HDKey {\n    if (!/^[mM]'?/.test(path)) {\n      throw new Error('Path must start with \"m\" or \"M\"');\n    }\n    if (/^[mM]'?$/.test(path)) {\n      return this;\n    }\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    // tslint:disable-next-line\n    let child: HDKey = this;\n    for (const c of parts) {\n      const m = /^(\\d+)('?)$/.exec(c);\n      const m1 = m && m[1];\n      if (!m || m.length !== 3 || typeof m1 !== 'string')\n        throw new Error('invalid child index: ' + c);\n      let idx = +m1;\n      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n        throw new Error('Invalid index');\n      }\n      // hardened key\n      if (m[2] === \"'\") {\n        idx += HARDENED_OFFSET;\n      }\n      child = child.deriveChild(idx);\n    }\n    return child;\n  }\n\n  public deriveChild(index: number): HDKey {\n    if (!this.pubKey || !this.chainCode) {\n      throw new Error('No publicKey or chainCode set');\n    }\n    let data = toU32(index);\n    if (index >= HARDENED_OFFSET) {\n      // Hardened\n      const priv = this.privateKey;\n      if (!priv) {\n        throw new Error('Could not derive hardened child key');\n      }\n      // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n      data = concatBytes(new Uint8Array([0]), priv, data);\n    } else {\n      // Normal child: serP(point(kpar)) || ser32(index)\n      data = concatBytes(this.pubKey, data);\n    }\n    const I = hmac(sha512, this.chainCode, data);\n    const childTweak = bytesToNumber(I.slice(0, 32));\n    const chainCode = I.slice(32);\n    if (!secp.utils.isValidPrivateKey(childTweak)) {\n      throw new Error('Tweak bigger than curve order');\n    }\n    const opt: HDKeyOpt = {\n      versions: this.versions,\n      chainCode,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint,\n      index,\n    };\n    try {\n      // Private parent key -> private child key\n      if (this.privateKey) {\n        const added = mod(this.privKey! + childTweak, secp.CURVE.n);\n        if (!secp.utils.isValidPrivateKey(added)) {\n          throw new Error('The tweak was out of range or the resulted private key is invalid');\n        }\n        opt.privateKey = added;\n      } else {\n        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n        // Cryptographically impossible: hmac-sha512 preimage would need to be found\n        if (added.equals(Point.ZERO)) {\n          throw new Error('The tweak was equal to negative P, which made the result key invalid');\n        }\n        opt.publicKey = added.toRawBytes(true);\n      }\n      return new HDKey(opt);\n    } catch (err) {\n      return this.deriveChild(index + 1);\n    }\n  }\n\n  public sign(hash: Uint8Array): Uint8Array {\n    if (!this.privateKey) {\n      throw new Error('No privateKey set!');\n    }\n    abytes(hash, 32);\n    return secp.sign(hash, this.privKey!).toCompactRawBytes();\n  }\n\n  public verify(hash: Uint8Array, signature: Uint8Array): boolean {\n    abytes(hash, 32);\n    abytes(signature, 64);\n    if (!this.publicKey) {\n      throw new Error('No publicKey set!');\n    }\n    let sig;\n    try {\n      sig = secp.Signature.fromCompact(signature);\n    } catch (error) {\n      return false;\n    }\n    return secp.verify(sig, hash, this.publicKey);\n  }\n\n  public wipePrivateData(): this {\n    this.privKey = undefined;\n    if (this.privKeyBytes) {\n      this.privKeyBytes.fill(0);\n      this.privKeyBytes = undefined;\n    }\n    return this;\n  }\n  public toJSON(): { xpriv: string; xpub: string } {\n    return {\n      xpriv: this.privateExtendedKey,\n      xpub: this.publicExtendedKey,\n    };\n  }\n\n  private serialize(version: number, key: Uint8Array) {\n    if (!this.chainCode) {\n      throw new Error('No chainCode set');\n    }\n    abytes(key, 33);\n    // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    return concatBytes(\n      toU32(version),\n      new Uint8Array([this.depth]),\n      toU32(this.parentFingerprint),\n      toU32(this.index),\n      this.chainCode,\n      key\n    );\n  }\n}\n", "/**\n * PBKDF (RFC 2898). Can be used to create a key from password and salt.\n * @module\n */\nimport { hmac } from './hmac.ts';\n// prettier-ignore\nimport {\n  ahash, anumber,\n  asyncLoop, checkOpts, clean, createView, Hash, kdfInputToBytes,\n  type CHash,\n  type KDFInput\n} from './utils.ts';\n\nexport type Pbkdf2Opt = {\n  c: number; // Iterations\n  dkLen?: number; // Desired key length in bytes (Intended output length in octets of the derived key\n  asyncTick?: number; // Maximum time in ms for which async function can block execution\n};\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash: CHash, _password: KDFInput, _salt: KDFInput, _opts: Pbkdf2Opt) {\n  ahash(hash);\n  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n  const { c, dkLen, asyncTick } = opts;\n  anumber(c);\n  anumber(dkLen);\n  anumber(asyncTick);\n  if (c < 1) throw new Error('iterations (c) should be >= 1');\n  const password = kdfInputToBytes(_password);\n  const salt = kdfInputToBytes(_salt);\n  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n  const DK = new Uint8Array(dkLen);\n  // U1 = PRF(Password, Salt + INT_32_BE(i))\n  const PRF = hmac.create(hash, password);\n  const PRFSalt = PRF._cloneInto().update(salt);\n  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\n\nfunction pbkdf2Output<T extends Hash<T>>(\n  PRF: Hash<T>,\n  PRFSalt: Hash<T>,\n  DK: Uint8Array,\n  prfW: Hash<T>,\n  u: Uint8Array\n) {\n  PRF.destroy();\n  PRFSalt.destroy();\n  if (prfW) prfW.destroy();\n  clean(u);\n  return DK;\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n */\nexport function pbkdf2(\n  hash: CHash,\n  password: KDFInput,\n  salt: KDFInput,\n  opts: Pbkdf2Opt\n): Uint8Array {\n  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + \u22EF + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ \u22EF ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    for (let ui = 1; ui < c; ui++) {\n      // Uc = PRF(Password, Uc\u22121)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    }\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.\n * @example\n * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });\n */\nexport async function pbkdf2Async(\n  hash: CHash,\n  password: KDFInput,\n  salt: KDFInput,\n  opts: Pbkdf2Opt\n): Promise<Uint8Array> {\n  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + \u22EF + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ \u22EF ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    await asyncLoop(c - 1, asyncTick, () => {\n      // Uc = PRF(Password, Uc\u22121)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    });\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n", "/**\n * Audited & minimal JS implementation of\n * [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\n * @module\n * @example\n```js\nimport * as bip39 from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nconst mn = bip39.generateMnemonic(wordlist);\nconsole.log(mn);\nconst ent = bip39.mnemonicToEntropy(mn, wordlist)\nbip39.entropyToMnemonic(ent, wordlist);\nbip39.validateMnemonic(mn, wordlist);\nawait bip39.mnemonicToSeed(mn, 'password');\nbip39.mnemonicToSeedSync(mn, 'password');\n\n// Wordlists\nimport { wordlist as czech } from '@scure/bip39/wordlists/czech';\nimport { wordlist as english } from '@scure/bip39/wordlists/english';\nimport { wordlist as french } from '@scure/bip39/wordlists/french';\nimport { wordlist as italian } from '@scure/bip39/wordlists/italian';\nimport { wordlist as japanese } from '@scure/bip39/wordlists/japanese';\nimport { wordlist as korean } from '@scure/bip39/wordlists/korean';\nimport { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';\nimport { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';\nimport { wordlist as spanish } from '@scure/bip39/wordlists/spanish';\nimport { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';\n```\n */\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2';\nimport { sha256, sha512 } from '@noble/hashes/sha2';\nimport { abytes, anumber, randomBytes } from '@noble/hashes/utils';\nimport { utils as baseUtils } from '@scure/base';\n// Japanese wordlist\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError('invalid mnemonic type: ' + typeof str);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction aentropy(ent) {\n    abytes(ent, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function generateMnemonic(wordlist, strength = 128) {\n    anumber(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic(randomBytes(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([(sha256(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Wordlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error('wordlist: non-string element: ' + i);\n    });\n    return baseUtils.chain(baseUtils.checksum(1, calcChecksum), baseUtils.radix2(11, true), baseUtils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    aentropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function entropyToMnemonic(entropy, wordlist) {\n    aentropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst psalt = (passphrase) => nfkd('mnemonic' + passphrase);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeed(mnemonic, passphrase = '') {\n    return pbkdf2Async(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return pbkdf2(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n", "export const wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split('\\n');\n", "import * as btc from '@scure/btc-signer';\r\nimport { HDKey } from '@scure/bip32';\r\nimport * as bip39 from '@scure/bip39';\r\nimport { wordlist as englishWordlist } from '@scure/bip39/wordlists/english';\r\nimport { secp256k1 } from '@noble/curves/secp256k1';\r\nimport { hex } from '@scure/base';\r\n\r\ntype NetworkName = 'mainnet' | 'testnet';\r\n\r\ntype UTXO = {\r\n  txid: string; // hex\r\n  vout: number;\r\n  value: number; // sats\r\n  status?: { confirmed?: boolean; block_height?: number };\r\n};\r\n\r\ntype FeeEstimates = Record<string, number>;\r\n\r\ntype BuildAndSignParams = {\r\n  mnemonic: string;\r\n  toAddress?: string;\r\n  amountSats?: number;\r\n  outputs?: ({ address: string; amountSats: number } | { scriptHex: string; amountSats: number })[];\r\n  changeAddress?: string;\r\n  feeRateSatPerVb?: number;\r\n  utxos: UTXO[];\r\n  network?: NetworkName;\r\n  // Optional: allow spending from non-default derivation.\r\n  account?: number; // BIP84 account (default 0)\r\n  index?: number; // BIP84 external index (default 0)\r\n};\r\n\r\nasync function sha256Bytes(message: string): Promise<Uint8Array> {\r\n  const enc = new TextEncoder();\r\n  const digest = await globalThis.crypto.subtle.digest('SHA-256', enc.encode(String(message)));\r\n  return new Uint8Array(digest);\r\n}\r\n\r\nfunction generateSecp256k1KeyPair(): { privateKeyHex: string; publicKeyHex: string } {\r\n  const priv = secp256k1.utils.randomPrivateKey();\r\n  const pub = secp256k1.getPublicKey(priv, true);\r\n  return { privateKeyHex: hex.encode(priv), publicKeyHex: hex.encode(pub) };\r\n}\r\n\r\nasync function signMessageSha256(message: string, privateKeyHex: string): Promise<string> {\r\n  const hash = await sha256Bytes(String(message));\r\n  const sig: any = (secp256k1 as any).sign(hash, hex.decode(String(privateKeyHex)));\r\n  const sigBytes: Uint8Array = sig?.toCompactRawBytes ? sig.toCompactRawBytes() : sig;\r\n  return hex.encode(sigBytes);\r\n}\r\n\r\nfunction getNetwork(network?: NetworkName) {\r\n  return network === 'testnet' ? btc.TEST_NETWORK : btc.NETWORK;\r\n}\r\n\r\nfunction getBip84Path(network?: NetworkName, account = 0, index = 0) {\r\n  // BIP84: m/84'/{coin_type}'/{account}'/0/{index}\r\n  // coin_type: 0 mainnet, 1 testnet\r\n  const coinType = network === 'testnet' ? 1 : 0;\r\n  return `m/84'/${coinType}'/${account}'/0/${index}`;\r\n}\r\n\r\nfunction getSeedFromMnemonic(mnemonic: string): Uint8Array {\r\n  if (!bip39.validateMnemonic(mnemonic.trim(), englishWordlist)) {\r\n    throw new Error('Invalid mnemonic');\r\n  }\r\n  return bip39.mnemonicToSeedSync(mnemonic.trim());\r\n}\r\n\r\nfunction derivePrivKeyBytesFromMnemonic(mnemonic: string, network?: NetworkName, account = 0, index = 0): Uint8Array {\r\n  const seed = getSeedFromMnemonic(mnemonic);\r\n  const root = HDKey.fromMasterSeed(seed);\r\n  const path = getBip84Path(network, account, index);\r\n  const child = root.derive(path);\r\n  if (!child.privateKey) throw new Error('Failed to derive private key');\r\n  return child.privateKey;\r\n}\r\n\r\nfunction getP2WPKHAddressFromMnemonic(mnemonic: string, network?: NetworkName, account = 0, index = 0): string {\r\n  const priv = derivePrivKeyBytesFromMnemonic(mnemonic, network, account, index);\r\n  const pub = secp256k1.getPublicKey(priv, true);\r\n  const pay = btc.p2wpkh(pub, getNetwork(network));\r\n  if (!pay.address) throw new Error('Failed to derive address');\r\n  return pay.address;\r\n}\r\n\r\nfunction getPublicKeyFromMnemonic(mnemonic: string, network?: NetworkName, account = 0, index = 0): string {\r\n  const priv = derivePrivKeyBytesFromMnemonic(mnemonic, network, account, index);\r\n  const pub = secp256k1.getPublicKey(priv, true);\r\n  return hex.encode(pub);\r\n}\r\n\r\nfunction getPrivateKeyFromMnemonic(mnemonic: string, network?: NetworkName, account = 0, index = 0): string {\r\n  const priv = derivePrivKeyBytesFromMnemonic(mnemonic, network, account, index);\r\n  return hex.encode(priv);\r\n}\r\n\r\n// Derive a separate messaging keypair from mnemonic (NOT the BTC spending key)\r\n// Uses domain separation: SHA256(\"Autho:Messaging:v1\" || seed) to ensure independence\r\nasync function deriveMessagingKeyPair(mnemonic: string): Promise<{ publicKeyHex: string; privateKeyHex: string }> {\r\n  const seed = getSeedFromMnemonic(mnemonic);\r\n  // Domain separation: hash with a unique prefix so this key can never be confused with BTC key\r\n  const domainPrefix = new TextEncoder().encode('Autho:Messaging:v1:');\r\n  const combined = new Uint8Array(domainPrefix.length + seed.length);\r\n  combined.set(domainPrefix, 0);\r\n  combined.set(seed, domainPrefix.length);\r\n  \r\n  // SHA-256 to get 32 bytes for the messaging private key\r\n  const hashBuffer = await globalThis.crypto.subtle.digest('SHA-256', combined);\r\n  const messagingPrivateKey = new Uint8Array(hashBuffer);\r\n  \r\n  // Derive public key using secp256k1 (compatible with nacl.box after conversion)\r\n  const messagingPublicKey = secp256k1.getPublicKey(messagingPrivateKey, true);\r\n  \r\n  return {\r\n    publicKeyHex: hex.encode(messagingPublicKey),\r\n    privateKeyHex: hex.encode(messagingPrivateKey),\r\n  };\r\n}\r\n\r\n// Synchronous version for environments where async isn't convenient\r\nfunction deriveMessagingKeyPairSync(mnemonic: string): { publicKeyHex: string; privateKeyHex: string } {\r\n  const seed = getSeedFromMnemonic(mnemonic);\r\n  // Domain separation\r\n  const domainPrefix = new TextEncoder().encode('Autho:Messaging:v1:');\r\n  const combined = new Uint8Array(domainPrefix.length + seed.length);\r\n  combined.set(domainPrefix, 0);\r\n  combined.set(seed, domainPrefix.length);\r\n  \r\n  // Use a simple SHA-256 implementation for sync (already have sha256Bytes async, need sync)\r\n  // For now, use the seed directly with domain separation via HKDF-like construction\r\n  // Actually, let's use the fact that we can do sync SHA-256 via a fallback\r\n  const messagingPrivateKey = sha256Sync(combined);\r\n  const messagingPublicKey = secp256k1.getPublicKey(messagingPrivateKey, true);\r\n  \r\n  return {\r\n    publicKeyHex: hex.encode(messagingPublicKey),\r\n    privateKeyHex: hex.encode(messagingPrivateKey),\r\n  };\r\n}\r\n\r\n// Simple synchronous SHA-256 for browser use\r\nfunction sha256Sync(bytes: Uint8Array): Uint8Array {\r\n  const K = [\r\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\r\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\r\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\r\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\r\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\r\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\r\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\r\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\r\n  ];\r\n  const rotr = (x: number, n: number) => (x >>> n) | (x << (32 - n));\r\n\r\n  const bitLen = bytes.length * 8;\r\n  const withOne = bytes.length + 1;\r\n  const padLen = (withOne % 64 <= 56) ? (56 - (withOne % 64)) : (56 + (64 - (withOne % 64)));\r\n  const totalLen = withOne + padLen + 8;\r\n  const msg = new Uint8Array(totalLen);\r\n  msg.set(bytes, 0);\r\n  msg[bytes.length] = 0x80;\r\n  const view = new DataView(msg.buffer);\r\n  view.setUint32(totalLen - 8, Math.floor(bitLen / 2 ** 32), false);\r\n  view.setUint32(totalLen - 4, bitLen >>> 0, false);\r\n\r\n  let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;\r\n  let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;\r\n\r\n  const w = new Uint32Array(64);\r\n  for (let i = 0; i < msg.length; i += 64) {\r\n    for (let t = 0; t < 16; t++) w[t] = view.getUint32(i + t * 4, false);\r\n    for (let t = 16; t < 64; t++) {\r\n      const s0 = (rotr(w[t - 15], 7) ^ rotr(w[t - 15], 18) ^ (w[t - 15] >>> 3)) >>> 0;\r\n      const s1 = (rotr(w[t - 2], 17) ^ rotr(w[t - 2], 19) ^ (w[t - 2] >>> 10)) >>> 0;\r\n      w[t] = (w[t - 16] + s0 + w[t - 7] + s1) >>> 0;\r\n    }\r\n\r\n    let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7;\r\n    for (let t = 0; t < 64; t++) {\r\n      const S1 = (rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)) >>> 0;\r\n      const ch = ((e & f) ^ (~e & g)) >>> 0;\r\n      const temp1 = (h + S1 + ch + K[t] + w[t]) >>> 0;\r\n      const S0 = (rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)) >>> 0;\r\n      const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0;\r\n      const temp2 = (S0 + maj) >>> 0;\r\n      h = g; g = f; f = e; e = (d + temp1) >>> 0;\r\n      d = c; c = b; b = a; a = (temp1 + temp2) >>> 0;\r\n    }\r\n    h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0;\r\n    h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0;\r\n  }\r\n\r\n  const out = new Uint8Array(32);\r\n  const outView = new DataView(out.buffer);\r\n  outView.setUint32(0, h0, false); outView.setUint32(4, h1, false);\r\n  outView.setUint32(8, h2, false); outView.setUint32(12, h3, false);\r\n  outView.setUint32(16, h4, false); outView.setUint32(20, h5, false);\r\n  outView.setUint32(24, h6, false); outView.setUint32(28, h7, false);\r\n  return out;\r\n}\r\n\r\nfunction generateMnemonic24(): string {\r\n  return bip39.generateMnemonic(englishWordlist, 256);\r\n}\r\n\r\nfunction normalizeUtxosForTx(mnemonic: string, utxos: UTXO[], network?: NetworkName, account = 0, index = 0) {\r\n  const priv = derivePrivKeyBytesFromMnemonic(mnemonic, network, account, index);\r\n  const pub = secp256k1.getPublicKey(priv, true);\r\n  const spend = btc.p2wpkh(pub, getNetwork(network));\r\n\r\n  return utxos.map((u) => ({\r\n    ...spend,\r\n    txid: hex.decode(u.txid),\r\n    index: u.vout,\r\n    witnessUtxo: {\r\n      script: spend.script,\r\n      amount: BigInt(u.value),\r\n    },\r\n  }));\r\n}\r\n\r\nfunction pickFeeRate(feeEstimates: FeeEstimates | null | undefined): number {\r\n  // Esplora fee-estimates returns { \"1\": sats/vbyte, \"2\": ..., \"6\": ... }\r\n  // We'll prefer 2-block, then 1-block, then 6.\r\n  const candidates = ['2', '1', '6', '3'];\r\n  for (const k of candidates) {\r\n    const v = feeEstimates?.[k];\r\n    if (typeof v === 'number' && isFinite(v) && v > 0) return v;\r\n  }\r\n  return 2; // conservative fallback\r\n}\r\n\r\nfunction buildAndSignP2WPKH(params: BuildAndSignParams): { txHex: string; txid: string; feeSats: number } {\r\n  const network = params.network || 'mainnet';\r\n  const account = params.account ?? 0;\r\n  const index = params.index ?? 0;\r\n\r\n  const outputsInput = Array.isArray(params.outputs) && params.outputs.length > 0 ? params.outputs : null;\r\n  if (!outputsInput) {\r\n    if (!params.toAddress) throw new Error('Missing toAddress');\r\n    if (!Number.isFinite(params.amountSats) || (params.amountSats as number) <= 0) throw new Error('Invalid amountSats');\r\n  }\r\n\r\n  const hasScriptOutputs = !!(outputsInput && outputsInput.some((o: any) => o && typeof (o as any).scriptHex === 'string'));\r\n\r\n  const changeAddress = params.changeAddress || getP2WPKHAddressFromMnemonic(params.mnemonic, network, account, index);\r\n\r\n  const requestedFeeRate = Number(params.feeRateSatPerVb ?? 2);\r\n  const hasRequestedFeeRate = Number.isFinite(requestedFeeRate) && requestedFeeRate > 0;\r\n  const needsFineTuning = hasRequestedFeeRate && Math.abs(requestedFeeRate - Math.round(requestedFeeRate)) > 1e-9;\r\n\r\n  // The underlying UTXO selection requires integer feePerByte >= 1.\r\n  // We'll select at ceil(feeRate) sat/vB, then (if needed) adjust the change output to hit the exact fee.\r\n  const selectionFeePerByte = BigInt(Math.max(1, Math.ceil(hasRequestedFeeRate ? requestedFeeRate : 2)));\r\n\r\n  const utxo = normalizeUtxosForTx(params.mnemonic, params.utxos || [], network, account, index);\r\n  const outputs = outputsInput\r\n    ? outputsInput.map((o: any) => {\r\n        const amountSats = Number(o?.amountSats || 0);\r\n        if (!Number.isFinite(amountSats) || amountSats < 0) throw new Error('Invalid output amountSats');\r\n\r\n        if (typeof o?.scriptHex === 'string') {\r\n          const scriptHex = String(o.scriptHex || '').trim().toLowerCase();\r\n          if (!/^[0-9a-f]*$/.test(scriptHex) || scriptHex.length < 2) {\r\n            throw new Error('Invalid output scriptHex');\r\n          }\r\n          return { script: hex.decode(scriptHex), amount: BigInt(amountSats) };\r\n        }\r\n\r\n        const address = String(o?.address || '').trim();\r\n        if (!address) throw new Error('Invalid output address');\r\n        if (!Number.isFinite(amountSats) || amountSats <= 0) throw new Error('Invalid output amountSats');\r\n        return { address, amount: BigInt(amountSats) };\r\n      })\r\n    : [{ address: String(params.toAddress), amount: BigInt(Number(params.amountSats)) }];\r\n\r\n  const selected = btc.selectUTXO(utxo as any, outputs as any, 'default', {\r\n    changeAddress,\r\n    feePerByte: selectionFeePerByte,\r\n    alwaysChange: needsFineTuning,\r\n    bip69: true,\r\n    createTx: true,\r\n    allowUnknownOutputs: hasScriptOutputs,\r\n    network: getNetwork(network),\r\n  } as any);\r\n\r\n  if (!selected?.tx) {\r\n    throw new Error('Insufficient funds');\r\n  }\r\n\r\n  const priv = derivePrivKeyBytesFromMnemonic(params.mnemonic, network, account, index);\r\n\r\n  // If user requested a fractional sat/vB (e.g. 0.2/0.5/2.3), adjust the change output so the final fee matches\r\n  // ceil(vsize * feeRate). Fee must still be integer sats.\r\n  if (needsFineTuning) {\r\n    // Compute actual vsize using a signed clone (signature sizes can vary by a byte).\r\n    const tmp = selected.tx.clone();\r\n    tmp.sign(priv);\r\n    tmp.finalize();\r\n    const vsize = tmp.vsize;\r\n    const desiredFeeSats = BigInt(Math.max(0, Math.ceil(requestedFeeRate * vsize)));\r\n\r\n    // Find the change output by script (change address)\r\n    const changeScript = btc.OutScript.encode(btc.Address(getNetwork(network)).decode(changeAddress));\r\n    let changeOutIdx = -1;\r\n    for (let i = 0; i < selected.tx.outputsLength; i++) {\r\n      const out = selected.tx.getOutput(i);\r\n      const script = (out as any)?.script;\r\n      if (script && hex.encode(script) === hex.encode(changeScript)) {\r\n        changeOutIdx = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (changeOutIdx === -1) {\r\n      throw new Error('Cannot set fractional sat/vB fee: missing change output. Try adding funds or using a higher fee.');\r\n    }\r\n\r\n    const currentFeeSats = BigInt(selected.tx.fee);\r\n    if (currentFeeSats !== desiredFeeSats) {\r\n      const changeOut = selected.tx.getOutput(changeOutIdx);\r\n      const currentChange = BigInt((changeOut as any)?.amount || 0n);\r\n\r\n      if (currentFeeSats > desiredFeeSats) {\r\n        const delta = currentFeeSats - desiredFeeSats; // reduce fee by increasing change\r\n        const newChange = currentChange + delta;\r\n        selected.tx.updateOutput(changeOutIdx, { ...changeOut, amount: newChange } as any, true);\r\n      } else {\r\n        const delta = desiredFeeSats - currentFeeSats; // increase fee by decreasing change\r\n        const newChange = currentChange - delta;\r\n        if (newChange <= 0n) {\r\n          throw new Error('Cannot set fractional sat/vB fee: not enough change available. Try adding funds or using a higher fee.');\r\n        }\r\n        selected.tx.updateOutput(changeOutIdx, { ...changeOut, amount: newChange } as any, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  selected.tx.sign(priv);\r\n  selected.tx.finalize();\r\n\r\n  return {\r\n    txHex: selected.tx.hex,\r\n    txid: selected.tx.id,\r\n    feeSats: Number(selected.tx.fee),\r\n  };\r\n}\r\n\r\ndeclare global {\r\n  interface Window {\r\n    AuthoBTC?: any;\r\n  }\r\n}\r\n\r\nwindow.AuthoBTC = {\r\n  version: '1.1.0',\r\n  getAddressFromMnemonic: (mnemonic: string, network?: NetworkName, account?: number, index?: number) =>\r\n    getP2WPKHAddressFromMnemonic(mnemonic, network, account ?? 0, index ?? 0),\r\n  getPublicKeyFromMnemonic: (mnemonic: string, network?: NetworkName, account?: number, index?: number) =>\r\n    getPublicKeyFromMnemonic(mnemonic, network, account ?? 0, index ?? 0),\r\n  getPrivateKeyFromMnemonic: (mnemonic: string, network?: NetworkName, account?: number, index?: number) =>\r\n    getPrivateKeyFromMnemonic(mnemonic, network, account ?? 0, index ?? 0),\r\n  // Messaging keypair (separate from BTC spending key, uses domain separation)\r\n  deriveMessagingKeyPair: (mnemonic: string) => deriveMessagingKeyPair(mnemonic),\r\n  deriveMessagingKeyPairSync: (mnemonic: string) => deriveMessagingKeyPairSync(mnemonic),\r\n  generateMnemonic24: () => generateMnemonic24(),\r\n  buildAndSignP2WPKH: (params: BuildAndSignParams) => buildAndSignP2WPKH(params),\r\n  generateSecp256k1KeyPair: () => generateSecp256k1KeyPair(),\r\n  signMessageSha256: (message: string, privateKeyHex: string) => signMessageSha256(message, privateKeyHex),\r\n};\r\n"],
  "mappings": "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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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",
  "names": ["hex", "array", "view", "_32n", "view", "view", "prefix", "num", "hex", "hex", "_0n", "_1n", "_0n", "_1n", "gcd", "num", "_0n", "_1n", "_1n", "_0n", "_1n", "num", "num", "_1n", "_0n", "_1n", "window", "Point", "wbits", "_0n", "num", "_2n", "_0n", "_1n", "def", "hex", "_3n", "_4n", "CURVE_ORDER", "pointToBytes", "Point", "endo", "Point", "utils", "randomBytes", "hmac", "CURVE_ORDER", "_1n", "num", "r", "s", "hex", "_2n", "_0n", "Point", "_0n", "_1n", "_2n", "_3n", "view", "isBytes", "abytes", "anumber", "wrap", "padding", "num", "sha256", "prefix", "isBytes", "hasHexBuiltin", "abytes", "isBytes", "concatBytes", "createView", "num", "utils", "invert", "i", "clean", "view", "view", "view", "isBytes", "prefix", "isBytes", "def", "isBytes", "isBytes", "isBytes", "utils", "concatBytes", "equalBytes", "concatBytes", "PubT", "isBytes", "OP", "isBytes", "flag", "num", "num", "value", "val", "add", "k", "equalBytes", "isBytes", "equalBytes", "prefix", "concatBytes", "data", "def", "isBytes", "SignatureHash", "SigHash", "equalBytes", "concatBytes", "num", "isBytes", "equalBytes", "num", "inputs", "outputs", "Point", "base58check", "num", "hash160", "view", "wordlist", "normalize", "normalize", "rotr", "bitLen", "view"]
}
